/*! jQuery v1.12.3 | (c) jQuery Foundation | jquery.org/license */
!function (a, b) { "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) { if (!a.document) throw new Error("jQuery requires a window with a document"); return b(a) } : b(a) }("undefined" != typeof window ? window : this, function (a, b) {
    var c = [], d = a.document, e = c.slice, f = c.concat, g = c.push, h = c.indexOf, i = {}, j = i.toString, k = i.hasOwnProperty, l = {}, m = "1.12.3", n = function (a, b) { return new n.fn.init(a, b) }, o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, p = /^-ms-/, q = /-([\da-z])/gi, r = function (a, b) { return b.toUpperCase() }; n.fn = n.prototype = { jquery: m, constructor: n, selector: "", length: 0, toArray: function () { return e.call(this) }, get: function (a) { return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this) }, pushStack: function (a) { var b = n.merge(this.constructor(), a); return b.prevObject = this, b.context = this.context, b }, each: function (a) { return n.each(this, a) }, map: function (a) { return this.pushStack(n.map(this, function (b, c) { return a.call(b, c, b) })) }, slice: function () { return this.pushStack(e.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, eq: function (a) { var b = this.length, c = +a + (0 > a ? b : 0); return this.pushStack(c >= 0 && b > c ? [this[c]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () { var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1; for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--) ; i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], c = e[d], g !== c && (j && c && (n.isPlainObject(c) || (b = n.isArray(c))) ? (b ? (b = !1, f = a && n.isArray(a) ? a : []) : f = a && n.isPlainObject(a) ? a : {}, g[d] = n.extend(j, f, c)) : void 0 !== c && (g[d] = c)); return g }, n.extend({ expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) { throw new Error(a) }, noop: function () { }, isFunction: function (a) { return "function" === n.type(a) }, isArray: Array.isArray || function (a) { return "array" === n.type(a) }, isWindow: function (a) { return null != a && a == a.window }, isNumeric: function (a) { var b = a && a.toString(); return !n.isArray(a) && b - parseFloat(b) + 1 >= 0 }, isEmptyObject: function (a) { var b; for (b in a) return !1; return !0 }, isPlainObject: function (a) { var b; if (!a || "object" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1; try { if (a.constructor && !k.call(a, "constructor") && !k.call(a.constructor.prototype, "isPrototypeOf")) return !1 } catch (c) { return !1 } if (!l.ownFirst) for (b in a) return k.call(a, b); for (b in a); return void 0 === b || k.call(a, b) }, type: function (a) { return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? i[j.call(a)] || "object" : typeof a }, globalEval: function (b) { b && n.trim(b) && (a.execScript || function (b) { a.eval.call(a, b) })(b) }, camelCase: function (a) { return a.replace(p, "ms-").replace(q, r) }, nodeName: function (a, b) { return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase() }, each: function (a, b) { var c, d = 0; if (s(a)) { for (c = a.length; c > d; d++) if (b.call(a[d], d, a[d]) === !1) break } else for (d in a) if (b.call(a[d], d, a[d]) === !1) break; return a }, trim: function (a) { return null == a ? "" : (a + "").replace(o, "") }, makeArray: function (a, b) { var c = b || []; return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : g.call(c, a)), c }, inArray: function (a, b, c) { var d; if (b) { if (h) return h.call(b, a, c); for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c } return -1 }, merge: function (a, b) { var c = +b.length, d = 0, e = a.length; while (c > d) a[e++] = b[d++]; if (c !== c) while (void 0 !== b[d]) a[e++] = b[d++]; return a.length = e, a }, grep: function (a, b, c) { for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]); return e }, map: function (a, b, c) { var d, e, g = 0, h = []; if (s(a)) for (d = a.length; d > g; g++) e = b(a[g], g, c), null != e && h.push(e); else for (g in a) e = b(a[g], g, c), null != e && h.push(e); return f.apply([], h) }, guid: 1, proxy: function (a, b) { var c, d, f; return "string" == typeof b && (f = a[b], b = a, a = f), n.isFunction(a) ? (c = e.call(arguments, 2), d = function () { return a.apply(b || this, c.concat(e.call(arguments))) }, d.guid = a.guid = a.guid || n.guid++, d) : void 0 }, now: function () { return +new Date }, support: l }), "function" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (a, b) { i["[object " + b + "]"] = b.toLowerCase() }); function s(a) { var b = !!a && "length" in a && a.length, c = n.type(a); return "function" === c || n.isWindow(a) ? !1 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a } var t = function (a) { var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date, v = a.document, w = 0, x = 0, y = ga(), z = ga(), A = ga(), B = function (a, b) { return a === b && (l = !0), 0 }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function (a, b) { for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c; return -1 }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + M + "))|)" + L + "*\\]", O = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + N + ")*)|.*)\\)|)", P = new RegExp(L + "+", "g"), Q = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), R = new RegExp("^" + L + "*," + L + "*"), S = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), T = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), U = new RegExp(O), V = new RegExp("^" + M + "$"), W = { ID: new RegExp("^#(" + M + ")"), CLASS: new RegExp("^\\.(" + M + ")"), TAG: new RegExp("^(" + M + "|[*])"), ATTR: new RegExp("^" + N), PSEUDO: new RegExp("^" + O), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"), bool: new RegExp("^(?:" + K + ")$", "i"), needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i") }, X = /^(?:input|select|textarea|button)$/i, Y = /^h\d$/i, Z = /^[^{]+\{\s*\[native \w/, $ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, _ = /[+~]/, aa = /'|\\/g, ba = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), ca = function (a, b, c) { var d = "0x" + b - 65536; return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320) }, da = function () { m() }; try { H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType } catch (ea) { H = { apply: E.length ? function (a, b) { G.apply(a, I.call(b)) } : function (a, b) { var c = a.length, d = 0; while (a[c++] = b[d++]); a.length = c - 1 } } } function fa(a, b, d, e) { var f, h, j, k, l, o, r, s, w = b && b.ownerDocument, x = b ? b.nodeType : 9; if (d = d || [], "string" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d; if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) { if (11 !== x && (o = $.exec(a))) if (f = o[1]) { if (9 === x) { if (!(j = b.getElementById(f))) return d; if (j.id === f) return d.push(j), d } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d } else { if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d; if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d } if (c.qsa && !A[a + " "] && (!q || !q.test(a))) { if (1 !== x) w = b, s = a; else if ("object" !== b.nodeName.toLowerCase()) { (k = b.getAttribute("id")) ? k = k.replace(aa, "\\$&") : b.setAttribute("id", k = u), r = g(a), h = r.length, l = V.test(k) ? "#" + k : "[id='" + k + "']"; while (h--) r[h] = l + " " + qa(r[h]); s = r.join(","), w = _.test(a) && oa(b.parentNode) || b } if (s) try { return H.apply(d, w.querySelectorAll(s)), d } catch (y) { } finally { k === u && b.removeAttribute("id") } } } return i(a.replace(Q, "$1"), b, d, e) } function ga() { var a = []; function b(c, e) { return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e } return b } function ha(a) { return a[u] = !0, a } function ia(a) { var b = n.createElement("div"); try { return !!a(b) } catch (c) { return !1 } finally { b.parentNode && b.parentNode.removeChild(b), b = null } } function ja(a, b) { var c = a.split("|"), e = c.length; while (e--) d.attrHandle[c[e]] = b } function ka(a, b) { var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C); if (d) return d; if (c) while (c = c.nextSibling) if (c === b) return -1; return a ? 1 : -1 } function la(a) { return function (b) { var c = b.nodeName.toLowerCase(); return "input" === c && b.type === a } } function ma(a) { return function (b) { var c = b.nodeName.toLowerCase(); return ("input" === c || "button" === c) && b.type === a } } function na(a) { return ha(function (b) { return b = +b, ha(function (c, d) { var e, f = a([], c.length, b), g = f.length; while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e])) }) }) } function oa(a) { return a && "undefined" != typeof a.getElementsByTagName && a } c = fa.support = {}, f = fa.isXML = function (a) { var b = a && (a.ownerDocument || a).documentElement; return b ? "HTML" !== b.nodeName : !1 }, m = fa.setDocument = function (a) { var b, e, g = a ? a.ownerDocument || a : v; return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener("unload", da, !1) : e.attachEvent && e.attachEvent("onunload", da)), c.attributes = ia(function (a) { return a.className = "i", !a.getAttribute("className") }), c.getElementsByTagName = ia(function (a) { return a.appendChild(n.createComment("")), !a.getElementsByTagName("*").length }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) { return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length }), c.getById ? (d.find.ID = function (a, b) { if ("undefined" != typeof b.getElementById && p) { var c = b.getElementById(a); return c ? [c] : [] } }, d.filter.ID = function (a) { var b = a.replace(ba, ca); return function (a) { return a.getAttribute("id") === b } }) : (delete d.find.ID, d.filter.ID = function (a) { var b = a.replace(ba, ca); return function (a) { var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id"); return c && c.value === b } }), d.find.TAG = c.getElementsByTagName ? function (a, b) { return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0 } : function (a, b) { var c, d = [], e = 0, f = b.getElementsByTagName(a); if ("*" === a) { while (c = f[e++]) 1 === c.nodeType && d.push(c); return d } return f }, d.find.CLASS = c.getElementsByClassName && function (a, b) { return "undefined" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0 }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) { o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]") }), ia(function (a) { var b = n.createElement("input"); b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:") })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) { c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", O) }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) { var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode; return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d))) } : function (a, b) { if (b) while (b = b.parentNode) if (b === a) return !0; return !1 }, B = b ? function (a, b) { if (a === b) return l = !0, 0; var d = !a.compareDocumentPosition - !b.compareDocumentPosition; return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1) } : function (a, b) { if (a === b) return l = !0, 0; var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0; if (e === f) return ka(a, b); c = a; while (c = c.parentNode) g.unshift(c); c = b; while (c = c.parentNode) h.unshift(c); while (g[d] === h[d]) d++; return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0 }, n) : n }, fa.matches = function (a, b) { return fa(a, null, null, b) }, fa.matchesSelector = function (a, b) { if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, "='$1']"), c.matchesSelector && p && !A[b + " "] && (!r || !r.test(b)) && (!q || !q.test(b))) try { var d = s.call(a, b); if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d } catch (e) { } return fa(b, n, null, [a]).length > 0 }, fa.contains = function (a, b) { return (a.ownerDocument || a) !== n && m(a), t(a, b) }, fa.attr = function (a, b) { (a.ownerDocument || a) !== n && m(a); var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0; return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null }, fa.error = function (a) { throw new Error("Syntax error, unrecognized expression: " + a) }, fa.uniqueSort = function (a) { var b, d = [], e = 0, f = 0; if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) { while (b = a[f++]) b === a[f] && (e = d.push(f)); while (e--) a.splice(d[e], 1) } return k = null, a }, e = fa.getText = function (a) { var b, c = "", d = 0, f = a.nodeType; if (f) { if (1 === f || 9 === f || 11 === f) { if ("string" == typeof a.textContent) return a.textContent; for (a = a.firstChild; a; a = a.nextSibling) c += e(a) } else if (3 === f || 4 === f) return a.nodeValue } else while (b = a[d++]) c += e(b); return c }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (a) { return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || "").replace(ba, ca), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4) }, CHILD: function (a) { return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fa.error(a[0]), a }, PSEUDO: function (a) { var b, c = !a[6] && a[2]; return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3)) } }, filter: { TAG: function (a) { var b = a.replace(ba, ca).toLowerCase(); return "*" === a ? function () { return !0 } : function (a) { return a.nodeName && a.nodeName.toLowerCase() === b } }, CLASS: function (a) { var b = y[a + " "]; return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function (a) { return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "") }) }, ATTR: function (a, b, c) { return function (d) { var e = fa.attr(d, a); return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(P, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0 } }, CHILD: function (a, b, c, d, e) { var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b; return 1 === d && 0 === e ? function (a) { return !!a.parentNode } : function (b, c, i) { var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h, t = !1; if (q) { if (f) { while (p) { m = b; while (m = m[p]) if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1; o = p = "only" === a && !o && "nextSibling" } return !0 } if (o = [g ? q.firstChild : q.lastChild], g && s) { m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n]; while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if (1 === m.nodeType && ++t && m === b) { k[a] = [w, n, t]; break } } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break; return t -= e, t === d || t % d === 0 && t / d >= 0 } } }, PSEUDO: function (a, b) { var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error("unsupported pseudo: " + a); return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) { var d, f = e(a, b), g = f.length; while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g]) }) : function (a) { return e(a, 0, c) }) : e } }, pseudos: { not: ha(function (a) { var b = [], c = [], d = h(a.replace(Q, "$1")); return d[u] ? ha(function (a, b, c, e) { var f, g = d(a, null, e, []), h = a.length; while (h--) (f = g[h]) && (a[h] = !(b[h] = f)) }) : function (a, e, f) { return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop() } }), has: ha(function (a) { return function (b) { return fa(a, b).length > 0 } }), contains: ha(function (a) { return a = a.replace(ba, ca), function (b) { return (b.textContent || b.innerText || e(b)).indexOf(a) > -1 } }), lang: ha(function (a) { return V.test(a || "") || fa.error("unsupported lang: " + a), a = a.replace(ba, ca).toLowerCase(), function (b) { var c; do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType); return !1 } }), target: function (b) { var c = a.location && a.location.hash; return c && c.slice(1) === b.id }, root: function (a) { return a === o }, focus: function (a) { return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex) }, enabled: function (a) { return a.disabled === !1 }, disabled: function (a) { return a.disabled === !0 }, checked: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && !!a.checked || "option" === b && !!a.selected }, selected: function (a) { return a.parentNode && a.parentNode.selectedIndex, a.selected === !0 }, empty: function (a) { for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1; return !0 }, parent: function (a) { return !d.pseudos.empty(a) }, header: function (a) { return Y.test(a.nodeName) }, input: function (a) { return X.test(a.nodeName) }, button: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && "button" === a.type || "button" === b }, text: function (a) { var b; return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase()) }, first: na(function () { return [0] }), last: na(function (a, b) { return [b - 1] }), eq: na(function (a, b, c) { return [0 > c ? c + b : c] }), even: na(function (a, b) { for (var c = 0; b > c; c += 2) a.push(c); return a }), odd: na(function (a, b) { for (var c = 1; b > c; c += 2) a.push(c); return a }), lt: na(function (a, b, c) { for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d); return a }), gt: na(function (a, b, c) { for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d); return a }) } }, d.pseudos.nth = d.pseudos.eq; for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) d.pseudos[b] = la(b); for (b in { submit: !0, reset: !0 }) d.pseudos[b] = ma(b); function pa() { } pa.prototype = d.filters = d.pseudos, d.setFilters = new pa, g = fa.tokenize = function (a, b) { var c, e, f, g, h, i, j, k = z[a + " "]; if (k) return b ? 0 : k.slice(0); h = a, i = [], j = d.preFilter; while (h) { c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, " ") }), h = h.slice(c.length)); for (g in d.filter) !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length)); if (!c) break } return b ? h.length : h ? fa.error(a) : z(a, i).slice(0) }; function qa(a) { for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value; return d } function ra(a, b, c) { var d = b.dir, e = c && "parentNode" === d, f = x++; return b.first ? function (b, c, f) { while (b = b[d]) if (1 === b.nodeType || e) return a(b, c, f) } : function (b, c, g) { var h, i, j, k = [w, f]; if (g) { while (b = b[d]) if ((1 === b.nodeType || e) && a(b, c, g)) return !0 } else while (b = b[d]) if (1 === b.nodeType || e) { if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2]; if (i[d] = k, k[2] = a(b, c, g)) return !0 } } } function sa(a) { return a.length > 1 ? function (b, c, d) { var e = a.length; while (e--) if (!a[e](b, c, d)) return !1; return !0 } : a[0] } function ta(a, b, c) { for (var d = 0, e = b.length; e > d; d++) fa(a, b[d], c); return c } function ua(a, b, c, d, e) { for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h))); return g } function va(a, b, c, d, e, f) { return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) { var j, k, l, m = [], n = [], o = g.length, p = f || ta(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : ua(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q; if (c && c(q, r, h, i), d) { j = ua(r, n), d(j, [], h, i), k = j.length; while (k--) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l)) } if (f) { if (e || a) { if (e) { j = [], k = r.length; while (k--) (l = r[k]) && j.push(q[k] = l); e(null, r = [], j, i) } k = r.length; while (k--) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l)) } } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r) }) } function wa(a) { for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = ra(function (a) { return a === b }, h, !0), l = ra(function (a) { return J(b, a) > -1 }, h, !0), m = [function (a, c, d) { var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d)); return b = null, e }]; f > i; i++) if (c = d.relative[a[i].type]) m = [ra(sa(m), c)]; else { if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) { for (e = ++i; f > e; e++) if (d.relative[a[e].type]) break; return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: " " === a[i - 2].type ? "*" : "" })).replace(Q, "$1"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a)) } m.push(c) } return sa(m) } function xa(a, b) { var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) { var l, o, q, r = 0, s = "0", t = f && [], u = [], v = j, x = f || e && d.find.TAG("*", k), y = w += null == v ? 1 : Math.random() || .1, z = x.length; for (k && (j = g === n || g || k) ; s !== z && null != (l = x[s]) ; s++) { if (e && l) { o = 0, g || l.ownerDocument === n || (m(l), h = !p); while (q = a[o++]) if (q(l, g || n, h)) { i.push(l); break } k && (w = y) } c && ((l = !q && l) && r--, f && t.push(l)) } if (r += s, c && s !== r) { o = 0; while (q = b[o++]) q(t, u, g, h); if (f) { if (r > 0) while (s--) t[s] || u[s] || (u[s] = F.call(i)); u = ua(u) } H.apply(i, u), k && !f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i) } return k && (w = y, j = v), t }; return c ? ha(f) : f } return h = fa.compile = function (a, b) { var c, d = [], e = [], f = A[a + " "]; if (!f) { b || (b = g(a)), c = b.length; while (c--) f = wa(b[c]), f[u] ? d.push(f) : e.push(f); f = A(a, xa(e, d)), f.selector = a } return f }, i = fa.select = function (a, b, e, f) { var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a); if (e = e || [], 1 === o.length) { if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) { if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e; n && (b = b.parentNode), a = a.slice(j.shift().value.length) } i = W.needsContext.test(a) ? 0 : j.length; while (i--) { if (k = j[i], d.relative[l = k.type]) break; if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) { if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e; break } } } return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) { return 1 & a.compareDocumentPosition(n.createElement("div")) }), ia(function (a) { return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href") }) || ja("type|href|height|width", function (a, b, c) { return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2) }), c.attributes && ia(function (a) { return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value") }) || ja("value", function (a, b, c) { return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue }), ia(function (a) { return null == a.getAttribute("disabled") }) || ja(K, function (a, b, c) { var d; return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null }), fa }(a); n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = function (a, b, c) { var d = [], e = void 0 !== c; while ((a = a[b]) && 9 !== a.nodeType) if (1 === a.nodeType) { if (e && n(a).is(c)) break; d.push(a) } return d }, v = function (a, b) { for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a); return c }, w = n.expr.match.needsContext, x = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, y = /^.[^:#\[\.,]*$/; function z(a, b, c) { if (n.isFunction(b)) return n.grep(a, function (a, d) { return !!b.call(a, d, a) !== c }); if (b.nodeType) return n.grep(a, function (a) { return a === b !== c }); if ("string" == typeof b) { if (y.test(b)) return n.filter(b, a, c); b = n.filter(b, a) } return n.grep(a, function (a) { return n.inArray(a, b) > -1 !== c }) } n.filter = function (a, b, c) { var d = b[0]; return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) { return 1 === a.nodeType })) }, n.fn.extend({ find: function (a) { var b, c = [], d = this, e = d.length; if ("string" != typeof a) return this.pushStack(n(a).filter(function () { for (b = 0; e > b; b++) if (n.contains(d[b], this)) return !0 })); for (b = 0; e > b; b++) n.find(a, d[b], c); return c = this.pushStack(e > 1 ? n.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c }, filter: function (a) { return this.pushStack(z(this, a || [], !1)) }, not: function (a) { return this.pushStack(z(this, a || [], !0)) }, is: function (a) { return !!z(this, "string" == typeof a && w.test(a) ? n(a) : a || [], !1).length } }); var A, B = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, C = n.fn.init = function (a, b, c) { var e, f; if (!a) return this; if (c = c || A, "string" == typeof a) { if (e = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a); if (e[1]) { if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]); return this } if (f = d.getElementById(e[2]), f && f.parentNode) { if (f.id !== e[2]) return A.find(a); this.length = 1, this[0] = f } return this.context = d, this.selector = a, this } return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this)) }; C.prototype = n.fn, A = n(d); var D = /^(?:parents|prev(?:Until|All))/, E = { children: !0, contents: !0, next: !0, prev: !0 }; n.fn.extend({ has: function (a) { var b, c = n(a, this), d = c.length; return this.filter(function () { for (b = 0; d > b; b++) if (n.contains(this, c[b])) return !0 }) }, closest: function (a, b) { for (var c, d = 0, e = this.length, f = [], g = w.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) { f.push(c); break } return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f) }, index: function (a) { return a ? "string" == typeof a ? n.inArray(this[0], n(a)) : n.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (a, b) { return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b)))) }, addBack: function (a) { return this.add(null == a ? this.prevObject : this.prevObject.filter(a)) } }); function F(a, b) { do a = a[b]; while (a && 1 !== a.nodeType); return a } n.each({ parent: function (a) { var b = a.parentNode; return b && 11 !== b.nodeType ? b : null }, parents: function (a) { return u(a, "parentNode") }, parentsUntil: function (a, b, c) { return u(a, "parentNode", c) }, next: function (a) { return F(a, "nextSibling") }, prev: function (a) { return F(a, "previousSibling") }, nextAll: function (a) { return u(a, "nextSibling") }, prevAll: function (a) { return u(a, "previousSibling") }, nextUntil: function (a, b, c) { return u(a, "nextSibling", c) }, prevUntil: function (a, b, c) { return u(a, "previousSibling", c) }, siblings: function (a) { return v((a.parentNode || {}).firstChild, a) }, children: function (a) { return v(a.firstChild) }, contents: function (a) { return n.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : n.merge([], a.childNodes) } }, function (a, b) { n.fn[a] = function (c, d) { var e = n.map(this, b, c); return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || (e = n.uniqueSort(e)), D.test(a) && (e = e.reverse())), this.pushStack(e) } }); var G = /\S+/g; function H(a) { var b = {}; return n.each(a.match(G) || [], function (a, c) { b[c] = !0 }), b } n.Callbacks = function (a) { a = "string" == typeof a ? H(a) : n.extend({}, a); var b, c, d, e, f = [], g = [], h = -1, i = function () { for (e = a.once, d = b = !0; g.length; h = -1) { c = g.shift(); while (++h < f.length) f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1) } a.memory || (c = !1), b = !1, e && (f = c ? [] : "") }, j = { add: function () { return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) { n.each(b, function (b, c) { n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && "string" !== n.type(c) && d(c) }) }(arguments), c && !b && i()), this }, remove: function () { return n.each(arguments, function (a, b) { var c; while ((c = n.inArray(b, f, c)) > -1) f.splice(c, 1), h >= c && h-- }), this }, has: function (a) { return a ? n.inArray(a, f) > -1 : f.length > 0 }, empty: function () { return f && (f = []), this }, disable: function () { return e = g = [], f = c = "", this }, disabled: function () { return !f }, lock: function () { return e = !0, c || j.disable(), this }, locked: function () { return !!e }, fireWith: function (a, c) { return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this }, fire: function () { return j.fireWith(this, arguments), this }, fired: function () { return !!d } }; return j }, n.extend({ Deferred: function (a) { var b = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]], c = "pending", d = { state: function () { return c }, always: function () { return e.done(arguments).fail(arguments), this }, then: function () { var a = arguments; return n.Deferred(function (c) { n.each(b, function (b, f) { var g = n.isFunction(a[b]) && a[b]; e[f[1]](function () { var a = g && g.apply(this, arguments); a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments) }) }), a = null }).promise() }, promise: function (a) { return null != a ? n.extend(a, d) : d } }, e = {}; return d.pipe = d.then, n.each(b, function (a, f) { var g = f[2], h = f[3]; d[f[1]] = g.add, h && g.add(function () { c = h }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () { return e[f[0] + "With"](this === e ? d : this, arguments), this }, e[f[0] + "With"] = g.fireWith }), d.promise(e), a && a.call(e, e), e }, when: function (a) { var b = 0, c = e.call(arguments), d = c.length, f = 1 !== d || a && n.isFunction(a.promise) ? d : 0, g = 1 === f ? a : n.Deferred(), h = function (a, b, c) { return function (d) { b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c) } }, i, j, k; if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d) ; d > b; b++) c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f; return f || g.resolveWith(k, c), g.promise() } }); var I; n.fn.ready = function (a) { return n.ready.promise().done(a), this }, n.extend({ isReady: !1, readyWait: 1, holdReady: function (a) { a ? n.readyWait++ : n.ready(!0) }, ready: function (a) { (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler("ready"), n(d).off("ready")))) } }); function J() { d.addEventListener ? (d.removeEventListener("DOMContentLoaded", K), a.removeEventListener("load", K)) : (d.detachEvent("onreadystatechange", K), a.detachEvent("onload", K)) } function K() { (d.addEventListener || "load" === a.event.type || "complete" === d.readyState) && (J(), n.ready()) } n.ready.promise = function (b) { if (!I) if (I = n.Deferred(), "complete" === d.readyState || "loading" !== d.readyState && !d.documentElement.doScroll) a.setTimeout(n.ready); else if (d.addEventListener) d.addEventListener("DOMContentLoaded", K), a.addEventListener("load", K); else { d.attachEvent("onreadystatechange", K), a.attachEvent("onload", K); var c = !1; try { c = null == a.frameElement && d.documentElement } catch (e) { } c && c.doScroll && !function f() { if (!n.isReady) { try { c.doScroll("left") } catch (b) { return a.setTimeout(f, 50) } J(), n.ready() } }() } return I.promise(b) }, n.ready.promise(); var L; for (L in n(l)) break; l.ownFirst = "0" === L, l.inlineBlockNeedsLayout = !1, n(function () { var a, b, c, e; c = d.getElementsByTagName("body")[0], c && c.style && (b = d.createElement("div"), e = d.createElement("div"), e.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(e).appendChild(b), "undefined" != typeof b.style.zoom && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", l.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(e)) }), function () { var a = d.createElement("div"); l.deleteExpando = !0; try { delete a.test } catch (b) { l.deleteExpando = !1 } a = null }(); var M = function (a) { var b = n.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1; return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b }, N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, O = /([A-Z])/g; function P(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(O, "-$1").toLowerCase(); if (c = a.getAttribute(d), "string" == typeof c) { try { c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c } catch (e) { } n.data(a, b, c) } else c = void 0;
        } return c
    } function Q(a) { var b; for (b in a) if (("data" !== b || !n.isEmptyObject(a[b])) && "toJSON" !== b) return !1; return !0 } function R(a, b, d, e) { if (M(a)) { var f, g, h = n.expando, i = a.nodeType, j = i ? n.cache : a, k = i ? a[h] : a[h] && h; if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || n.guid++ : h), j[k] || (j[k] = i ? {} : { toJSON: n.noop }), "object" != typeof b && "function" != typeof b || (e ? j[k] = n.extend(j[k], b) : j[k].data = n.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[n.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f && (f = g[n.camelCase(b)])) : f = g, f } } function S(a, b, c) { if (M(a)) { var d, e, f = a.nodeType, g = f ? n.cache : a, h = f ? a[n.expando] : n.expando; if (g[h]) { if (b && (d = c ? g[h] : g[h].data)) { n.isArray(b) ? b = b.concat(n.map(b, n.camelCase)) : b in d ? b = [b] : (b = n.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length; while (e--) delete d[b[e]]; if (c ? !Q(d) : !n.isEmptyObject(d)) return } (c || (delete g[h].data, Q(g[h]))) && (f ? n.cleanData([a], !0) : l.deleteExpando || g != g.window ? delete g[h] : g[h] = void 0) } } } n.extend({ cache: {}, noData: { "applet ": !0, "embed ": !0, "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" }, hasData: function (a) { return a = a.nodeType ? n.cache[a[n.expando]] : a[n.expando], !!a && !Q(a) }, data: function (a, b, c) { return R(a, b, c) }, removeData: function (a, b) { return S(a, b) }, _data: function (a, b, c) { return R(a, b, c, !0) }, _removeData: function (a, b) { return S(a, b, !0) } }), n.fn.extend({ data: function (a, b) { var c, d, e, f = this[0], g = f && f.attributes; if (void 0 === a) { if (this.length && (e = n.data(f), 1 === f.nodeType && !n._data(f, "parsedAttrs"))) { c = g.length; while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), P(f, d, e[d]))); n._data(f, "parsedAttrs", !0) } return e } return "object" == typeof a ? this.each(function () { n.data(this, a) }) : arguments.length > 1 ? this.each(function () { n.data(this, a, b) }) : f ? P(f, a, n.data(f, a)) : void 0 }, removeData: function (a) { return this.each(function () { n.removeData(this, a) }) } }), n.extend({ queue: function (a, b, c) { var d; return a ? (b = (b || "fx") + "queue", d = n._data(a, b), c && (!d || n.isArray(c) ? d = n._data(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0 }, dequeue: function (a, b) { b = b || "fx"; var c = n.queue(a, b), d = c.length, e = c.shift(), f = n._queueHooks(a, b), g = function () { n.dequeue(a, b) }; "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire() }, _queueHooks: function (a, b) { var c = b + "queueHooks"; return n._data(a, c) || n._data(a, c, { empty: n.Callbacks("once memory").add(function () { n._removeData(a, b + "queue"), n._removeData(a, c) }) }) } }), n.fn.extend({ queue: function (a, b) { var c = 2; return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () { var c = n.queue(this, a, b); n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a) }) }, dequeue: function (a) { return this.each(function () { n.dequeue(this, a) }) }, clearQueue: function (a) { return this.queue(a || "fx", []) }, promise: function (a, b) { var c, d = 1, e = n.Deferred(), f = this, g = this.length, h = function () { --d || e.resolveWith(f, [f]) }; "string" != typeof a && (b = a, a = void 0), a = a || "fx"; while (g--) c = n._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h)); return h(), e.promise(b) } }), function () { var a; l.shrinkWrapBlocks = function () { if (null != a) return a; a = !1; var b, c, e; return c = d.getElementsByTagName("body")[0], c && c.style ? (b = d.createElement("div"), e = d.createElement("div"), e.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(e).appendChild(b), "undefined" != typeof b.style.zoom && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", b.appendChild(d.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), c.removeChild(e), a) : void 0 } }(); var T = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, U = new RegExp("^(?:([+-])=|)(" + T + ")([a-z%]*)$", "i"), V = ["Top", "Right", "Bottom", "Left"], W = function (a, b) { return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a) }; function X(a, b, c, d) { var e, f = 1, g = 20, h = d ? function () { return d.cur() } : function () { return n.css(a, b, "") }, i = h(), j = c && c[3] || (n.cssNumber[b] ? "" : "px"), k = (n.cssNumber[b] || "px" !== j && +i) && U.exec(n.css(a, b)); if (k && k[3] !== j) { j = j || k[3], c = c || [], k = +i || 1; do f = f || ".5", k /= f, n.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g) } return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e } var Y = function (a, b, c, d, e, f, g) { var h = 0, i = a.length, j = null == c; if ("object" === n.type(c)) { e = !0; for (h in c) Y(a, b, h, c[h], !0, f, g) } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) { return j.call(n(a), c) })), b)) for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c))); return e ? a : j ? b.call(a) : i ? b(a[0], c) : f }, Z = /^(?:checkbox|radio)$/i, $ = /<([\w:-]+)/, _ = /^$|\/(?:java|ecma)script/i, aa = /^\s+/, ba = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video"; function ca(a) { var b = ba.split("|"), c = a.createDocumentFragment(); if (c.createElement) while (b.length) c.createElement(b.pop()); return c } !function () { var a = d.createElement("div"), b = d.createDocumentFragment(), c = d.createElement("input"); a.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", l.leadingWhitespace = 3 === a.firstChild.nodeType, l.tbody = !a.getElementsByTagName("tbody").length, l.htmlSerialize = !!a.getElementsByTagName("link").length, l.html5Clone = "<:nav></:nav>" !== d.createElement("nav").cloneNode(!0).outerHTML, c.type = "checkbox", c.checked = !0, b.appendChild(c), l.appendChecked = c.checked, a.innerHTML = "<textarea>x</textarea>", l.noCloneChecked = !!a.cloneNode(!0).lastChild.defaultValue, b.appendChild(a), c = d.createElement("input"), c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), a.appendChild(c), l.checkClone = a.cloneNode(!0).cloneNode(!0).lastChild.checked, l.noCloneEvent = !!a.addEventListener, a[n.expando] = 1, l.attributes = !a.getAttribute(n.expando) }(); var da = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: l.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] }; da.optgroup = da.option, da.tbody = da.tfoot = da.colgroup = da.caption = da.thead, da.th = da.td; function ea(a, b) { var c, d, e = 0, f = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : void 0; if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]) ; e++) !b || n.nodeName(d, b) ? f.push(d) : n.merge(f, ea(d, b)); return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], f) : f } function fa(a, b) { for (var c, d = 0; null != (c = a[d]) ; d++) n._data(c, "globalEval", !b || n._data(b[d], "globalEval")) } var ga = /<|&#?\w+;/, ha = /<tbody/i; function ia(a) { Z.test(a.type) && (a.defaultChecked = a.checked) } function ja(a, b, c, d, e) { for (var f, g, h, i, j, k, m, o = a.length, p = ca(b), q = [], r = 0; o > r; r++) if (g = a[r], g || 0 === g) if ("object" === n.type(g)) n.merge(q, g.nodeType ? [g] : g); else if (ga.test(g)) { i = i || p.appendChild(b.createElement("div")), j = ($.exec(g) || ["", ""])[1].toLowerCase(), m = da[j] || da._default, i.innerHTML = m[1] + n.htmlPrefilter(g) + m[2], f = m[0]; while (f--) i = i.lastChild; if (!l.leadingWhitespace && aa.test(g) && q.push(b.createTextNode(aa.exec(g)[0])), !l.tbody) { g = "table" !== j || ha.test(g) ? "<table>" !== m[1] || ha.test(g) ? 0 : i : i.firstChild, f = g && g.childNodes.length; while (f--) n.nodeName(k = g.childNodes[f], "tbody") && !k.childNodes.length && g.removeChild(k) } n.merge(q, i.childNodes), i.textContent = ""; while (i.firstChild) i.removeChild(i.firstChild); i = p.lastChild } else q.push(b.createTextNode(g)); i && p.removeChild(i), l.appendChecked || n.grep(ea(q, "input"), ia), r = 0; while (g = q[r++]) if (d && n.inArray(g, d) > -1) e && e.push(g); else if (h = n.contains(g.ownerDocument, g), i = ea(p.appendChild(g), "script"), h && fa(i), c) { f = 0; while (g = i[f++]) _.test(g.type || "") && c.push(g) } return i = null, p } !function () { var b, c, e = d.createElement("div"); for (b in { submit: !0, change: !0, focusin: !0 }) c = "on" + b, (l[b] = c in a) || (e.setAttribute(c, "t"), l[b] = e.attributes[c].expando === !1); e = null }(); var ka = /^(?:input|select|textarea)$/i, la = /^key/, ma = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, na = /^(?:focusinfocus|focusoutblur)$/, oa = /^([^.]*)(?:\.(.+)|)/; function pa() { return !0 } function qa() { return !1 } function ra() { try { return d.activeElement } catch (a) { } } function sa(a, b, c, d, e, f) { var g, h; if ("object" == typeof b) { "string" != typeof c && (d = d || c, c = void 0); for (h in b) sa(a, h, c, d, b[h], f); return a } if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = qa; else if (!e) return a; return 1 === f && (g = e, e = function (a) { return n().off(a), g.apply(this, arguments) }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () { n.event.add(this, b, e, d, c) }) } n.event = { global: {}, add: function (a, b, c, d, e) { var f, g, h, i, j, k, l, m, o, p, q, r = n._data(a); if (r) { c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) { return "undefined" == typeof n || a && n.event.triggered === a.type ? void 0 : n.event.dispatch.apply(k.elem, arguments) }, k.elem = a), b = (b || "").match(G) || [""], h = b.length; while (h--) f = oa.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = n.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = n.event.special[o] || {}, l = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(".") }, i), (m = g[o]) || (m = g[o] = [], m.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, l) : m.push(l), n.event.global[o] = !0); a = null } }, remove: function (a, b, c, d, e) { var f, g, h, i, j, k, l, m, o, p, q, r = n.hasData(a) && n._data(a); if (r && (k = r.events)) { b = (b || "").match(G) || [""], j = b.length; while (j--) if (h = oa.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) { l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = k[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = m.length; while (f--) g = m[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (m.splice(f, 1), g.selector && m.delegateCount--, l.remove && l.remove.call(a, g)); i && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete k[o]) } else for (o in k) n.event.remove(a, o + b[j], c, d, !0); n.isEmptyObject(k) && (delete r.handle, n._removeData(a, "events")) } }, trigger: function (b, c, e, f) { var g, h, i, j, l, m, o, p = [e || d], q = k.call(b, "type") ? b.type : b, r = k.call(b, "namespace") ? b.namespace.split(".") : []; if (i = m = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !na.test(q + n.event.triggered) && (q.indexOf(".") > -1 && (r = q.split("."), q = r.shift(), r.sort()), h = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), l = n.event.special[q] || {}, f || !l.trigger || l.trigger.apply(e, c) !== !1)) { if (!f && !l.noBubble && !n.isWindow(e)) { for (j = l.delegateType || q, na.test(j + q) || (i = i.parentNode) ; i; i = i.parentNode) p.push(i), m = i; m === (e.ownerDocument || d) && p.push(m.defaultView || m.parentWindow || a) } o = 0; while ((i = p[o++]) && !b.isPropagationStopped()) b.type = o > 1 ? j : l.bindType || q, g = (n._data(i, "events") || {})[b.type] && n._data(i, "handle"), g && g.apply(i, c), g = h && i[h], g && g.apply && M(i) && (b.result = g.apply(i, c), b.result === !1 && b.preventDefault()); if (b.type = q, !f && !b.isDefaultPrevented() && (!l._default || l._default.apply(p.pop(), c) === !1) && M(e) && h && e[q] && !n.isWindow(e)) { m = e[h], m && (e[h] = null), n.event.triggered = q; try { e[q]() } catch (s) { } n.event.triggered = void 0, m && (e[h] = m) } return b.result } }, dispatch: function (a) { a = n.event.fix(a); var b, c, d, f, g, h = [], i = e.call(arguments), j = (n._data(this, "events") || {})[a.type] || [], k = n.event.special[a.type] || {}; if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) { h = n.event.handlers.call(this, a, j), b = 0; while ((f = h[b++]) && !a.isPropagationStopped()) { a.currentTarget = f.elem, c = 0; while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation())) } return k.postDispatch && k.postDispatch.call(this, a), a.result } }, handlers: function (a, b) { var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1)) for (; i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) { for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f); d.length && g.push({ elem: i, handlers: d }) } return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g }, fix: function (a) { if (a[n.expando]) return a; var b, c, e, f = a.type, g = a, h = this.fixHooks[f]; h || (this.fixHooks[f] = h = ma.test(f) ? this.mouseHooks : la.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length; while (b--) c = e[b], a[c] = g[c]; return a.target || (a.target = g.srcElement || d), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, h.filter ? h.filter(a, g) : a }, props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function (a, b) { return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (a, b) { var c, e, f, g = b.button, h = b.fromElement; return null == a.pageX && null != b.clientX && (e = a.target.ownerDocument || d, f = e.documentElement, c = e.body, a.pageX = b.clientX + (f && f.scrollLeft || c && c.scrollLeft || 0) - (f && f.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (f && f.scrollTop || c && c.scrollTop || 0) - (f && f.clientTop || c && c.clientTop || 0)), !a.relatedTarget && h && (a.relatedTarget = h === a.target ? b.toElement : h), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a } }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== ra() && this.focus) try { return this.focus(), !1 } catch (a) { } }, delegateType: "focusin" }, blur: { trigger: function () { return this === ra() && this.blur ? (this.blur(), !1) : void 0 }, delegateType: "focusout" }, click: { trigger: function () { return n.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0 }, _default: function (a) { return n.nodeName(a.target, "a") } }, beforeunload: { postDispatch: function (a) { void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result) } } }, simulate: function (a, b, c) { var d = n.extend(new n.Event, c, { type: a, isSimulated: !0 }); n.event.trigger(d, null, b), d.isDefaultPrevented() && c.preventDefault() } }, n.removeEvent = d.removeEventListener ? function (a, b, c) { a.removeEventListener && a.removeEventListener(b, c) } : function (a, b, c) { var d = "on" + b; a.detachEvent && ("undefined" == typeof a[d] && (a[d] = null), a.detachEvent(d, c)) }, n.Event = function (a, b) { return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? pa : qa) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b) }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: qa, isPropagationStopped: qa, isImmediatePropagationStopped: qa, preventDefault: function () { var a = this.originalEvent; this.isDefaultPrevented = pa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1) }, stopPropagation: function () { var a = this.originalEvent; this.isPropagationStopped = pa, a && !this.isSimulated && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0) }, stopImmediatePropagation: function () { var a = this.originalEvent; this.isImmediatePropagationStopped = pa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation() } }, n.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (a, b) { n.event.special[a] = { delegateType: b, bindType: b, handle: function (a) { var c, d = this, e = a.relatedTarget, f = a.handleObj; return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c } } }), l.submit || (n.event.special.submit = { setup: function () { return n.nodeName(this, "form") ? !1 : void n.event.add(this, "click._submit keypress._submit", function (a) { var b = a.target, c = n.nodeName(b, "input") || n.nodeName(b, "button") ? n.prop(b, "form") : void 0; c && !n._data(c, "submit") && (n.event.add(c, "submit._submit", function (a) { a._submitBubble = !0 }), n._data(c, "submit", !0)) }) }, postDispatch: function (a) { a._submitBubble && (delete a._submitBubble, this.parentNode && !a.isTrigger && n.event.simulate("submit", this.parentNode, a)) }, teardown: function () { return n.nodeName(this, "form") ? !1 : void n.event.remove(this, "._submit") } }), l.change || (n.event.special.change = { setup: function () { return ka.test(this.nodeName) ? ("checkbox" !== this.type && "radio" !== this.type || (n.event.add(this, "propertychange._change", function (a) { "checked" === a.originalEvent.propertyName && (this._justChanged = !0) }), n.event.add(this, "click._change", function (a) { this._justChanged && !a.isTrigger && (this._justChanged = !1), n.event.simulate("change", this, a) })), !1) : void n.event.add(this, "beforeactivate._change", function (a) { var b = a.target; ka.test(b.nodeName) && !n._data(b, "change") && (n.event.add(b, "change._change", function (a) { !this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate("change", this.parentNode, a) }), n._data(b, "change", !0)) }) }, handle: function (a) { var b = a.target; return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0 }, teardown: function () { return n.event.remove(this, "._change"), !ka.test(this.nodeName) } }), l.focusin || n.each({ focus: "focusin", blur: "focusout" }, function (a, b) { var c = function (a) { n.event.simulate(b, a.target, n.event.fix(a)) }; n.event.special[b] = { setup: function () { var d = this.ownerDocument || this, e = n._data(d, b); e || d.addEventListener(a, c, !0), n._data(d, b, (e || 0) + 1) }, teardown: function () { var d = this.ownerDocument || this, e = n._data(d, b) - 1; e ? n._data(d, b, e) : (d.removeEventListener(a, c, !0), n._removeData(d, b)) } } }), n.fn.extend({ on: function (a, b, c, d) { return sa(this, a, b, c, d) }, one: function (a, b, c, d) { return sa(this, a, b, c, d, 1) }, off: function (a, b, c) { var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this; if ("object" == typeof a) { for (e in a) this.off(e, b, a[e]); return this } return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = qa), this.each(function () { n.event.remove(this, a, c, b) }) }, trigger: function (a, b) { return this.each(function () { n.event.trigger(a, b, this) }) }, triggerHandler: function (a, b) { var c = this[0]; return c ? n.event.trigger(a, b, c, !0) : void 0 } }); var ta = / jQuery\d+="(?:null|\d+)"/g, ua = new RegExp("<(?:" + ba + ")[\\s/>]", "i"), va = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wa = /<script|<style|<link/i, xa = /checked\s*(?:[^=]|=\s*.checked.)/i, ya = /^true\/(.*)/, za = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, Aa = ca(d), Ba = Aa.appendChild(d.createElement("div")); function Ca(a, b) { return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a } function Da(a) { return a.type = (null !== n.find.attr(a, "type")) + "/" + a.type, a } function Ea(a) { var b = ya.exec(a.type); return b ? a.type = b[1] : a.removeAttribute("type"), a } function Fa(a, b) { if (1 === b.nodeType && n.hasData(a)) { var c, d, e, f = n._data(a), g = n._data(b, f), h = f.events; if (h) { delete g.handle, g.events = {}; for (c in h) for (d = 0, e = h[c].length; e > d; d++) n.event.add(b, c, h[c][d]) } g.data && (g.data = n.extend({}, g.data)) } } function Ga(a, b) { var c, d, e; if (1 === b.nodeType) { if (c = b.nodeName.toLowerCase(), !l.noCloneEvent && b[n.expando]) { e = n._data(b); for (d in e.events) n.removeEvent(b, d, e.handle); b.removeAttribute(n.expando) } "script" === c && b.text !== a.text ? (Da(b).text = a.text, Ea(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), l.html5Clone && a.innerHTML && !n.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && Z.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue) } } function Ha(a, b, c, d) { b = f.apply([], b); var e, g, h, i, j, k, m = 0, o = a.length, p = o - 1, q = b[0], r = n.isFunction(q); if (r || o > 1 && "string" == typeof q && !l.checkClone && xa.test(q)) return a.each(function (e) { var f = a.eq(e); r && (b[0] = q.call(this, e, f.html())), Ha(f, b, c, d) }); if (o && (k = ja(b, a[0].ownerDocument, !1, a, d), e = k.firstChild, 1 === k.childNodes.length && (k = e), e || d)) { for (i = n.map(ea(k, "script"), Da), h = i.length; o > m; m++) g = k, m !== p && (g = n.clone(g, !0, !0), h && n.merge(i, ea(g, "script"))), c.call(a[m], g, m); if (h) for (j = i[i.length - 1].ownerDocument, n.map(i, Ea), m = 0; h > m; m++) g = i[m], _.test(g.type || "") && !n._data(g, "globalEval") && n.contains(j, g) && (g.src ? n._evalUrl && n._evalUrl(g.src) : n.globalEval((g.text || g.textContent || g.innerHTML || "").replace(za, ""))); k = e = null } return a } function Ia(a, b, c) { for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]) ; f++) c || 1 !== d.nodeType || n.cleanData(ea(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && fa(ea(d, "script")), d.parentNode.removeChild(d)); return a } n.extend({ htmlPrefilter: function (a) { return a.replace(va, "<$1></$2>") }, clone: function (a, b, c) { var d, e, f, g, h, i = n.contains(a.ownerDocument, a); if (l.html5Clone || n.isXMLDoc(a) || !ua.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (Ba.innerHTML = a.outerHTML, Ba.removeChild(f = Ba.firstChild)), !(l.noCloneEvent && l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (d = ea(f), h = ea(a), g = 0; null != (e = h[g]) ; ++g) d[g] && Ga(e, d[g]); if (b) if (c) for (h = h || ea(a), d = d || ea(f), g = 0; null != (e = h[g]) ; g++) Fa(e, d[g]); else Fa(a, f); return d = ea(f, "script"), d.length > 0 && fa(d, !i && ea(a, "script")), d = h = e = null, f }, cleanData: function (a, b) { for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.attributes, m = n.event.special; null != (d = a[h]) ; h++) if ((b || M(d)) && (f = d[i], g = f && j[f])) { if (g.events) for (e in g.events) m[e] ? n.event.remove(d, e) : n.removeEvent(d, e, g.handle); j[f] && (delete j[f], k || "undefined" == typeof d.removeAttribute ? d[i] = void 0 : d.removeAttribute(i), c.push(f)) } } }), n.fn.extend({ domManip: Ha, detach: function (a) { return Ia(this, a, !0) }, remove: function (a) { return Ia(this, a) }, text: function (a) { return Y(this, function (a) { return void 0 === a ? n.text(this) : this.empty().append((this[0] && this[0].ownerDocument || d).createTextNode(a)) }, null, a, arguments.length) }, append: function () { return Ha(this, arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = Ca(this, a); b.appendChild(a) } }) }, prepend: function () { return Ha(this, arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var b = Ca(this, a); b.insertBefore(a, b.firstChild) } }) }, before: function () { return Ha(this, arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this) }) }, after: function () { return Ha(this, arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this.nextSibling) }) }, empty: function () { for (var a, b = 0; null != (a = this[b]) ; b++) { 1 === a.nodeType && n.cleanData(ea(a, !1)); while (a.firstChild) a.removeChild(a.firstChild); a.options && n.nodeName(a, "select") && (a.options.length = 0) } return this }, clone: function (a, b) { return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () { return n.clone(this, a, b) }) }, html: function (a) { return Y(this, function (a) { var b = this[0] || {}, c = 0, d = this.length; if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(ta, "") : void 0; if ("string" == typeof a && !wa.test(a) && (l.htmlSerialize || !ua.test(a)) && (l.leadingWhitespace || !aa.test(a)) && !da[($.exec(a) || ["", ""])[1].toLowerCase()]) { a = n.htmlPrefilter(a); try { for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (n.cleanData(ea(b, !1)), b.innerHTML = a); b = 0 } catch (e) { } } b && this.empty().append(a) }, null, a, arguments.length) }, replaceWith: function () { var a = []; return Ha(this, arguments, function (b) { var c = this.parentNode; n.inArray(this, a) < 0 && (n.cleanData(ea(this)), c && c.replaceChild(b, this)) }, a) } }), n.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (a, b) { n.fn[a] = function (a) { for (var c, d = 0, e = [], f = n(a), h = f.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0), n(f[d])[b](c), g.apply(e, c.get()); return this.pushStack(e) } }); var Ja, Ka = { HTML: "block", BODY: "block" }; function La(a, b) { var c = n(b.createElement(a)).appendTo(b.body), d = n.css(c[0], "display"); return c.detach(), d } function Ma(a) { var b = d, c = Ka[a]; return c || (c = La(a, b), "none" !== c && c || (Ja = (Ja || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = (Ja[0].contentWindow || Ja[0].contentDocument).document, b.write(), b.close(), c = La(a, b), Ja.detach()), Ka[a] = c), c } var Na = /^margin/, Oa = new RegExp("^(" + T + ")(?!px)[a-z%]+$", "i"), Pa = function (a, b, c, d) { var e, f, g = {}; for (f in b) g[f] = a.style[f], a.style[f] = b[f]; e = c.apply(a, d || []); for (f in b) a.style[f] = g[f]; return e }, Qa = d.documentElement; !function () { var b, c, e, f, g, h, i = d.createElement("div"), j = d.createElement("div"); if (j.style) { j.style.cssText = "float:left;opacity:.5", l.opacity = "0.5" === j.style.opacity, l.cssFloat = !!j.style.cssFloat, j.style.backgroundClip = "content-box", j.cloneNode(!0).style.backgroundClip = "", l.clearCloneStyle = "content-box" === j.style.backgroundClip, i = d.createElement("div"), i.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", j.innerHTML = "", i.appendChild(j), l.boxSizing = "" === j.style.boxSizing || "" === j.style.MozBoxSizing || "" === j.style.WebkitBoxSizing, n.extend(l, { reliableHiddenOffsets: function () { return null == b && k(), f }, boxSizingReliable: function () { return null == b && k(), e }, pixelMarginRight: function () { return null == b && k(), c }, pixelPosition: function () { return null == b && k(), b }, reliableMarginRight: function () { return null == b && k(), g }, reliableMarginLeft: function () { return null == b && k(), h } }); function k() { var k, l, m = d.documentElement; m.appendChild(i), j.style.cssText = "-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", b = e = h = !1, c = g = !0, a.getComputedStyle && (l = a.getComputedStyle(j), b = "1%" !== (l || {}).top, h = "2px" === (l || {}).marginLeft, e = "4px" === (l || { width: "4px" }).width, j.style.marginRight = "50%", c = "4px" === (l || { marginRight: "4px" }).marginRight, k = j.appendChild(d.createElement("div")), k.style.cssText = j.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", k.style.marginRight = k.style.width = "0", j.style.width = "1px", g = !parseFloat((a.getComputedStyle(k) || {}).marginRight), j.removeChild(k)), j.style.display = "none", f = 0 === j.getClientRects().length, f && (j.style.display = "", j.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", k = j.getElementsByTagName("td"), k[0].style.cssText = "margin:0;border:0;padding:0;display:none", f = 0 === k[0].offsetHeight, f && (k[0].style.display = "", k[1].style.display = "none", f = 0 === k[0].offsetHeight)), m.removeChild(i) } } }(); var Ra, Sa, Ta = /^(top|right|bottom|left)$/; a.getComputedStyle ? (Ra = function (b) { var c = b.ownerDocument.defaultView; return c && c.opener || (c = a), c.getComputedStyle(b) }, Sa = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ra(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Oa.test(g) && Na.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 === g ? g : g + "" }) : Qa.currentStyle && (Ra = function (a) { return a.currentStyle }, Sa = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ra(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), Oa.test(g) && !Ta.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g ? g : g + "" || "auto" }); function Ua(a, b) { return { get: function () { return a() ? void delete this.get : (this.get = b).apply(this, arguments) } } } var Va = /alpha\([^)]*\)/i, Wa = /opacity\s*=\s*([^)]*)/i, Xa = /^(none|table(?!-c[ea]).+)/, Ya = new RegExp("^(" + T + ")(.*)$", "i"), Za = { position: "absolute", visibility: "hidden", display: "block" }, $a = { letterSpacing: "0", fontWeight: "400" }, _a = ["Webkit", "O", "Moz", "ms"], ab = d.createElement("div").style; function bb(a) { if (a in ab) return a; var b = a.charAt(0).toUpperCase() + a.slice(1), c = _a.length; while (c--) if (a = _a[c] + b, a in ab) return a } function cb(a, b) { for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = n._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && W(d) && (f[g] = n._data(d, "olddisplay", Ma(d.nodeName)))) : (e = W(d), (c && "none" !== c || !e) && n._data(d, "olddisplay", e ? c : n.css(d, "display")))); for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none")); return a } function db(a, b, c) { var d = Ya.exec(b); return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b } function eb(a, b, c, d, e) { for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += n.css(a, c + V[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + V[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + V[f] + "Width", !0, e))) : (g += n.css(a, "padding" + V[f], !0, e), "padding" !== c && (g += n.css(a, "border" + V[f] + "Width", !0, e))); return g } function fb(b, c, e) { var f = !0, g = "width" === c ? b.offsetWidth : b.offsetHeight, h = Ra(b), i = l.boxSizing && "border-box" === n.css(b, "boxSizing", !1, h); if (d.msFullscreenElement && a.top !== a && b.getClientRects().length && (g = Math.round(100 * b.getBoundingClientRect()[c])), 0 >= g || null == g) { if (g = Sa(b, c, h), (0 > g || null == g) && (g = b.style[c]), Oa.test(g)) return g; f = i && (l.boxSizingReliable() || g === b.style[c]), g = parseFloat(g) || 0 } return g + eb(b, c, e || (i ? "border" : "content"), f, h) + "px" } n.extend({ cssHooks: { opacity: { get: function (a, b) { if (b) { var c = Sa(a, "opacity"); return "" === c ? "1" : c } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": l.cssFloat ? "cssFloat" : "styleFloat" }, style: function (a, b, c, d) { if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) { var e, f, g, h = n.camelCase(b), i = a.style; if (b = n.cssProps[h] || (n.cssProps[h] = bb(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b]; if (f = typeof c, "string" === f && (e = U.exec(c)) && e[1] && (c = X(a, b, e), f = "number"), null != c && c === c && ("number" === f && (c += e && e[3] || (n.cssNumber[h] ? "" : "px")), l.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try { i[b] = c } catch (j) { } } }, css: function (a, b, c, d) { var e, f, g, h = n.camelCase(b); return b = n.cssProps[h] || (n.cssProps[h] = bb(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Sa(a, b, d)), "normal" === f && b in $a && (f = $a[b]), "" === c || c ? (e = parseFloat(f), c === !0 || isFinite(e) ? e || 0 : f) : f } }), n.each(["height", "width"], function (a, b) { n.cssHooks[b] = { get: function (a, c, d) { return c ? Xa.test(n.css(a, "display")) && 0 === a.offsetWidth ? Pa(a, Za, function () { return fb(a, b, d) }) : fb(a, b, d) : void 0 }, set: function (a, c, d) { var e = d && Ra(a); return db(a, c, d ? eb(a, b, d, l.boxSizing && "border-box" === n.css(a, "boxSizing", !1, e), e) : 0) } } }), l.opacity || (n.cssHooks.opacity = { get: function (a, b) { return Wa.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "" }, set: function (a, b) { var c = a.style, d = a.currentStyle, e = n.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || ""; c.zoom = 1, (b >= 1 || "" === b) && "" === n.trim(f.replace(Va, "")) && c.removeAttribute && (c.removeAttribute("filter"), "" === b || d && !d.filter) || (c.filter = Va.test(f) ? f.replace(Va, e) : f + " " + e) } }), n.cssHooks.marginRight = Ua(l.reliableMarginRight, function (a, b) { return b ? Pa(a, { display: "inline-block" }, Sa, [a, "marginRight"]) : void 0 }), n.cssHooks.marginLeft = Ua(l.reliableMarginLeft, function (a, b) {
        return b ? (parseFloat(Sa(a, "marginLeft")) || (n.contains(a.ownerDocument, a) ? a.getBoundingClientRect().left - Pa(a, { marginLeft: 0 }, function () { return a.getBoundingClientRect().left }) : 0)) + "px" : void 0
    }), n.each({ margin: "", padding: "", border: "Width" }, function (a, b) { n.cssHooks[a + b] = { expand: function (c) { for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + V[d] + b] = f[d] || f[d - 2] || f[0]; return e } }, Na.test(a) || (n.cssHooks[a + b].set = db) }), n.fn.extend({ css: function (a, b) { return Y(this, function (a, b, c) { var d, e, f = {}, g = 0; if (n.isArray(b)) { for (d = Ra(a), e = b.length; e > g; g++) f[b[g]] = n.css(a, b[g], !1, d); return f } return void 0 !== c ? n.style(a, b, c) : n.css(a, b) }, a, b, arguments.length > 1) }, show: function () { return cb(this, !0) }, hide: function () { return cb(this) }, toggle: function (a) { return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () { W(this) ? n(this).show() : n(this).hide() }) } }); function gb(a, b, c, d, e) { return new gb.prototype.init(a, b, c, d, e) } n.Tween = gb, gb.prototype = { constructor: gb, init: function (a, b, c, d, e, f) { this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px") }, cur: function () { var a = gb.propHooks[this.prop]; return a && a.get ? a.get(this) : gb.propHooks._default.get(this) }, run: function (a) { var b, c = gb.propHooks[this.prop]; return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : gb.propHooks._default.set(this), this } }, gb.prototype.init.prototype = gb.prototype, gb.propHooks = { _default: { get: function (a) { var b; return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) }, set: function (a) { n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit) } } }, gb.propHooks.scrollTop = gb.propHooks.scrollLeft = { set: function (a) { a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now) } }, n.easing = { linear: function (a) { return a }, swing: function (a) { return .5 - Math.cos(a * Math.PI) / 2 }, _default: "swing" }, n.fx = gb.prototype.init, n.fx.step = {}; var hb, ib, jb = /^(?:toggle|show|hide)$/, kb = /queueHooks$/; function lb() { return a.setTimeout(function () { hb = void 0 }), hb = n.now() } function mb(a, b) { var c, d = { height: a }, e = 0; for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = V[e], d["margin" + c] = d["padding" + c] = a; return b && (d.opacity = d.width = a), d } function nb(a, b, c) { for (var d, e = (qb.tweeners[b] || []).concat(qb.tweeners["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d } function ob(a, b, c) { var d, e, f, g, h, i, j, k, m = this, o = {}, p = a.style, q = a.nodeType && W(a), r = n._data(a, "fxshow"); c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () { h.unqueued || i() }), h.unqueued++, m.always(function () { m.always(function () { h.unqueued--, n.queue(a, "fx").length || h.empty.fire() }) })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css(a, "display"), k = "none" === j ? n._data(a, "olddisplay") || Ma(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (l.inlineBlockNeedsLayout && "inline" !== Ma(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), c.overflow && (p.overflow = "hidden", l.shrinkWrapBlocks() || m.always(function () { p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2] })); for (d in b) if (e = b[d], jb.exec(e)) { if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) { if ("show" !== e || !r || void 0 === r[d]) continue; q = !0 } o[d] = r && r[d] || n.style(a, d) } else j = void 0; if (n.isEmptyObject(o)) "inline" === ("none" === j ? Ma(a.nodeName) : j) && (p.display = j); else { r ? "hidden" in r && (q = r.hidden) : r = n._data(a, "fxshow", {}), f && (r.hidden = !q), q ? n(a).show() : m.done(function () { n(a).hide() }), m.done(function () { var b; n._removeData(a, "fxshow"); for (b in o) n.style(a, b, o[b]) }); for (d in o) g = nb(q ? r[d] : 0, d, m), d in r || (r[d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0)) } } function pb(a, b) { var c, d, e, f, g; for (c in a) if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) { f = g.expand(f), delete a[d]; for (c in f) c in a || (a[c] = f[c], b[c] = e) } else b[d] = e } function qb(a, b, c) { var d, e, f = 0, g = qb.prefilters.length, h = n.Deferred().always(function () { delete i.elem }), i = function () { if (e) return !1; for (var b = hb || lb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f); return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1) }, j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: hb || lb(), duration: c.duration, tweens: [], createTween: function (b, c) { var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing); return j.tweens.push(d), d }, stop: function (b) { var c = 0, d = b ? j.tweens.length : 0; if (e) return this; for (e = !0; d > c; c++) j.tweens[c].run(1); return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this } }), k = j.props; for (pb(k, j.opts.specialEasing) ; g > f; f++) if (d = qb.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d; return n.map(k, nb, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always) } n.Animation = n.extend(qb, { tweeners: { "*": [function (a, b) { var c = this.createTween(a, b); return X(c.elem, a, U.exec(b), c), c }] }, tweener: function (a, b) { n.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(G); for (var c, d = 0, e = a.length; e > d; d++) c = a[d], qb.tweeners[c] = qb.tweeners[c] || [], qb.tweeners[c].unshift(b) }, prefilters: [ob], prefilter: function (a, b) { b ? qb.prefilters.unshift(a) : qb.prefilters.push(a) } }), n.speed = function (a, b, c) { var d = a && "object" == typeof a ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b }; return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function () { n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue) }, d }, n.fn.extend({ fadeTo: function (a, b, c, d) { return this.filter(W).css("opacity", 0).show().end().animate({ opacity: b }, a, c, d) }, animate: function (a, b, c, d) { var e = n.isEmptyObject(a), f = n.speed(b, c, d), g = function () { var b = qb(this, n.extend({}, a), f); (e || n._data(this, "finish")) && b.stop(!0) }; return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g) }, stop: function (a, b, c) { var d = function (a) { var b = a.stop; delete a.stop, b(c) }; return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () { var b = !0, e = null != a && a + "queueHooks", f = n.timers, g = n._data(this); if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && kb.test(e) && d(g[e]); for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1)); !b && c || n.dequeue(this, a) }) }, finish: function (a) { return a !== !1 && (a = a || "fx"), this.each(function () { var b, c = n._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = n.timers, g = d ? d.length : 0; for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1)); for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this); delete c.finish }) } }), n.each(["toggle", "show", "hide"], function (a, b) { var c = n.fn[b]; n.fn[b] = function (a, d, e) { return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(mb(b, !0), a, d, e) } }), n.each({ slideDown: mb("show"), slideUp: mb("hide"), slideToggle: mb("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (a, b) { n.fn[a] = function (a, c, d) { return this.animate(b, a, c, d) } }), n.timers = [], n.fx.tick = function () { var a, b = n.timers, c = 0; for (hb = n.now() ; c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1); b.length || n.fx.stop(), hb = void 0 }, n.fx.timer = function (a) { n.timers.push(a), a() ? n.fx.start() : n.timers.pop() }, n.fx.interval = 13, n.fx.start = function () { ib || (ib = a.setInterval(n.fx.tick, n.fx.interval)) }, n.fx.stop = function () { a.clearInterval(ib), ib = null }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) { return b = n.fx ? n.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function (c, d) { var e = a.setTimeout(c, b); d.stop = function () { a.clearTimeout(e) } }) }, function () { var a, b = d.createElement("input"), c = d.createElement("div"), e = d.createElement("select"), f = e.appendChild(d.createElement("option")); c = d.createElement("div"), c.setAttribute("className", "t"), c.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", a = c.getElementsByTagName("a")[0], b.setAttribute("type", "checkbox"), c.appendChild(b), a = c.getElementsByTagName("a")[0], a.style.cssText = "top:1px", l.getSetAttribute = "t" !== c.className, l.style = /top/.test(a.getAttribute("style")), l.hrefNormalized = "/a" === a.getAttribute("href"), l.checkOn = !!b.value, l.optSelected = f.selected, l.enctype = !!d.createElement("form").enctype, e.disabled = !0, l.optDisabled = !f.disabled, b = d.createElement("input"), b.setAttribute("value", ""), l.input = "" === b.getAttribute("value"), b.value = "t", b.setAttribute("type", "radio"), l.radioValue = "t" === b.value }(); var rb = /\r/g, sb = /[\x20\t\r\n\f]+/g; n.fn.extend({ val: function (a) { var b, c, d, e = this[0]; { if (arguments.length) return d = n.isFunction(a), this.each(function (c) { var e; 1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function (a) { return null == a ? "" : a + "" })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e)) }); if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(rb, "") : null == c ? "" : c) } } }), n.extend({ valHooks: { option: { get: function (a) { var b = n.find.attr(a, "value"); return null != b ? b : n.trim(n.text(a)).replace(sb, " ") } }, select: { get: function (a) { for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, "optgroup"))) { if (b = n(c).val(), f) return b; g.push(b) } return g }, set: function (a, b) { var c, d, e = a.options, f = n.makeArray(b), g = e.length; while (g--) if (d = e[g], n.inArray(n.valHooks.option.get(d), f) > -1) try { d.selected = c = !0 } catch (h) { d.scrollHeight } else d.selected = !1; return c || (a.selectedIndex = -1), e } } } }), n.each(["radio", "checkbox"], function () { n.valHooks[this] = { set: function (a, b) { return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0 } }, l.checkOn || (n.valHooks[this].get = function (a) { return null === a.getAttribute("value") ? "on" : a.value }) }); var tb, ub, vb = n.expr.attrHandle, wb = /^(?:checked|selected)$/i, xb = l.getSetAttribute, yb = l.input; n.fn.extend({ attr: function (a, b) { return Y(this, n.attr, a, b, arguments.length > 1) }, removeAttr: function (a) { return this.each(function () { n.removeAttr(this, a) }) } }), n.extend({ attr: function (a, b, c) { var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ub : tb)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d)) }, attrHooks: { type: { set: function (a, b) { if (!l.radioValue && "radio" === b && n.nodeName(a, "input")) { var c = a.value; return a.setAttribute("type", b), c && (a.value = c), b } } } }, removeAttr: function (a, b) { var c, d, e = 0, f = b && b.match(G); if (f && 1 === a.nodeType) while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) ? yb && xb || !wb.test(c) ? a[d] = !1 : a[n.camelCase("default-" + c)] = a[d] = !1 : n.attr(a, c, ""), a.removeAttribute(xb ? c : d) } }), ub = { set: function (a, b, c) { return b === !1 ? n.removeAttr(a, c) : yb && xb || !wb.test(c) ? a.setAttribute(!xb && n.propFix[c] || c, c) : a[n.camelCase("default-" + c)] = a[c] = !0, c } }, n.each(n.expr.match.bool.source.match(/\w+/g), function (a, b) { var c = vb[b] || n.find.attr; yb && xb || !wb.test(b) ? vb[b] = function (a, b, d) { var e, f; return d || (f = vb[b], vb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, vb[b] = f), e } : vb[b] = function (a, b, c) { return c ? void 0 : a[n.camelCase("default-" + b)] ? b.toLowerCase() : null } }), yb && xb || (n.attrHooks.value = { set: function (a, b, c) { return n.nodeName(a, "input") ? void (a.defaultValue = b) : tb && tb.set(a, b, c) } }), xb || (tb = { set: function (a, b, c) { var d = a.getAttributeNode(c); return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0 } }, vb.id = vb.name = vb.coords = function (a, b, c) { var d; return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null }, n.valHooks.button = { get: function (a, b) { var c = a.getAttributeNode(b); return c && c.specified ? c.value : void 0 }, set: tb.set }, n.attrHooks.contenteditable = { set: function (a, b, c) { tb.set(a, "" === b ? !1 : b, c) } }, n.each(["width", "height"], function (a, b) { n.attrHooks[b] = { set: function (a, c) { return "" === c ? (a.setAttribute(b, "auto"), c) : void 0 } } })), l.style || (n.attrHooks.style = { get: function (a) { return a.style.cssText || void 0 }, set: function (a, b) { return a.style.cssText = b + "" } }); var zb = /^(?:input|select|textarea|button|object)$/i, Ab = /^(?:a|area)$/i; n.fn.extend({ prop: function (a, b) { return Y(this, n.prop, a, b, arguments.length > 1) }, removeProp: function (a) { return a = n.propFix[a] || a, this.each(function () { try { this[a] = void 0, delete this[a] } catch (b) { } }) } }), n.extend({ prop: function (a, b, c) { var d, e, f = a.nodeType; if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b] }, propHooks: { tabIndex: { get: function (a) { var b = n.find.attr(a, "tabindex"); return b ? parseInt(b, 10) : zb.test(a.nodeName) || Ab.test(a.nodeName) && a.href ? 0 : -1 } } }, propFix: { "for": "htmlFor", "class": "className" } }), l.hrefNormalized || n.each(["href", "src"], function (a, b) { n.propHooks[b] = { get: function (a) { return a.getAttribute(b, 4) } } }), l.optSelected || (n.propHooks.selected = { get: function (a) { var b = a.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null }, set: function (a) { var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex) } }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { n.propFix[this.toLowerCase()] = this }), l.enctype || (n.propFix.enctype = "encoding"); var Bb = /[\t\r\n\f]/g; function Cb(a) { return n.attr(a, "class") || "" } n.fn.extend({ addClass: function (a) { var b, c, d, e, f, g, h, i = 0; if (n.isFunction(a)) return this.each(function (b) { n(this).addClass(a.call(this, b, Cb(this))) }); if ("string" == typeof a && a) { b = a.match(G) || []; while (c = this[i++]) if (e = Cb(c), d = 1 === c.nodeType && (" " + e + " ").replace(Bb, " ")) { g = 0; while (f = b[g++]) d.indexOf(" " + f + " ") < 0 && (d += f + " "); h = n.trim(d), e !== h && n.attr(c, "class", h) } } return this }, removeClass: function (a) { var b, c, d, e, f, g, h, i = 0; if (n.isFunction(a)) return this.each(function (b) { n(this).removeClass(a.call(this, b, Cb(this))) }); if (!arguments.length) return this.attr("class", ""); if ("string" == typeof a && a) { b = a.match(G) || []; while (c = this[i++]) if (e = Cb(c), d = 1 === c.nodeType && (" " + e + " ").replace(Bb, " ")) { g = 0; while (f = b[g++]) while (d.indexOf(" " + f + " ") > -1) d = d.replace(" " + f + " ", " "); h = n.trim(d), e !== h && n.attr(c, "class", h) } } return this }, toggleClass: function (a, b) { var c = typeof a; return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) { n(this).toggleClass(a.call(this, c, Cb(this), b), b) }) : this.each(function () { var b, d, e, f; if ("string" === c) { d = 0, e = n(this), f = a.match(G) || []; while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b) } else void 0 !== a && "boolean" !== c || (b = Cb(this), b && n._data(this, "__className__", b), n.attr(this, "class", b || a === !1 ? "" : n._data(this, "__className__") || "")) }) }, hasClass: function (a) { var b, c, d = 0; b = " " + a + " "; while (c = this[d++]) if (1 === c.nodeType && (" " + Cb(c) + " ").replace(Bb, " ").indexOf(b) > -1) return !0; return !1 } }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) { n.fn[b] = function (a, c) { return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b) } }), n.fn.extend({ hover: function (a, b) { return this.mouseenter(a).mouseleave(b || a) } }); var Db = a.location, Eb = n.now(), Fb = /\?/, Gb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g; n.parseJSON = function (b) { if (a.JSON && a.JSON.parse) return a.JSON.parse(b + ""); var c, d = null, e = n.trim(b + ""); return e && !n.trim(e.replace(Gb, function (a, b, e, f) { return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "") })) ? Function("return " + e)() : n.error("Invalid JSON: " + b) }, n.parseXML = function (b) { var c, d; if (!b || "string" != typeof b) return null; try { a.DOMParser ? (d = new a.DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new a.ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b)) } catch (e) { c = void 0 } return c && c.documentElement && !c.getElementsByTagName("parsererror").length || n.error("Invalid XML: " + b), c }; var Hb = /#.*$/, Ib = /([?&])_=[^&]*/, Jb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Kb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Lb = /^(?:GET|HEAD)$/, Mb = /^\/\//, Nb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Ob = {}, Pb = {}, Qb = "*/".concat("*"), Rb = Db.href, Sb = Nb.exec(Rb.toLowerCase()) || []; function Tb(a) { return function (b, c) { "string" != typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase().match(G) || []; if (n.isFunction(c)) while (d = f[e++]) "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c) } } function Ub(a, b, c, d) { var e = {}, f = a === Pb; function g(h) { var i; return e[h] = !0, n.each(a[h] || [], function (a, h) { var j = h(b, c, d); return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1) }), i } return g(b.dataTypes[0]) || !e["*"] && g("*") } function Vb(a, b) { var c, d, e = n.ajaxSettings.flatOptions || {}; for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]); return c && n.extend(!0, a, c), a } function Wb(a, b, c) { var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i[0]) i.shift(), void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type")); if (e) for (g in h) if (h[g] && h[g].test(e)) { i.unshift(g); break } if (i[0] in c) f = i[0]; else { for (g in c) { if (!i[0] || a.converters[g + " " + i[0]]) { f = g; break } d || (d = g) } f = f || d } return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0 } function Xb(a, b, c, d) { var e, f, g, h, i, j = {}, k = a.dataTypes.slice(); if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g]; f = k.shift(); while (f) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) { if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) { g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1])); break } if (g !== !0) if (g && a["throws"]) b = g(b); else try { b = g(b) } catch (l) { return { state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f } } } return { state: "success", data: b } } n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Rb, type: "GET", isLocal: Kb.test(Sb[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Qb, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": n.parseJSON, "text xml": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (a, b) { return b ? Vb(Vb(a, n.ajaxSettings), b) : Vb(n.ajaxSettings, a) }, ajaxPrefilter: Tb(Ob), ajaxTransport: Tb(Pb), ajax: function (b, c) { "object" == typeof b && (c = b, b = void 0), c = c || {}; var d, e, f, g, h, i, j, k, l = n.ajaxSetup({}, c), m = l.context || l, o = l.context && (m.nodeType || m.jquery) ? n(m) : n.event, p = n.Deferred(), q = n.Callbacks("once memory"), r = l.statusCode || {}, s = {}, t = {}, u = 0, v = "canceled", w = { readyState: 0, getResponseHeader: function (a) { var b; if (2 === u) { if (!k) { k = {}; while (b = Jb.exec(g)) k[b[1].toLowerCase()] = b[2] } b = k[a.toLowerCase()] } return null == b ? null : b }, getAllResponseHeaders: function () { return 2 === u ? g : null }, setRequestHeader: function (a, b) { var c = a.toLowerCase(); return u || (a = t[c] = t[c] || a, s[a] = b), this }, overrideMimeType: function (a) { return u || (l.mimeType = a), this }, statusCode: function (a) { var b; if (a) if (2 > u) for (b in a) r[b] = [r[b], a[b]]; else w.always(a[w.status]); return this }, abort: function (a) { var b = a || v; return j && j.abort(b), y(0, b), this } }; if (p.promise(w).complete = q.add, w.success = w.done, w.error = w.fail, l.url = ((b || l.url || Rb) + "").replace(Hb, "").replace(Mb, Sb[1] + "//"), l.type = c.method || c.type || l.method || l.type, l.dataTypes = n.trim(l.dataType || "*").toLowerCase().match(G) || [""], null == l.crossDomain && (d = Nb.exec(l.url.toLowerCase()), l.crossDomain = !(!d || d[1] === Sb[1] && d[2] === Sb[2] && (d[3] || ("http:" === d[1] ? "80" : "443")) === (Sb[3] || ("http:" === Sb[1] ? "80" : "443")))), l.data && l.processData && "string" != typeof l.data && (l.data = n.param(l.data, l.traditional)), Ub(Ob, l, c, w), 2 === u) return w; i = n.event && l.global, i && 0 === n.active++ && n.event.trigger("ajaxStart"), l.type = l.type.toUpperCase(), l.hasContent = !Lb.test(l.type), f = l.url, l.hasContent || (l.data && (f = l.url += (Fb.test(f) ? "&" : "?") + l.data, delete l.data), l.cache === !1 && (l.url = Ib.test(f) ? f.replace(Ib, "$1_=" + Eb++) : f + (Fb.test(f) ? "&" : "?") + "_=" + Eb++)), l.ifModified && (n.lastModified[f] && w.setRequestHeader("If-Modified-Since", n.lastModified[f]), n.etag[f] && w.setRequestHeader("If-None-Match", n.etag[f])), (l.data && l.hasContent && l.contentType !== !1 || c.contentType) && w.setRequestHeader("Content-Type", l.contentType), w.setRequestHeader("Accept", l.dataTypes[0] && l.accepts[l.dataTypes[0]] ? l.accepts[l.dataTypes[0]] + ("*" !== l.dataTypes[0] ? ", " + Qb + "; q=0.01" : "") : l.accepts["*"]); for (e in l.headers) w.setRequestHeader(e, l.headers[e]); if (l.beforeSend && (l.beforeSend.call(m, w, l) === !1 || 2 === u)) return w.abort(); v = "abort"; for (e in { success: 1, error: 1, complete: 1 }) w[e](l[e]); if (j = Ub(Pb, l, c, w)) { if (w.readyState = 1, i && o.trigger("ajaxSend", [w, l]), 2 === u) return w; l.async && l.timeout > 0 && (h = a.setTimeout(function () { w.abort("timeout") }, l.timeout)); try { u = 1, j.send(s, y) } catch (x) { if (!(2 > u)) throw x; y(-1, x) } } else y(-1, "No Transport"); function y(b, c, d, e) { var k, s, t, v, x, y = c; 2 !== u && (u = 2, h && a.clearTimeout(h), j = void 0, g = e || "", w.readyState = b > 0 ? 4 : 0, k = b >= 200 && 300 > b || 304 === b, d && (v = Wb(l, w, d)), v = Xb(l, v, w, k), k ? (l.ifModified && (x = w.getResponseHeader("Last-Modified"), x && (n.lastModified[f] = x), x = w.getResponseHeader("etag"), x && (n.etag[f] = x)), 204 === b || "HEAD" === l.type ? y = "nocontent" : 304 === b ? y = "notmodified" : (y = v.state, s = v.data, t = v.error, k = !t)) : (t = y, !b && y || (y = "error", 0 > b && (b = 0))), w.status = b, w.statusText = (c || y) + "", k ? p.resolveWith(m, [s, y, w]) : p.rejectWith(m, [w, y, t]), w.statusCode(r), r = void 0, i && o.trigger(k ? "ajaxSuccess" : "ajaxError", [w, l, k ? s : t]), q.fireWith(m, [w, y]), i && (o.trigger("ajaxComplete", [w, l]), --n.active || n.event.trigger("ajaxStop"))) } return w }, getJSON: function (a, b, c) { return n.get(a, b, c, "json") }, getScript: function (a, b) { return n.get(a, void 0, b, "script") } }), n.each(["get", "post"], function (a, b) { n[b] = function (a, c, d, e) { return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a)) } }), n._evalUrl = function (a) { return n.ajax({ url: a, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, "throws": !0 }) }, n.fn.extend({ wrapAll: function (a) { if (n.isFunction(a)) return this.each(function (b) { n(this).wrapAll(a.call(this, b)) }); if (this[0]) { var b = n(a, this[0].ownerDocument).eq(0).clone(!0); this[0].parentNode && b.insertBefore(this[0]), b.map(function () { var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; return a }).append(this) } return this }, wrapInner: function (a) { return n.isFunction(a) ? this.each(function (b) { n(this).wrapInner(a.call(this, b)) }) : this.each(function () { var b = n(this), c = b.contents(); c.length ? c.wrapAll(a) : b.append(a) }) }, wrap: function (a) { var b = n.isFunction(a); return this.each(function (c) { n(this).wrapAll(b ? a.call(this, c) : a) }) }, unwrap: function () { return this.parent().each(function () { n.nodeName(this, "body") || n(this).replaceWith(this.childNodes) }).end() } }); function Yb(a) { return a.style && a.style.display || n.css(a, "display") } function Zb(a) { while (a && 1 === a.nodeType) { if ("none" === Yb(a) || "hidden" === a.type) return !0; a = a.parentNode } return !1 } n.expr.filters.hidden = function (a) { return l.reliableHiddenOffsets() ? a.offsetWidth <= 0 && a.offsetHeight <= 0 && !a.getClientRects().length : Zb(a) }, n.expr.filters.visible = function (a) { return !n.expr.filters.hidden(a) }; var $b = /%20/g, _b = /\[\]$/, ac = /\r?\n/g, bc = /^(?:submit|button|image|reset|file)$/i, cc = /^(?:input|select|textarea|keygen)/i; function dc(a, b, c, d) { var e; if (n.isArray(b)) n.each(b, function (b, e) { c || _b.test(a) ? d(a, e) : dc(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d) }); else if (c || "object" !== n.type(b)) d(a, b); else for (e in b) dc(a + "[" + e + "]", b[e], c, d) } n.param = function (a, b) { var c, d = [], e = function (a, b) { b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b) }; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () { e(this.name, this.value) }); else for (c in a) dc(c, a[c], b, e); return d.join("&").replace($b, "+") }, n.fn.extend({ serialize: function () { return n.param(this.serializeArray()) }, serializeArray: function () { return this.map(function () { var a = n.prop(this, "elements"); return a ? n.makeArray(a) : this }).filter(function () { var a = this.type; return this.name && !n(this).is(":disabled") && cc.test(this.nodeName) && !bc.test(a) && (this.checked || !Z.test(a)) }).map(function (a, b) { var c = n(this).val(); return null == c ? null : n.isArray(c) ? n.map(c, function (a) { return { name: b.name, value: a.replace(ac, "\r\n") } }) : { name: b.name, value: c.replace(ac, "\r\n") } }).get() } }), n.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () { return this.isLocal ? ic() : d.documentMode > 8 ? hc() : /^(get|post|head|put|delete|options)$/i.test(this.type) && hc() || ic() } : hc; var ec = 0, fc = {}, gc = n.ajaxSettings.xhr(); a.attachEvent && a.attachEvent("onunload", function () { for (var a in fc) fc[a](void 0, !0) }), l.cors = !!gc && "withCredentials" in gc, gc = l.ajax = !!gc, gc && n.ajaxTransport(function (b) { if (!b.crossDomain || l.cors) { var c; return { send: function (d, e) { var f, g = b.xhr(), h = ++ec; if (g.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (f in b.xhrFields) g[f] = b.xhrFields[f]; b.mimeType && g.overrideMimeType && g.overrideMimeType(b.mimeType), b.crossDomain || d["X-Requested-With"] || (d["X-Requested-With"] = "XMLHttpRequest"); for (f in d) void 0 !== d[f] && g.setRequestHeader(f, d[f] + ""); g.send(b.hasContent && b.data || null), c = function (a, d) { var f, i, j; if (c && (d || 4 === g.readyState)) if (delete fc[h], c = void 0, g.onreadystatechange = n.noop, d) 4 !== g.readyState && g.abort(); else { j = {}, f = g.status, "string" == typeof g.responseText && (j.text = g.responseText); try { i = g.statusText } catch (k) { i = "" } f || !b.isLocal || b.crossDomain ? 1223 === f && (f = 204) : f = j.text ? 200 : 404 } j && e(f, i, j, g.getAllResponseHeaders()) }, b.async ? 4 === g.readyState ? a.setTimeout(c) : g.onreadystatechange = fc[h] = c : c() }, abort: function () { c && c(void 0, !0) } } } }); function hc() { try { return new a.XMLHttpRequest } catch (b) { } } function ic() { try { return new a.ActiveXObject("Microsoft.XMLHTTP") } catch (b) { } } n.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (a) { return n.globalEval(a), a } } }), n.ajaxPrefilter("script", function (a) { void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1) }), n.ajaxTransport("script", function (a) { if (a.crossDomain) { var b, c = d.head || n("head")[0] || d.documentElement; return { send: function (e, f) { b = d.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) { (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild(b), b = null, c || f(200, "success")) }, c.insertBefore(b, c.firstChild) }, abort: function () { b && b.onload(void 0, !0) } } } }); var jc = [], kc = /(=)\?(?=&|$)|\?\?/; n.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var a = jc.pop() || n.expando + "_" + Eb++; return this[a] = !0, a } }), n.ajaxPrefilter("json jsonp", function (b, c, d) { var e, f, g, h = b.jsonp !== !1 && (kc.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && kc.test(b.data) && "data"); return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(kc, "$1" + e) : b.jsonp !== !1 && (b.url += (Fb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () { return g || n.error(e + " was not called"), g[0] }, b.dataTypes[0] = "json", f = a[e], a[e] = function () { g = arguments }, d.always(function () { void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, jc.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0 }), "script") : void 0 }), n.parseHTML = function (a, b, c) { if (!a || "string" != typeof a) return null; "boolean" == typeof b && (c = b, b = !1), b = b || d; var e = x.exec(a), f = !c && []; return e ? [b.createElement(e[1])] : (e = ja([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes)) }; var lc = n.fn.load; n.fn.load = function (a, b, c) { if ("string" != typeof a && lc) return lc.apply(this, arguments); var d, e, f, g = this, h = a.indexOf(" "); return h > -1 && (d = n.trim(a.slice(h, a.length)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({ url: a, type: e || "GET", dataType: "html", data: b }).done(function (a) { f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a) }).always(c && function (a, b) { g.each(function () { c.apply(this, f || [a.responseText, b, a]) }) }), this }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) { n.fn[b] = function (a) { return this.on(b, a) } }), n.expr.filters.animated = function (a) { return n.grep(n.timers, function (b) { return a === b.elem }).length }; function mc(a) { return n.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1 } n.offset = { setOffset: function (a, b, c) { var d, e, f, g, h, i, j, k = n.css(a, "position"), l = n(a), m = {}; "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && n.inArray("auto", [f, i]) > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m) } }, n.fn.extend({ offset: function (a) { if (arguments.length) return void 0 === a ? this : this.each(function (b) { n.offset.setOffset(this, a, b) }); var b, c, d = { top: 0, left: 0 }, e = this[0], f = e && e.ownerDocument; if (f) return b = f.documentElement, n.contains(b, e) ? ("undefined" != typeof e.getBoundingClientRect && (d = e.getBoundingClientRect()), c = mc(f), { top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0) }) : d }, position: function () { if (this[0]) { var a, b, c = { top: 0, left: 0 }, d = this[0]; return "fixed" === n.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (c = a.offset()), c.top += n.css(a[0], "borderTopWidth", !0), c.left += n.css(a[0], "borderLeftWidth", !0)), { top: b.top - c.top - n.css(d, "marginTop", !0), left: b.left - c.left - n.css(d, "marginLeft", !0) } } }, offsetParent: function () { return this.map(function () { var a = this.offsetParent; while (a && !n.nodeName(a, "html") && "static" === n.css(a, "position")) a = a.offsetParent; return a || Qa }) } }), n.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (a, b) { var c = /Y/.test(b); n.fn[a] = function (d) { return Y(this, function (a, d, e) { var f = mc(a); return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? n(f).scrollLeft() : e, c ? e : n(f).scrollTop()) : a[d] = e) }, a, d, arguments.length, null) } }), n.each(["top", "left"], function (a, b) {
        n.cssHooks[b] = Ua(l.pixelPosition, function (a, c) {
            return c ? (c = Sa(a, b), Oa.test(c) ? n(a).position()[b] + "px" : c) : void 0;
        })
    }), n.each({ Height: "height", Width: "width" }, function (a, b) { n.each({ padding: "inner" + a, content: b, "": "outer" + a }, function (c, d) { n.fn[d] = function (d, e) { var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border"); return Y(this, function (b, c, d) { var e; return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g) }, b, f ? d : void 0, f, null) } }) }), n.fn.extend({ bind: function (a, b, c) { return this.on(a, null, b, c) }, unbind: function (a, b) { return this.off(a, null, b) }, delegate: function (a, b, c, d) { return this.on(b, a, c, d) }, undelegate: function (a, b, c) { return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c) } }), n.fn.size = function () { return this.length }, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () { return n }); var nc = a.jQuery, oc = a.$; return n.noConflict = function (b) { return a.$ === n && (a.$ = oc), b && a.jQuery === n && (a.jQuery = nc), n }, b || (a.jQuery = a.$ = n), n
});

/*
 AngularJS v1.5.5
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (v) {
    'use strict'; function O(a) { return function () { var b = arguments[0], d; d = "[" + (a ? a + ":" : "") + b + "] http://errors.angularjs.org/1.5.5/" + (a ? a + "/" : "") + b; for (b = 1; b < arguments.length; b++) { d = d + (1 == b ? "?" : "&") + "p" + (b - 1) + "="; var c = encodeURIComponent, e; e = arguments[b]; e = "function" == typeof e ? e.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof e ? "undefined" : "string" != typeof e ? JSON.stringify(e) : e; d += c(e) } return Error(d) } } function ya(a) {
        if (null == a || Va(a)) return !1; if (K(a) || F(a) || B && a instanceof B) return !0;
        var b = "length" in Object(a) && a.length; return Q(b) && (0 <= b && (b - 1 in a || a instanceof Array) || "function" == typeof a.item)
    } function q(a, b, d) {
        var c, e; if (a) if (E(a)) for (c in a) "prototype" == c || "length" == c || "name" == c || a.hasOwnProperty && !a.hasOwnProperty(c) || b.call(d, a[c], c, a); else if (K(a) || ya(a)) { var f = "object" !== typeof a; c = 0; for (e = a.length; c < e; c++) (f || c in a) && b.call(d, a[c], c, a) } else if (a.forEach && a.forEach !== q) a.forEach(b, d, a); else if (oc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" === typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) &&
        b.call(d, a[c], c, a); else for (c in a) ua.call(a, c) && b.call(d, a[c], c, a); return a
    } function pc(a, b, d) { for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++) b.call(d, a[c[e]], c[e]); return c } function qc(a) { return function (b, d) { a(d, b) } } function Xd() { return ++nb } function Nb(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; e < f; ++e) {
            var g = b[e]; if (G(g) || E(g)) for (var h = Object.keys(g), k = 0, l = h.length; k < l; k++) {
                var n = h[k], m = g[n]; d && G(m) ? fa(m) ? a[n] = new Date(m.valueOf()) : Wa(m) ? a[n] = new RegExp(m) : m.nodeName ? a[n] = m.cloneNode(!0) :
                Ob(m) ? a[n] = m.clone() : (G(a[n]) || (a[n] = K(m) ? [] : {}), Nb(a[n], [m], !0)) : a[n] = m
            }
        } c ? a.$$hashKey = c : delete a.$$hashKey; return a
    } function R(a) { return Nb(a, za.call(arguments, 1), !1) } function Yd(a) { return Nb(a, za.call(arguments, 1), !0) } function X(a) { return parseInt(a, 10) } function Pb(a, b) { return R(Object.create(a), b) } function C() { } function Xa(a) { return a } function da(a) { return function () { return a } } function rc(a) { return E(a.toString) && a.toString !== ma } function y(a) { return "undefined" === typeof a } function x(a) {
        return "undefined" !==
        typeof a
    } function G(a) { return null !== a && "object" === typeof a } function oc(a) { return null !== a && "object" === typeof a && !sc(a) } function F(a) { return "string" === typeof a } function Q(a) { return "number" === typeof a } function fa(a) { return "[object Date]" === ma.call(a) } function E(a) { return "function" === typeof a } function Wa(a) { return "[object RegExp]" === ma.call(a) } function Va(a) { return a && a.window === a } function Ya(a) { return a && a.$evalAsync && a.$watch } function Da(a) { return "boolean" === typeof a } function Zd(a) {
        return a && Q(a.length) &&
        $d.test(ma.call(a))
    } function Ob(a) { return !(!a || !(a.nodeName || a.prop && a.attr && a.find)) } function ae(a) { var b = {}; a = a.split(","); var d; for (d = 0; d < a.length; d++) b[a[d]] = !0; return b } function va(a) { return P(a.nodeName || a[0] && a[0].nodeName) } function Za(a, b) { var d = a.indexOf(b); 0 <= d && a.splice(d, 1); return d } function qa(a, b) {
        function d(a, b) {
            var d = b.$$hashKey, e; if (K(a)) { e = 0; for (var f = a.length; e < f; e++) b.push(c(a[e])) } else if (oc(a)) for (e in a) b[e] = c(a[e]); else if (a && "function" === typeof a.hasOwnProperty) for (e in a) a.hasOwnProperty(e) &&
            (b[e] = c(a[e])); else for (e in a) ua.call(a, e) && (b[e] = c(a[e])); d ? b.$$hashKey = d : delete b.$$hashKey; return b
        } function c(a) { if (!G(a)) return a; var b = f.indexOf(a); if (-1 !== b) return g[b]; if (Va(a) || Ya(a)) throw Aa("cpws"); var b = !1, c = e(a); void 0 === c && (c = K(a) ? [] : Object.create(sc(a)), b = !0); f.push(a); g.push(c); return b ? d(a, c) : c } function e(a) {
            switch (ma.call(a)) {
                case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Float32Array]": case "[object Float64Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return new a.constructor(c(a.buffer));
                case "[object ArrayBuffer]": if (!a.slice) { var b = new ArrayBuffer(a.byteLength); (new Uint8Array(b)).set(new Uint8Array(a)); return b } return a.slice(0); case "[object Boolean]": case "[object Number]": case "[object String]": case "[object Date]": return new a.constructor(a.valueOf()); case "[object RegExp]": return b = new RegExp(a.source, a.toString().match(/[^\/]*$/)[0]), b.lastIndex = a.lastIndex, b; case "[object Blob]": return new a.constructor([a], { type: a.type })
            } if (E(a.cloneNode)) return a.cloneNode(!0)
        } var f = [],
        g = []; if (b) { if (Zd(b) || "[object ArrayBuffer]" === ma.call(b)) throw Aa("cpta"); if (a === b) throw Aa("cpi"); K(b) ? b.length = 0 : q(b, function (a, d) { "$$hashKey" !== d && delete b[d] }); f.push(a); g.push(b); return d(a, b) } return c(a)
    } function ha(a, b) { if (K(a)) { b = b || []; for (var d = 0, c = a.length; d < c; d++) b[d] = a[d] } else if (G(a)) for (d in b = b || {}, a) if ("$" !== d.charAt(0) || "$" !== d.charAt(1)) b[d] = a[d]; return b || a } function pa(a, b) {
        if (a === b) return !0; if (null === a || null === b) return !1; if (a !== a && b !== b) return !0; var d = typeof a, c; if (d == typeof b &&
        "object" == d) if (K(a)) { if (!K(b)) return !1; if ((d = a.length) == b.length) { for (c = 0; c < d; c++) if (!pa(a[c], b[c])) return !1; return !0 } } else { if (fa(a)) return fa(b) ? pa(a.getTime(), b.getTime()) : !1; if (Wa(a)) return Wa(b) ? a.toString() == b.toString() : !1; if (Ya(a) || Ya(b) || Va(a) || Va(b) || K(b) || fa(b) || Wa(b)) return !1; d = T(); for (c in a) if ("$" !== c.charAt(0) && !E(a[c])) { if (!pa(a[c], b[c])) return !1; d[c] = !0 } for (c in b) if (!(c in d) && "$" !== c.charAt(0) && x(b[c]) && !E(b[c])) return !1; return !0 } return !1
    } function $a(a, b, d) {
        return a.concat(za.call(b,
        d))
    } function tc(a, b) { var d = 2 < arguments.length ? za.call(arguments, 2) : []; return !E(b) || b instanceof RegExp ? b : d.length ? function () { return arguments.length ? b.apply(a, $a(d, arguments, 0)) : b.apply(a, d) } : function () { return arguments.length ? b.apply(a, arguments) : b.call(a) } } function be(a, b) { var d = b; "string" === typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = void 0 : Va(b) ? d = "$WINDOW" : b && v.document === b ? d = "$DOCUMENT" : Ya(b) && (d = "$SCOPE"); return d } function ab(a, b) {
        if (!y(a)) return Q(b) || (b = b ? 2 : null), JSON.stringify(a, be,
        b)
    } function uc(a) { return F(a) ? JSON.parse(a) : a } function vc(a, b) { a = a.replace(ce, ""); var d = Date.parse("Jan 01, 1970 00:00:00 " + a) / 6E4; return isNaN(d) ? b : d } function Qb(a, b, d) { d = d ? -1 : 1; var c = a.getTimezoneOffset(); b = vc(b, c); d *= b - c; a = new Date(a.getTime()); a.setMinutes(a.getMinutes() + d); return a } function wa(a) { a = B(a).clone(); try { a.empty() } catch (b) { } var d = B("<div>").append(a).html(); try { return a[0].nodeType === Ma ? P(d) : d.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (a, b) { return "<" + P(b) }) } catch (c) { return P(d) } }
    function wc(a) { try { return decodeURIComponent(a) } catch (b) { } } function xc(a) { var b = {}; q((a || "").split("&"), function (a) { var c, e, f; a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), f = a.substring(c + 1)), e = wc(e), x(e) && (f = x(f) ? wc(f) : !0, ua.call(b, e) ? K(b[e]) ? b[e].push(f) : b[e] = [b[e], f] : b[e] = f)) }); return b } function Rb(a) { var b = []; q(a, function (a, c) { K(a) ? q(a, function (a) { b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0))) }) : b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0))) }); return b.length ? b.join("&") : "" }
    function ob(a) { return ja(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+") } function ja(a, b) { return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+") } function de(a, b) { var d, c, e = Na.length; for (c = 0; c < e; ++c) if (d = Na[c] + b, F(d = a.getAttribute(d))) return d; return null } function ee(a, b) {
        var d, c, e = {}; q(Na, function (b) { b += "app"; !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b)) });
        q(Na, function (b) { b += "app"; var e; !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b)) }); d && (e.strictDi = null !== de(d, "strict-di"), b(d, c ? [c] : [], e))
    } function yc(a, b, d) {
        G(d) || (d = {}); d = R({ strictDi: !1 }, d); var c = function () {
            a = B(a); if (a.injector()) { var c = a[0] === v.document ? "document" : wa(a); throw Aa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;")); } b = b || []; b.unshift(["$provide", function (b) { b.value("$rootElement", a) }]); d.debugInfoEnabled && b.push(["$compileProvider", function (a) { a.debugInfoEnabled(!0) }]);
            b.unshift("ng"); c = bb(b, d.strictDi); c.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (a, b, c, d) { a.$apply(function () { b.data("$injector", d); c(b)(a) }) }]); return c
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/; v && e.test(v.name) && (d.debugInfoEnabled = !0, v.name = v.name.replace(e, "")); if (v && !f.test(v.name)) return c(); v.name = v.name.replace(f, ""); ea.resumeBootstrap = function (a) { q(a, function (a) { b.push(a) }); return c() }; E(ea.resumeDeferredBootstrap) && ea.resumeDeferredBootstrap()
    } function fe() {
        v.name =
        "NG_ENABLE_DEBUG_INFO!" + v.name; v.location.reload()
    } function ge(a) { a = ea.element(a).injector(); if (!a) throw Aa("test"); return a.get("$$testability") } function zc(a, b) { b = b || "_"; return a.replace(he, function (a, c) { return (c ? b : "") + a.toLowerCase() }) } function ie() {
        var a; if (!Ac) {
            var b = pb(); (Z = y(b) ? v.jQuery : b ? v[b] : void 0) && Z.fn.on ? (B = Z, R(Z.fn, { scope: Oa.scope, isolateScope: Oa.isolateScope, controller: Oa.controller, injector: Oa.injector, inheritedData: Oa.inheritedData }), a = Z.cleanData, Z.cleanData = function (b) {
                for (var c,
                e = 0, f; null != (f = b[e]) ; e++) (c = Z._data(f, "events")) && c.$destroy && Z(f).triggerHandler("$destroy"); a(b)
            }) : B = U; ea.element = B; Ac = !0
        }
    } function qb(a, b, d) { if (!a) throw Aa("areq", b || "?", d || "required"); return a } function Pa(a, b, d) { d && K(a) && (a = a[a.length - 1]); qb(E(a), b, "not a function, got " + (a && "object" === typeof a ? a.constructor.name || "Object" : typeof a)); return a } function Qa(a, b) { if ("hasOwnProperty" === a) throw Aa("badname", b); } function Bc(a, b, d) {
        if (!b) return a; b = b.split("."); for (var c, e = a, f = b.length, g = 0; g < f; g++) c =
        b[g], a && (a = (e = a)[c]); return !d && E(a) ? tc(e, a) : a
    } function rb(a) { for (var b = a[0], d = a[a.length - 1], c, e = 1; b !== d && (b = b.nextSibling) ; e++) if (c || a[e] !== b) c || (c = B(za.call(a, 0, e))), c.push(b); return c || a } function T() { return Object.create(null) } function je(a) {
        function b(a, b, c) { return a[b] || (a[b] = c()) } var d = O("$injector"), c = O("ng"); a = b(a, "angular", Object); a.$$minErr = a.$$minErr || O; return b(a, "module", function () {
            var a = {}; return function (f, g, h) {
                if ("hasOwnProperty" === f) throw c("badname", "module"); g && a.hasOwnProperty(f) &&
                (a[f] = null); return b(a, f, function () {
                    function a(b, d, e, f) { f || (f = c); return function () { f[e || "push"]([b, d, arguments]); return M } } function b(a, d) { return function (b, e) { e && E(e) && (e.$$moduleName = f); c.push([a, d, arguments]); return M } } if (!g) throw d("nomod", f); var c = [], e = [], r = [], N = a("$injector", "invoke", "push", e), M = {
                        _invokeQueue: c, _configBlocks: e, _runBlocks: r, requires: g, name: f, provider: b("$provide", "provider"), factory: b("$provide", "factory"), service: b("$provide", "service"), value: a("$provide", "value"), constant: a("$provide",
                        "constant", "unshift"), decorator: b("$provide", "decorator"), animation: b("$animateProvider", "register"), filter: b("$filterProvider", "register"), controller: b("$controllerProvider", "register"), directive: b("$compileProvider", "directive"), component: b("$compileProvider", "component"), config: N, run: function (a) { r.push(a); return this }
                    }; h && N(h); return M
                })
            }
        })
    } function ke(a) {
        R(a, {
            bootstrap: yc, copy: qa, extend: R, merge: Yd, equals: pa, element: B, forEach: q, injector: bb, noop: C, bind: tc, toJson: ab, fromJson: uc, identity: Xa, isUndefined: y,
            isDefined: x, isString: F, isFunction: E, isObject: G, isNumber: Q, isElement: Ob, isArray: K, version: le, isDate: fa, lowercase: P, uppercase: sb, callbacks: { counter: 0 }, getTestability: ge, $$minErr: O, $$csp: Ea, reloadWithDebugInfo: fe
        }); Sb = je(v); Sb("ng", ["ngLocale"], ["$provide", function (a) {
            a.provider({ $$sanitizeUri: me }); a.provider("$compile", Cc).directive({
                a: ne, input: Dc, textarea: Dc, form: oe, script: pe, select: qe, style: re, option: se, ngBind: te, ngBindHtml: ue, ngBindTemplate: ve, ngClass: we, ngClassEven: xe, ngClassOdd: ye, ngCloak: ze, ngController: Ae,
                ngForm: Be, ngHide: Ce, ngIf: De, ngInclude: Ee, ngInit: Fe, ngNonBindable: Ge, ngPluralize: He, ngRepeat: Ie, ngShow: Je, ngStyle: Ke, ngSwitch: Le, ngSwitchWhen: Me, ngSwitchDefault: Ne, ngOptions: Oe, ngTransclude: Pe, ngModel: Qe, ngList: Re, ngChange: Se, pattern: Ec, ngPattern: Ec, required: Fc, ngRequired: Fc, minlength: Gc, ngMinlength: Gc, maxlength: Hc, ngMaxlength: Hc, ngValue: Te, ngModelOptions: Ue
            }).directive({ ngInclude: Ve }).directive(tb).directive(Ic); a.provider({
                $anchorScroll: We, $animate: Xe, $animateCss: Ye, $$animateJs: Ze, $$animateQueue: $e,
                $$AnimateRunner: af, $$animateAsyncRun: bf, $browser: cf, $cacheFactory: df, $controller: ef, $document: ff, $exceptionHandler: gf, $filter: Jc, $$forceReflow: hf, $interpolate: jf, $interval: kf, $http: lf, $httpParamSerializer: mf, $httpParamSerializerJQLike: nf, $httpBackend: of, $xhrFactory: pf, $location: qf, $log: rf, $parse: sf, $rootScope: tf, $q: uf, $$q: vf, $sce: wf, $sceDelegate: xf, $sniffer: yf, $templateCache: zf, $templateRequest: Af, $$testability: Bf, $timeout: Cf, $window: Df, $$rAF: Ef, $$jqLite: Ff, $$HashMap: Gf, $$cookieReader: Hf
            })
        }])
    } function cb(a) {
        return a.replace(If,
        function (a, d, c, e) { return e ? c.toUpperCase() : c }).replace(Jf, "Moz$1")
    } function Kc(a) { a = a.nodeType; return 1 === a || !a || 9 === a } function Lc(a, b) {
        var d, c, e = b.createDocumentFragment(), f = []; if (Tb.test(a)) { d = d || e.appendChild(b.createElement("div")); c = (Kf.exec(a) || ["", ""])[1].toLowerCase(); c = ia[c] || ia._default; d.innerHTML = c[1] + a.replace(Lf, "<$1></$2>") + c[2]; for (c = c[0]; c--;) d = d.lastChild; f = $a(f, d.childNodes); d = e.firstChild; d.textContent = "" } else f.push(b.createTextNode(a)); e.textContent = ""; e.innerHTML = ""; q(f, function (a) { e.appendChild(a) });
        return e
    } function Mc(a, b) { var d = a.parentNode; d && d.replaceChild(b, a); b.appendChild(a) } function U(a) { if (a instanceof U) return a; var b; F(a) && (a = V(a), b = !0); if (!(this instanceof U)) { if (b && "<" != a.charAt(0)) throw Ub("nosel"); return new U(a) } if (b) { b = v.document; var d; a = (d = Mf.exec(a)) ? [b.createElement(d[1])] : (d = Lc(a, b)) ? d.childNodes : [] } Nc(this, a) } function Vb(a) { return a.cloneNode(!0) } function ub(a, b) { b || db(a); if (a.querySelectorAll) for (var d = a.querySelectorAll("*"), c = 0, e = d.length; c < e; c++) db(d[c]) } function Oc(a,
    b, d, c) { if (x(c)) throw Ub("offargs"); var e = (c = vb(a)) && c.events, f = c && c.handle; if (f) if (b) { var g = function (b) { var c = e[b]; x(d) && Za(c || [], d); x(d) && c && 0 < c.length || (a.removeEventListener(b, f, !1), delete e[b]) }; q(b.split(" "), function (a) { g(a); wb[a] && g(wb[a]) }) } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f, !1), delete e[b] } function db(a, b) { var d = a.ng339, c = d && eb[d]; c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), Oc(a)), delete eb[d], a.ng339 = void 0)) } function vb(a, b) {
        var d =
        a.ng339, d = d && eb[d]; b && !d && (a.ng339 = d = ++Nf, d = eb[d] = { events: {}, data: {}, handle: void 0 }); return d
    } function Wb(a, b, d) { if (Kc(a)) { var c = x(d), e = !c && b && !G(b), f = !b; a = (a = vb(a, !e)) && a.data; if (c) a[b] = d; else { if (f) return a; if (e) return a && a[b]; R(a, b) } } } function xb(a, b) { return a.getAttribute ? -1 < (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1 } function yb(a, b) {
        b && a.setAttribute && q(b.split(" "), function (b) {
            a.setAttribute("class", V((" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g,
            " ").replace(" " + V(b) + " ", " ")))
        })
    } function zb(a, b) { if (b && a.setAttribute) { var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "); q(b.split(" "), function (a) { a = V(a); -1 === d.indexOf(" " + a + " ") && (d += a + " ") }); a.setAttribute("class", V(d)) } } function Nc(a, b) { if (b) if (b.nodeType) a[a.length++] = b; else { var d = b.length; if ("number" === typeof d && b.window !== b) { if (d) for (var c = 0; c < d; c++) a[a.length++] = b[c] } else a[a.length++] = b } } function Pc(a, b) { return Ab(a, "$" + (b || "ngController") + "Controller") } function Ab(a,
    b, d) { 9 == a.nodeType && (a = a.documentElement); for (b = K(b) ? b : [b]; a;) { for (var c = 0, e = b.length; c < e; c++) if (x(d = B.data(a, b[c]))) return d; a = a.parentNode || 11 === a.nodeType && a.host } } function Qc(a) { for (ub(a, !0) ; a.firstChild;) a.removeChild(a.firstChild) } function Bb(a, b) { b || ub(a); var d = a.parentNode; d && d.removeChild(a) } function Of(a, b) { b = b || v; if ("complete" === b.document.readyState) b.setTimeout(a); else B(b).on("load", a) } function Rc(a, b) { var d = Cb[b.toLowerCase()]; return d && Sc[va(a)] && d } function Pf(a, b) {
        var d = function (c,
        d) { c.isDefaultPrevented = function () { return c.defaultPrevented }; var f = b[d || c.type], g = f ? f.length : 0; if (g) { if (y(c.immediatePropagationStopped)) { var h = c.stopImmediatePropagation; c.stopImmediatePropagation = function () { c.immediatePropagationStopped = !0; c.stopPropagation && c.stopPropagation(); h && h.call(c) } } c.isImmediatePropagationStopped = function () { return !0 === c.immediatePropagationStopped }; var k = f.specialHandlerWrapper || Qf; 1 < g && (f = ha(f)); for (var l = 0; l < g; l++) c.isImmediatePropagationStopped() || k(a, c, f[l]) } }; d.elem =
        a; return d
    } function Qf(a, b, d) { d.call(a, b) } function Rf(a, b, d) { var c = b.relatedTarget; c && (c === a || Sf.call(a, c)) || d.call(a, b) } function Ff() { this.$get = function () { return R(U, { hasClass: function (a, b) { a.attr && (a = a[0]); return xb(a, b) }, addClass: function (a, b) { a.attr && (a = a[0]); return zb(a, b) }, removeClass: function (a, b) { a.attr && (a = a[0]); return yb(a, b) } }) } } function Fa(a, b) {
        var d = a && a.$$hashKey; if (d) return "function" === typeof d && (d = a.$$hashKey()), d; d = typeof a; return d = "function" == d || "object" == d && null !== a ? a.$$hashKey =
        d + ":" + (b || Xd)() : d + ":" + a
    } function Ra(a, b) { if (b) { var d = 0; this.nextUid = function () { return ++d } } q(a, this.put, this) } function Tc(a) { a = Function.prototype.toString.call(a).replace(Tf, ""); return a.match(Uf) || a.match(Vf) } function Wf(a) { return (a = Tc(a)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn" } function bb(a, b) {
        function d(a) { return function (b, c) { if (G(b)) q(b, qc(a)); else return a(b, c) } } function c(a, b) {
            Qa(a, "service"); if (E(b) || K(b)) b = r.instantiate(b); if (!b.$get) throw Ga("pget", a); return m[a + "Provider"] =
            b
        } function e(a, b) { return function () { var c = w.invoke(b, this); if (y(c)) throw Ga("undef", a); return c } } function f(a, b, d) { return c(a, { $get: !1 !== d ? e(a, b) : b }) } function g(a) {
            qb(y(a) || K(a), "modulesToLoad", "not an array"); var b = [], c; q(a, function (a) {
                function d(a) { var b, c; b = 0; for (c = a.length; b < c; b++) { var e = a[b], f = r.get(e[0]); f[e[1]].apply(f, e[2]) } } if (!n.get(a)) {
                    n.put(a, !0); try {
                        F(a) ? (c = Sb(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), d(c._configBlocks)) : E(a) ? b.push(r.invoke(a)) : K(a) ? b.push(r.invoke(a)) :
                        Pa(a, "module")
                    } catch (e) { throw K(a) && (a = a[a.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), Ga("modulerr", a, e.stack || e.message || e); }
                }
            }); return b
        } function h(a, c) {
            function d(b, e) { if (a.hasOwnProperty(b)) { if (a[b] === k) throw Ga("cdep", b + " <- " + l.join(" <- ")); return a[b] } try { return l.unshift(b), a[b] = k, a[b] = c(b, e) } catch (f) { throw a[b] === k && delete a[b], f; } finally { l.shift() } } function e(a, c, f) {
                var g = []; a = bb.$$annotate(a, b, f); for (var h = 0, k = a.length; h < k; h++) {
                    var l = a[h];
                    if ("string" !== typeof l) throw Ga("itkn", l); g.push(c && c.hasOwnProperty(l) ? c[l] : d(l, f))
                } return g
            } return {
                invoke: function (a, b, c, d) { "string" === typeof c && (d = c, c = null); c = e(a, c, d); K(a) && (a = a[a.length - 1]); d = 11 >= Ca ? !1 : "function" === typeof a && /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(a)); return d ? (c.unshift(null), new (Function.prototype.bind.apply(a, c))) : a.apply(b, c) }, instantiate: function (a, b, c) {
                    var d = K(a) ? a[a.length - 1] : a; a = e(a, b, c); a.unshift(null); return new (Function.prototype.bind.apply(d,
                    a))
                }, get: d, annotate: bb.$$annotate, has: function (b) { return m.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b) }
            }
        } b = !0 === b; var k = {}, l = [], n = new Ra([], !0), m = {
            $provide: {
                provider: d(c), factory: d(f), service: d(function (a, b) { return f(a, ["$injector", function (a) { return a.instantiate(b) }]) }), value: d(function (a, b) { return f(a, da(b), !1) }), constant: d(function (a, b) { Qa(a, "constant"); m[a] = b; N[a] = b }), decorator: function (a, b) {
                    var c = r.get(a + "Provider"), d = c.$get; c.$get = function () {
                        var a = w.invoke(d, c); return w.invoke(b, null,
                        { $delegate: a })
                    }
                }
            }
        }, r = m.$injector = h(m, function (a, b) { ea.isString(b) && l.push(b); throw Ga("unpr", l.join(" <- ")); }), N = {}, M = h(N, function (a, b) { var c = r.get(a + "Provider", b); return w.invoke(c.$get, c, void 0, a) }), w = M; m.$injectorProvider = { $get: da(M) }; var p = g(a), w = M.get("$injector"); w.strictDi = b; q(p, function (a) { a && w.invoke(a) }); return w
    } function We() {
        var a = !0; this.disableAutoScrolling = function () { a = !1 }; this.$get = ["$window", "$location", "$rootScope", function (b, d, c) {
            function e(a) {
                var b = null; Array.prototype.some.call(a,
                function (a) { if ("a" === va(a)) return b = a, !0 }); return b
            } function f(a) { if (a) { a.scrollIntoView(); var c; c = g.yOffset; E(c) ? c = c() : Ob(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Q(c) || (c = 0); c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c)) } else b.scrollTo(0, 0) } function g(a) { a = F(a) ? a : d.hash(); var b; a ? (b = h.getElementById(a)) ? f(b) : (b = e(h.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null) } var h = b.document; a && c.$watch(function () { return d.hash() }, function (a, b) {
                a ===
                b && "" === a || Of(function () { c.$evalAsync(g) })
            }); return g
        }]
    } function fb(a, b) { if (!a && !b) return ""; if (!a) return b; if (!b) return a; K(a) && (a = a.join(" ")); K(b) && (b = b.join(" ")); return a + " " + b } function Xf(a) { F(a) && (a = a.split(" ")); var b = T(); q(a, function (a) { a.length && (b[a] = !0) }); return b } function Ha(a) { return G(a) ? a : {} } function Yf(a, b, d, c) {
        function e(a) { try { a.apply(null, za.call(arguments, 1)) } finally { if (M--, 0 === M) for (; w.length;) try { w.pop()() } catch (b) { d.error(b) } } } function f() { u = null; g(); h() } function g() {
            p = I();
            p = y(p) ? null : p; pa(p, L) && (p = L); L = p
        } function h() { if (t !== k.url() || H !== p) t = k.url(), H = p, q(J, function (a) { a(k.url(), p) }) } var k = this, l = a.location, n = a.history, m = a.setTimeout, r = a.clearTimeout, N = {}; k.isMock = !1; var M = 0, w = []; k.$$completeOutstandingRequest = e; k.$$incOutstandingRequestCount = function () { M++ }; k.notifyWhenNoOutstandingRequests = function (a) { 0 === M ? a() : w.push(a) }; var p, H, t = l.href, z = b.find("base"), u = null, I = c.history ? function () { try { return n.state } catch (a) { } } : C; g(); H = p; k.url = function (b, d, e) {
            y(e) && (e = null); l !==
            a.location && (l = a.location); n !== a.history && (n = a.history); if (b) { var f = H === e; if (t === b && (!c.history || f)) return k; var h = t && Ia(t) === Ia(b); t = b; H = e; if (!c.history || h && f) { if (!h || u) u = b; d ? l.replace(b) : h ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), d.hash = e) : l.href = b; l.href !== b && (u = b) } else n[d ? "replaceState" : "pushState"](e, "", b), g(), H = p; return k } return u || l.href.replace(/%27/g, "'")
        }; k.state = function () { return p }; var J = [], D = !1, L = null; k.onUrlChange = function (b) {
            if (!D) {
                if (c.history) B(a).on("popstate", f); B(a).on("hashchange",
                f); D = !0
            } J.push(b); return b
        }; k.$$applicationDestroyed = function () { B(a).off("hashchange popstate", f) }; k.$$checkUrlChange = h; k.baseHref = function () { var a = z.attr("href"); return a ? a.replace(/^(https?\:)?\/\/[^\/]*/, "") : "" }; k.defer = function (a, b) { var c; M++; c = m(function () { delete N[c]; e(a) }, b || 0); N[c] = !0; return c }; k.defer.cancel = function (a) { return N[a] ? (delete N[a], r(a), e(C), !0) : !1 }
    } function cf() { this.$get = ["$window", "$log", "$sniffer", "$document", function (a, b, d, c) { return new Yf(a, c, b, d) }] } function df() {
        this.$get =
        function () {
            function a(a, c) {
                function e(a) { a != m && (r ? r == a && (r = a.n) : r = a, f(a.n, a.p), f(a, m), m = a, m.n = null) } function f(a, b) { a != b && (a && (a.p = b), b && (b.n = a)) } if (a in b) throw O("$cacheFactory")("iid", a); var g = 0, h = R({}, c, { id: a }), k = T(), l = c && c.capacity || Number.MAX_VALUE, n = T(), m = null, r = null; return b[a] = {
                    put: function (a, b) { if (!y(b)) { if (l < Number.MAX_VALUE) { var c = n[a] || (n[a] = { key: a }); e(c) } a in k || g++; k[a] = b; g > l && this.remove(r.key); return b } }, get: function (a) { if (l < Number.MAX_VALUE) { var b = n[a]; if (!b) return; e(b) } return k[a] },
                    remove: function (a) { if (l < Number.MAX_VALUE) { var b = n[a]; if (!b) return; b == m && (m = b.p); b == r && (r = b.n); f(b.n, b.p); delete n[a] } a in k && (delete k[a], g--) }, removeAll: function () { k = T(); g = 0; n = T(); m = r = null }, destroy: function () { n = h = k = null; delete b[a] }, info: function () { return R({}, h, { size: g }) }
                }
            } var b = {}; a.info = function () { var a = {}; q(b, function (b, e) { a[e] = b.info() }); return a }; a.get = function (a) { return b[a] }; return a
        }
    } function zf() { this.$get = ["$cacheFactory", function (a) { return a("templates") }] } function Cc(a, b) {
        function d(a,
        b, c) { var d = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/, e = T(); q(a, function (a, f) { if (a in n) e[f] = n[a]; else { var g = a.match(d); if (!g) throw ga("iscp", b, f, a, c ? "controller bindings definition" : "isolate scope definition"); e[f] = { mode: g[1][0], collection: "*" === g[2], optional: "?" === g[3], attrName: g[4] || f }; g[4] && (n[a] = e[f]) } }); return e } function c(a) { var b = a.charAt(0); if (!b || b !== P(b)) throw ga("baddir", a); if (a !== a.trim()) throw ga("baddir", a); } var e = {}, f = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, g = /(([\w\-]+)(?:\:([^;]+))?;?)/,
        h = ae("ngSrc,ngSrcset,src,srcset"), k = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, l = /^(on[a-z]+|formaction)$/, n = T(); this.directive = function M(b, d) {
            Qa(b, "directive"); F(b) ? (c(b), qb(d, "directiveFactory"), e.hasOwnProperty(b) || (e[b] = [], a.factory(b + "Directive", ["$injector", "$exceptionHandler", function (a, c) {
                var d = []; q(e[b], function (e, f) {
                    try {
                        var g = a.invoke(e); E(g) ? g = { compile: da(g) } : !g.compile && g.link && (g.compile = da(g.link)); g.priority = g.priority || 0; g.index = f; g.name = g.name || b; g.require = g.require || g.controller && g.name; g.restrict =
                        g.restrict || "EA"; g.$$moduleName = e.$$moduleName; d.push(g)
                    } catch (h) { c(h) }
                }); return d
            }])), e[b].push(d)) : q(b, qc(M)); return this
        }; this.component = function (a, b) {
            function c(a) {
                function e(b) { return E(b) || K(b) ? function (c, d) { return a.invoke(b, this, { $element: c, $attrs: d }) } : b } var f = b.template || b.templateUrl ? b.template : "", g = {
                    controller: d, controllerAs: Uc(b.controller) || b.controllerAs || "$ctrl", template: e(f), templateUrl: e(b.templateUrl), transclude: b.transclude, scope: {}, bindToController: b.bindings || {}, restrict: "E",
                    require: b.require
                }; q(b, function (a, b) { "$" === b.charAt(0) && (g[b] = a) }); return g
            } var d = b.controller || function () { }; q(b, function (a, b) { "$" === b.charAt(0) && (c[b] = a, E(d) && (d[b] = a)) }); c.$inject = ["$injector"]; return this.directive(a, c)
        }; this.aHrefSanitizationWhitelist = function (a) { return x(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist() }; this.imgSrcSanitizationWhitelist = function (a) { return x(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist() }; var m = !0; this.debugInfoEnabled =
        function (a) { return x(a) ? (m = a, this) : m }; var r = 10; this.onChangesTtl = function (a) { return arguments.length ? (r = a, this) : r }; this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function (a, b, c, n, t, z, u, I, J, D) {
            function L() { try { if (!--qa) throw Z = void 0, ga("infchng", r); u.$apply(function () { for (var a = 0, b = Z.length; a < b; ++a) Z[a](); Z = void 0 }) } finally { qa++ } } function S(a, b) {
                if (b) {
                    var c = Object.keys(b), d, e, f; d = 0; for (e = c.length; d <
                    e; d++) f = c[d], this[f] = b[f]
                } else this.$attr = {}; this.$$element = a
            } function $(a, b, c) { na.innerHTML = "<span " + b + ">"; b = na.firstChild.attributes; var d = b[0]; b.removeNamedItem(d.name); d.value = c; a.attributes.setNamedItem(d) } function A(a, b) { try { a.addClass(b) } catch (c) { } } function ba(a, b, c, d, e) {
                a instanceof B || (a = B(a)); for (var f = /\S+/, g = 0, h = a.length; g < h; g++) { var k = a[g]; k.nodeType === Ma && k.nodeValue.match(f) && Mc(k, a[g] = v.document.createElement("span")) } var l = s(a, b, a, c, d, e); ba.$$addScopeClass(a); var m = null; return function (b,
                c, d) { qb(b, "scope"); e && e.needsNewScope && (b = b.$parent.$new()); d = d || {}; var f = d.parentBoundTranscludeFn, g = d.transcludeControllers; d = d.futureParentElement; f && f.$$boundTransclude && (f = f.$$boundTransclude); m || (m = (d = d && d[0]) ? "foreignobject" !== va(d) && ma.call(d).match(/SVG/) ? "svg" : "html" : "html"); d = "html" !== m ? B(ca(m, B("<div>").append(a).html())) : c ? Oa.clone.call(a) : a; if (g) for (var h in g) d.data("$" + h + "Controller", g[h].instance); ba.$$addScopeInfo(d, b); c && c(d, b); l && l(b, d, d, f); return d }
            } function s(a, b, c, d, e, f) {
                function g(a,
                c, d, e) { var f, k, l, m, n, t, p; if (r) for (p = Array(c.length), m = 0; m < h.length; m += 3) f = h[m], p[f] = c[f]; else p = c; m = 0; for (n = h.length; m < n;) k = p[h[m++]], c = h[m++], f = h[m++], c ? (c.scope ? (l = a.$new(), ba.$$addScopeInfo(B(k), l)) : l = a, t = c.transcludeOnThisElement ? ka(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? ka(a, b) : null, c(f, l, k, d, t)) : f && f(a, k.childNodes, void 0, e) } for (var h = [], k, l, m, n, r, t = 0; t < a.length; t++) {
                    k = new S; l = x(a[t], [], k, 0 === t ? d : void 0, e); (f = l.length ? Ba(l, a[t], k, b, c, null, [], [], f) : null) && f.scope && ba.$$addScopeClass(k.$$element);
                    k = f && f.terminal || !(m = a[t].childNodes) || !m.length ? null : s(m, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b); if (f || k) h.push(t, f, k), n = !0, r = r || f; f = null
                } return n ? g : null
            } function ka(a, b, c) { function d(e, f, g, h, k) { e || (e = a.$new(!1, k), e.$$transcluded = !0); return b(e, f, { parentBoundTranscludeFn: c, transcludeControllers: g, futureParentElement: h }) } var e = d.$$slots = T(), f; for (f in b.$$slots) e[f] = b.$$slots[f] ? ka(a, b.$$slots[f], c) : null; return d } function x(a, b, c, d, e) {
                var h = c.$attr, k; switch (a.nodeType) {
                    case 1: la(b,
                    xa(va(a)), "E", d, e); for (var l, m, n, t = a.attributes, r = 0, p = t && t.length; r < p; r++) { var I = !1, D = !1; l = t[r]; k = l.name; m = V(l.value); l = xa(k); if (n = ya.test(l)) k = k.replace(Vc, "").substr(8).replace(/_(.)/g, function (a, b) { return b.toUpperCase() }); (l = l.match(Aa)) && Q(l[1]) && (I = k, D = k.substr(0, k.length - 5) + "end", k = k.substr(0, k.length - 6)); l = xa(k.toLowerCase()); h[l] = k; if (n || !c.hasOwnProperty(l)) c[l] = m, Rc(a, l) && (c[l] = !0); fa(a, b, m, l, n); la(b, l, "A", d, e, I, D) } a = a.className; G(a) && (a = a.animVal); if (F(a) && "" !== a) for (; k = g.exec(a) ;) l = xa(k[2]),
                    la(b, l, "C", d, e) && (c[l] = V(k[3])), a = a.substr(k.index + k[0].length); break; case Ma: if (11 === Ca) for (; a.parentNode && a.nextSibling && a.nextSibling.nodeType === Ma;) a.nodeValue += a.nextSibling.nodeValue, a.parentNode.removeChild(a.nextSibling); X(b, a.nodeValue); break; case 8: try { if (k = f.exec(a.nodeValue)) l = xa(k[1]), la(b, l, "M", d, e) && (c[l] = V(k[2])) } catch (J) { }
                } b.sort(Y); return b
            } function Wc(a, b, c) {
                var d = [], e = 0; if (b && a.hasAttribute && a.hasAttribute(b)) {
                    do {
                        if (!a) throw ga("uterdir", b, c); 1 == a.nodeType && (a.hasAttribute(b) &&
                        e++, a.hasAttribute(c) && e--); d.push(a); a = a.nextSibling
                    } while (0 < e)
                } else d.push(a); return B(d)
            } function Xc(a, b, c) { return function (d, e, f, g, h) { e = Wc(e[0], b, c); return a(d, e, f, g, h) } } function Yb(a, b, c, d, e, f) { var g; return a ? ba(b, c, d, e, f) : function () { g || (g = ba(b, c, d, e, f), b = c = f = null); return g.apply(this, arguments) } } function Ba(a, b, d, e, f, g, h, k, l) {
                function m(a, b, c, d) {
                    if (a) { c && (a = Xc(a, c, d)); a.require = A.require; a.directiveName = M; if (D === A || A.$$isolateScope) a = ha(a, { isolateScope: !0 }); h.push(a) } if (b) {
                        c && (b = Xc(b, c, d));
                        b.require = A.require; b.directiveName = M; if (D === A || A.$$isolateScope) b = ha(b, { isolateScope: !0 }); k.push(b)
                    }
                } function n(a, c, e, f, g) {
                    function l(a, b, c, d) { var e; Ya(a) || (d = c, c = b, b = a, a = void 0); H && (e = u); c || (c = H ? z.parent() : z); if (d) { var f = g.$$slots[d]; if (f) return f(a, b, e, c, $); if (y(f)) throw ga("noslot", d, wa(z)); } else return g(a, b, e, c, $) } var m, t, p, A, w, u, L, z; b === e ? (f = d, z = d.$$element) : (z = B(e), f = new S(z, d)); w = c; D ? A = c.$new(!0) : r && (w = c.$parent); g && (L = l, L.$$boundTransclude = g, L.isSlotFilled = function (a) { return !!g.$$slots[a] });
                    I && (u = O(z, f, L, I, A, c, D)); D && (ba.$$addScopeInfo(z, A, !0, !(J && (J === D || J === D.$$originalDirective))), ba.$$addScopeClass(z, !0), A.$$isolateBindings = D.$$isolateBindings, t = ia(c, f, A, A.$$isolateBindings, D), t.removeWatches && A.$on("$destroy", t.removeWatches)); for (m in u) {
                        t = I[m]; p = u[m]; var Xb = t.$$bindings.bindToController; p.bindingInfo = p.identifier && Xb ? ia(w, f, p.instance, Xb, t) : {}; var M = p(); M !== p.instance && (p.instance = M, z.data("$" + t.name + "Controller", M), p.bindingInfo.removeWatches && p.bindingInfo.removeWatches(), p.bindingInfo =
                        ia(w, f, p.instance, Xb, t))
                    } q(I, function (a, b) { var c = a.require; a.bindToController && !K(c) && G(c) && R(u[b].instance, gb(b, c, z, u)) }); q(u, function (a) { var b = a.instance; E(b.$onChanges) && b.$onChanges(a.bindingInfo.initialChanges); E(b.$onInit) && b.$onInit(); E(b.$onDestroy) && w.$on("$destroy", function () { b.$onDestroy() }) }); m = 0; for (t = h.length; m < t; m++) p = h[m], ja(p, p.isolateScope ? A : c, z, f, p.require && gb(p.directiveName, p.require, z, u), L); var $ = c; D && (D.template || null === D.templateUrl) && ($ = A); a && a($, e.childNodes, void 0, g); for (m =
                    k.length - 1; 0 <= m; m--) p = k[m], ja(p, p.isolateScope ? A : c, z, f, p.require && gb(p.directiveName, p.require, z, u), L); q(u, function (a) { a = a.instance; E(a.$postLink) && a.$postLink() })
                } l = l || {}; for (var t = -Number.MAX_VALUE, r = l.newScopeDirective, I = l.controllerDirectives, D = l.newIsolateScopeDirective, J = l.templateDirective, w = l.nonTlbTranscludeDirective, u = !1, L = !1, H = l.hasElementTranscludeDirective, z = d.$$element = B(b), A, M, $, s = e, Sa, ka = !1, C = !1, v, F = 0, Ba = a.length; F < Ba; F++) {
                    A = a[F]; var P = A.$$start, Q = A.$$end; P && (z = Wc(b, P, Q)); $ = void 0;
                    if (t > A.priority) break; if (v = A.scope) A.templateUrl || (G(v) ? (W("new/isolated scope", D || r, A, z), D = A) : W("new/isolated scope", D, A, z)), r = r || A; M = A.name; if (!ka && (A.replace && (A.templateUrl || A.template) || A.transclude && !A.$$tlb)) { for (v = F + 1; ka = a[v++];) if (ka.transclude && !ka.$$tlb || ka.replace && (ka.templateUrl || ka.template)) { C = !0; break } ka = !0 } !A.templateUrl && A.controller && (v = A.controller, I = I || T(), W("'" + M + "' controller", I[M], A, z), I[M] = A); if (v = A.transclude) if (u = !0, A.$$tlb || (W("transclusion", w, A, z), w = A), "element" == v) H =
                    !0, t = A.priority, $ = z, z = d.$$element = B(ba.$$createComment(M, d[M])), b = z[0], da(f, za.call($, 0), b), $[0].$$parentNode = $[0].parentNode, s = Yb(C, $, e, t, g && g.name, { nonTlbTranscludeDirective: w }); else {
                        var la = T(); $ = B(Vb(b)).contents(); if (G(v)) {
                            $ = []; var Y = T(), X = T(); q(v, function (a, b) { var c = "?" === a.charAt(0); a = c ? a.substring(1) : a; Y[a] = b; la[b] = null; X[b] = c }); q(z.contents(), function (a) { var b = Y[xa(va(a))]; b ? (X[b] = !0, la[b] = la[b] || [], la[b].push(a)) : $.push(a) }); q(X, function (a, b) { if (!a) throw ga("reqslot", b); }); for (var Z in la) la[Z] &&
                            (la[Z] = Yb(C, la[Z], e))
                        } z.empty(); s = Yb(C, $, e, void 0, void 0, { needsNewScope: A.$$isolateScope || A.$$newScope }); s.$$slots = la
                    } if (A.template) if (L = !0, W("template", J, A, z), J = A, v = E(A.template) ? A.template(z, d) : A.template, v = ta(v), A.replace) { g = A; $ = Tb.test(v) ? Yc(ca(A.templateNamespace, V(v))) : []; b = $[0]; if (1 != $.length || 1 !== b.nodeType) throw ga("tplrt", M, ""); da(f, z, b); Ba = { $attr: {} }; v = x(b, [], Ba); var ea = a.splice(F + 1, a.length - (F + 1)); (D || r) && Zc(v, D, r); a = a.concat(v).concat(ea); U(d, Ba); Ba = a.length } else z.html(v); if (A.templateUrl) L =
                    !0, W("template", J, A, z), J = A, A.replace && (g = A), n = aa(a.splice(F, a.length - F), z, d, f, u && s, h, k, { controllerDirectives: I, newScopeDirective: r !== A && r, newIsolateScopeDirective: D, templateDirective: J, nonTlbTranscludeDirective: w }), Ba = a.length; else if (A.compile) try { Sa = A.compile(z, d, s), E(Sa) ? m(null, Sa, P, Q) : Sa && m(Sa.pre, Sa.post, P, Q) } catch (fa) { c(fa, wa(z)) } A.terminal && (n.terminal = !0, t = Math.max(t, A.priority))
                } n.scope = r && !0 === r.scope; n.transcludeOnThisElement = u; n.templateOnThisElement = L; n.transclude = s; l.hasElementTranscludeDirective =
                H; return n
            } function gb(a, b, c, d) { var e; if (F(b)) { var f = b.match(k); b = b.substring(f[0].length); var g = f[1] || f[3], f = "?" === f[2]; "^^" === g ? c = c.parent() : e = (e = d && d[b]) && e.instance; if (!e) { var h = "$" + b + "Controller"; e = g ? c.inheritedData(h) : c.data(h) } if (!e && !f) throw ga("ctreq", b, a); } else if (K(b)) for (e = [], g = 0, f = b.length; g < f; g++) e[g] = gb(a, b[g], c, d); else G(b) && (e = {}, q(b, function (b, f) { e[f] = gb(a, b, c, d) })); return e || null } function O(a, b, c, d, e, f, g) {
                var h = T(), k; for (k in d) {
                    var l = d[k], m = {
                        $scope: l === g || l.$$isolateScope ? e : f,
                        $element: a, $attrs: b, $transclude: c
                    }, n = l.controller; "@" == n && (n = b[l.name]); m = z(n, m, !0, l.controllerAs); h[l.name] = m; a.data("$" + l.name + "Controller", m.instance)
                } return h
            } function Zc(a, b, c) { for (var d = 0, e = a.length; d < e; d++) a[d] = Pb(a[d], { $$isolateScope: b, $$newScope: c }) } function la(b, f, g, h, k, l, m) {
                if (f === k) return null; k = null; if (e.hasOwnProperty(f)) {
                    var n; f = a.get(f + "Directive"); for (var t = 0, r = f.length; t < r; t++) try {
                        if (n = f[t], (y(h) || h > n.priority) && -1 != n.restrict.indexOf(g)) {
                            l && (n = Pb(n, { $$start: l, $$end: m })); if (!n.$$bindings) {
                                var I =
                                n, D = n, A = n.name, J = { isolateScope: null, bindToController: null }; G(D.scope) && (!0 === D.bindToController ? (J.bindToController = d(D.scope, A, !0), J.isolateScope = {}) : J.isolateScope = d(D.scope, A, !1)); G(D.bindToController) && (J.bindToController = d(D.bindToController, A, !0)); if (G(J.bindToController)) { var w = D.controller, z = D.controllerAs; if (!w) throw ga("noctrl", A); if (!Uc(w, z)) throw ga("noident", A); } var u = I.$$bindings = J; G(u.isolateScope) && (n.$$isolateBindings = u.isolateScope)
                            } b.push(n); k = n
                        }
                    } catch (L) { c(L) }
                } return k
            } function Q(b) {
                if (e.hasOwnProperty(b)) for (var c =
                a.get(b + "Directive"), d = 0, f = c.length; d < f; d++) if (b = c[d], b.multiElement) return !0; return !1
            } function U(a, b) { var c = b.$attr, d = a.$attr, e = a.$$element; q(a, function (d, e) { "$" != e.charAt(0) && (b[e] && b[e] !== d && (d += ("style" === e ? ";" : " ") + b[e]), a.$set(e, d, !0, c[e])) }); q(b, function (b, f) { "class" == f ? (A(e, b), a["class"] = (a["class"] ? a["class"] + " " : "") + b) : "style" == f ? (e.attr("style", e.attr("style") + ";" + b), a.style = (a.style ? a.style + ";" : "") + b) : "$" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, d[f] = c[f]) }) } function aa(a, b, c, d, e, f,
            g, h) {
                var k = [], l, m, t = b[0], p = a.shift(), r = Pb(p, { templateUrl: null, transclude: null, replace: null, $$originalDirective: p }), I = E(p.templateUrl) ? p.templateUrl(b, c) : p.templateUrl, D = p.templateNamespace; b.empty(); n(I).then(function (n) {
                    var J, w; n = ta(n); if (p.replace) { n = Tb.test(n) ? Yc(ca(D, V(n))) : []; J = n[0]; if (1 != n.length || 1 !== J.nodeType) throw ga("tplrt", p.name, I); n = { $attr: {} }; da(d, b, J); var z = x(J, [], n); G(p.scope) && Zc(z, !0); a = z.concat(a); U(c, n) } else J = t, b.html(n); a.unshift(r); l = Ba(a, J, c, e, b, p, f, g, h); q(d, function (a, c) {
                        a ==
                        J && (d[c] = b[0])
                    }); for (m = s(b[0].childNodes, e) ; k.length;) { n = k.shift(); w = k.shift(); var u = k.shift(), L = k.shift(), z = b[0]; if (!n.$$destroyed) { if (w !== t) { var S = w.className; h.hasElementTranscludeDirective && p.replace || (z = Vb(J)); da(u, B(w), z); A(B(z), S) } w = l.transcludeOnThisElement ? ka(n, l.transclude, L) : L; l(m, n, z, d, w) } } k = null
                }); return function (a, b, c, d, e) { a = e; b.$$destroyed || (k ? k.push(b, c, d, a) : (l.transcludeOnThisElement && (a = ka(b, l.transclude, e)), l(m, b, c, d, a))) }
            } function Y(a, b) {
                var c = b.priority - a.priority; return 0 !==
                c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
            } function W(a, b, c, d) { function e(a) { return a ? " (module: " + a + ")" : "" } if (b) throw ga("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, wa(d)); } function X(a, c) { var d = b(c, !0); d && a.push({ priority: 0, compile: function (a) { a = a.parent(); var b = !!a.length; b && ba.$$addBindingClass(a); return function (a, c) { var e = c.parent(); b || ba.$$addBindingClass(e); ba.$$addBindingInfo(e, d.expressions); a.$watch(d, function (a) { c[0].nodeValue = a }) } } }) } function ca(a, b) {
                a =
                P(a || "html"); switch (a) { case "svg": case "math": var c = v.document.createElement("div"); c.innerHTML = "<" + a + ">" + b + "</" + a + ">"; return c.childNodes[0].childNodes; default: return b }
            } function ea(a, b) { if ("srcdoc" == b) return I.HTML; var c = va(a); if ("xlinkHref" == b || "form" == c && "action" == b || "img" != c && ("src" == b || "ngSrc" == b)) return I.RESOURCE_URL } function fa(a, c, d, e, f) {
                var g = ea(a, e); f = h[e] || f; var k = b(d, !0, g, f); if (k) {
                    if ("multiple" === e && "select" === va(a)) throw ga("selmulti", wa(a)); c.push({
                        priority: 100, compile: function () {
                            return {
                                pre: function (a,
                                c, h) { c = h.$$observers || (h.$$observers = T()); if (l.test(e)) throw ga("nodomevents"); var m = h[e]; m !== d && (k = m && b(m, !0, g, f), d = m); k && (h[e] = k(a), (c[e] || (c[e] = [])).$$inter = !0, (h.$$observers && h.$$observers[e].$$scope || a).$watch(k, function (a, b) { "class" === e && a != b ? h.$updateClass(a, b) : h.$set(e, a) })) }
                            }
                        }
                    })
                }
            } function da(a, b, c) {
                var d = b[0], e = b.length, f = d.parentNode, g, h; if (a) for (g = 0, h = a.length; g < h; g++) if (a[g] == d) {
                    a[g++] = c; h = g + e - 1; for (var k = a.length; g < k; g++, h++) h < k ? a[g] = a[h] : delete a[g]; a.length -= e - 1; a.context === d && (a.context =
                    c); break
                } f && f.replaceChild(c, d); a = v.document.createDocumentFragment(); for (g = 0; g < e; g++) a.appendChild(b[g]); B.hasData(d) && (B.data(c, B.data(d)), B(d).off("$destroy")); B.cleanData(a.querySelectorAll("*")); for (g = 1; g < e; g++) delete b[g]; b[0] = c; b.length = 1
            } function ha(a, b) { return R(function () { return a.apply(null, arguments) }, a, b) } function ja(a, b, d, e, f, g) { try { a(b, d, e, f, g) } catch (h) { c(h, wa(d)) } } function ia(a, c, d, e, f) {
                function g(b, c, e) {
                    E(d.$onChanges) && c !== e && (Z || (a.$$postDigest(L), Z = []), m || (m = {}, Z.push(h)), m[b] &&
                    (e = m[b].previousValue), m[b] = new Db(e, c))
                } function h() { d.$onChanges(m); m = void 0 } var k = [], l = {}, m; q(e, function (e, h) {
                    var m = e.attrName, n = e.optional, p, r, I, D; switch (e.mode) {
                        case "@": n || ua.call(c, m) || (d[h] = c[m] = void 0); c.$observe(m, function (a) { if (F(a) || Da(a)) g(h, a, d[h]), d[h] = a }); c.$$observers[m].$$scope = a; p = c[m]; F(p) ? d[h] = b(p)(a) : Da(p) && (d[h] = p); l[h] = new Db(Zb, d[h]); break; case "=": if (!ua.call(c, m)) { if (n) break; c[m] = void 0 } if (n && !c[m]) break; r = t(c[m]); D = r.literal ? pa : function (a, b) { return a === b || a !== a && b !== b };
                            I = r.assign || function () { p = d[h] = r(a); throw ga("nonassign", c[m], m, f.name); }; p = d[h] = r(a); n = function (b) { D(b, d[h]) || (D(b, p) ? I(a, b = d[h]) : d[h] = b); return p = b }; n.$stateful = !0; n = e.collection ? a.$watchCollection(c[m], n) : a.$watch(t(c[m], n), null, r.literal); k.push(n); break; case "<": if (!ua.call(c, m)) { if (n) break; c[m] = void 0 } if (n && !c[m]) break; r = t(c[m]); d[h] = r(a); l[h] = new Db(Zb, d[h]); n = a.$watch(r, function (a, b) { a === b && (b = d[h]); g(h, a, b); d[h] = a }, r.literal); k.push(n); break; case "&": r = c.hasOwnProperty(m) ? t(c[m]) : C; if (r ===
                            C && n) break; d[h] = function (b) { return r(a, b) }
                    }
                }); return { initialChanges: l, removeWatches: k.length && function () { for (var a = 0, b = k.length; a < b; ++a) k[a]() } }
            } var oa = /^\w/, na = v.document.createElement("div"), qa = r, Z; S.prototype = {
                $normalize: xa, $addClass: function (a) { a && 0 < a.length && J.addClass(this.$$element, a) }, $removeClass: function (a) { a && 0 < a.length && J.removeClass(this.$$element, a) }, $updateClass: function (a, b) {
                    var c = $c(a, b); c && c.length && J.addClass(this.$$element, c); (c = $c(b, a)) && c.length && J.removeClass(this.$$element,
                    c)
                }, $set: function (a, b, d, e) {
                    var f = Rc(this.$$element[0], a), g = ad[a], h = a; f ? (this.$$element.prop(a, b), e = f) : g && (this[g] = b, h = g); this[a] = b; e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = zc(a, "-")); f = va(this.$$element); if ("a" === f && ("href" === a || "xlinkHref" === a) || "img" === f && "src" === a) this[a] = b = D(b, "src" === a); else if ("img" === f && "srcset" === a) {
                        for (var f = "", g = V(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(g) ? k : /(,)/, g = g.split(k), k = Math.floor(g.length / 2), l = 0; l < k; l++) var m = 2 * l, f = f + D(V(g[m]), !0), f =
                        f + (" " + V(g[m + 1])); g = V(g[2 * l]).split(/\s/); f += D(V(g[0]), !0); 2 === g.length && (f += " " + V(g[1])); this[a] = b = f
                    } !1 !== d && (null === b || y(b) ? this.$$element.removeAttr(e) : oa.test(e) ? this.$$element.attr(e, b) : $(this.$$element[0], e, b)); (a = this.$$observers) && q(a[h], function (a) { try { a(b) } catch (d) { c(d) } })
                }, $observe: function (a, b) { var c = this, d = c.$$observers || (c.$$observers = T()), e = d[a] || (d[a] = []); e.push(b); u.$evalAsync(function () { e.$$inter || !c.hasOwnProperty(a) || y(c[a]) || b(c[a]) }); return function () { Za(e, b) } }
            }; var ra = b.startSymbol(),
            sa = b.endSymbol(), ta = "{{" == ra && "}}" == sa ? Xa : function (a) { return a.replace(/\{\{/g, ra).replace(/}}/g, sa) }, ya = /^ngAttr[A-Z]/, Aa = /^(.+)Start$/; ba.$$addBindingInfo = m ? function (a, b) { var c = a.data("$binding") || []; K(b) ? c = c.concat(b) : c.push(b); a.data("$binding", c) } : C; ba.$$addBindingClass = m ? function (a) { A(a, "ng-binding") } : C; ba.$$addScopeInfo = m ? function (a, b, c, d) { a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b) } : C; ba.$$addScopeClass = m ? function (a, b) { A(a, b ? "ng-isolate-scope" : "ng-scope") } : C; ba.$$createComment =
            function (a, b) { var c = ""; m && (c = " " + (a || "") + ": " + (b || "") + " "); return v.document.createComment(c) }; return ba
        }]
    } function Db(a, b) { this.previousValue = a; this.currentValue = b } function xa(a) { return cb(a.replace(Vc, "")) } function $c(a, b) { var d = "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0; a: for (; f < c.length; f++) { for (var g = c[f], h = 0; h < e.length; h++) if (g == e[h]) continue a; d += (0 < d.length ? " " : "") + g } return d } function Yc(a) { a = B(a); var b = a.length; if (1 >= b) return a; for (; b--;) 8 === a[b].nodeType && Zf.call(a, b, 1); return a } function Uc(a,
    b) { if (b && F(b)) return b; if (F(a)) { var d = bd.exec(a); if (d) return d[3] } } function ef() {
        var a = {}, b = !1; this.has = function (b) { return a.hasOwnProperty(b) }; this.register = function (b, c) { Qa(b, "controller"); G(b) ? R(a, b) : a[b] = c }; this.allowGlobals = function () { b = !0 }; this.$get = ["$injector", "$window", function (d, c) {
            function e(a, b, c, d) { if (!a || !G(a.$scope)) throw O("$controller")("noscp", d, b); a.$scope[b] = c } return function (f, g, h, k) {
                var l, n, m; h = !0 === h; k && F(k) && (m = k); if (F(f)) {
                    k = f.match(bd); if (!k) throw $f("ctrlfmt", f); n = k[1]; m =
                    m || k[3]; f = a.hasOwnProperty(n) ? a[n] : Bc(g.$scope, n, !0) || (b ? Bc(c, n, !0) : void 0); Pa(f, n, !0)
                } if (h) return h = (K(f) ? f[f.length - 1] : f).prototype, l = Object.create(h || null), m && e(g, m, l, n || f.name), R(function () { var a = d.invoke(f, l, g, n); a !== l && (G(a) || E(a)) && (l = a, m && e(g, m, l, n || f.name)); return l }, { instance: l, identifier: m }); l = d.instantiate(f, g, n); m && e(g, m, l, n || f.name); return l
            }
        }]
    } function ff() { this.$get = ["$window", function (a) { return B(a.document) }] } function gf() {
        this.$get = ["$log", function (a) {
            return function (b, d) {
                a.error.apply(a,
                arguments)
            }
        }]
    } function $b(a) { return G(a) ? fa(a) ? a.toISOString() : ab(a) : a } function mf() { this.$get = function () { return function (a) { if (!a) return ""; var b = []; pc(a, function (a, c) { null === a || y(a) || (K(a) ? q(a, function (a) { b.push(ja(c) + "=" + ja($b(a))) }) : b.push(ja(c) + "=" + ja($b(a)))) }); return b.join("&") } } } function nf() {
        this.$get = function () {
            return function (a) {
                function b(a, e, f) {
                    null === a || y(a) || (K(a) ? q(a, function (a, c) { b(a, e + "[" + (G(a) ? c : "") + "]") }) : G(a) && !fa(a) ? pc(a, function (a, c) { b(a, e + (f ? "" : "[") + c + (f ? "" : "]")) }) : d.push(ja(e) +
                    "=" + ja($b(a))))
                } if (!a) return ""; var d = []; b(a, "", !0); return d.join("&")
            }
        }
    } function ac(a, b) { if (F(a)) { var d = a.replace(ag, "").trim(); if (d) { var c = b("Content-Type"); (c = c && 0 === c.indexOf(cd)) || (c = (c = d.match(bg)) && cg[c[0]].test(d)); c && (a = uc(d)) } } return a } function dd(a) { var b = T(), d; F(a) ? q(a.split("\n"), function (a) { d = a.indexOf(":"); var e = P(V(a.substr(0, d))); a = V(a.substr(d + 1)); e && (b[e] = b[e] ? b[e] + ", " + a : a) }) : G(a) && q(a, function (a, d) { var f = P(d), g = V(a); f && (b[f] = b[f] ? b[f] + ", " + g : g) }); return b } function ed(a) {
        var b;
        return function (d) { b || (b = dd(a)); return d ? (d = b[P(d)], void 0 === d && (d = null), d) : b }
    } function fd(a, b, d, c) { if (E(c)) return c(a, b, d); q(c, function (c) { a = c(a, b, d) }); return a } function lf() {
        var a = this.defaults = {
            transformResponse: [ac], transformRequest: [function (a) { return G(a) && "[object File]" !== ma.call(a) && "[object Blob]" !== ma.call(a) && "[object FormData]" !== ma.call(a) ? ab(a) : a }], headers: { common: { Accept: "application/json, text/plain, */*" }, post: ha(bc), put: ha(bc), patch: ha(bc) }, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, b = !1; this.useApplyAsync = function (a) { return x(a) ? (b = !!a, this) : b }; var d = !0; this.useLegacyPromiseExtensions = function (a) { return x(a) ? (d = !!a, this) : d }; var c = this.interceptors = []; this.$get = ["$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function (e, f, g, h, k, l) {
            function n(b) {
                function c(a) { var b = R({}, a); b.data = fd(a.data, a.headers, a.status, f.transformResponse); a = a.status; return 200 <= a && 300 > a ? b : k.reject(b) } function e(a, b) {
                    var c, d = {}; q(a, function (a,
                    e) { E(a) ? (c = a(b), null != c && (d[e] = c)) : d[e] = a }); return d
                } if (!G(b)) throw O("$http")("badreq", b); if (!F(b.url)) throw O("$http")("badreq", b.url); var f = R({ method: "get", transformRequest: a.transformRequest, transformResponse: a.transformResponse, paramSerializer: a.paramSerializer }, b); f.headers = function (b) { var c = a.headers, d = R({}, b.headers), f, g, h, c = R({}, c.common, c[P(b.method)]); a: for (f in c) { g = P(f); for (h in d) if (P(h) === g) continue a; d[f] = c[f] } return e(d, ha(b)) }(b); f.method = sb(f.method); f.paramSerializer = F(f.paramSerializer) ?
                l.get(f.paramSerializer) : f.paramSerializer; var g = [function (b) { var d = b.headers, e = fd(b.data, ed(d), void 0, b.transformRequest); y(e) && q(d, function (a, b) { "content-type" === P(b) && delete d[b] }); y(b.withCredentials) && !y(a.withCredentials) && (b.withCredentials = a.withCredentials); return m(b, e).then(c, c) }, void 0], h = k.when(f); for (q(M, function (a) { (a.request || a.requestError) && g.unshift(a.request, a.requestError); (a.response || a.responseError) && g.push(a.response, a.responseError) }) ; g.length;) {
                    b = g.shift(); var n = g.shift(),
                    h = h.then(b, n)
                } d ? (h.success = function (a) { Pa(a, "fn"); h.then(function (b) { a(b.data, b.status, b.headers, f) }); return h }, h.error = function (a) { Pa(a, "fn"); h.then(null, function (b) { a(b.data, b.status, b.headers, f) }); return h }) : (h.success = gd("success"), h.error = gd("error")); return h
            } function m(c, d) {
                function g(a) { if (a) { var c = {}; q(a, function (a, d) { c[d] = function (c) { function d() { a(c) } b ? h.$applyAsync(d) : h.$$phase ? d() : h.$apply(d) } }); return c } } function l(a, c, d, e) {
                    function f() { m(c, a, d, e) } L && (200 <= a && 300 > a ? L.put(A, [a, c, dd(d),
                    e]) : L.remove(A)); b ? h.$applyAsync(f) : (f(), h.$$phase || h.$apply())
                } function m(a, b, d, e) { b = -1 <= b ? b : 0; (200 <= b && 300 > b ? J.resolve : J.reject)({ data: a, status: b, headers: ed(d), config: c, statusText: e }) } function u(a) { m(a.data, a.status, ha(a.headers()), a.statusText) } function I() { var a = n.pendingRequests.indexOf(c); -1 !== a && n.pendingRequests.splice(a, 1) } var J = k.defer(), D = J.promise, L, S, M = c.headers, A = r(c.url, c.paramSerializer(c.params)); n.pendingRequests.push(c); D.then(I, I); !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method &&
                "JSONP" !== c.method || (L = G(c.cache) ? c.cache : G(a.cache) ? a.cache : N); L && (S = L.get(A), x(S) ? S && E(S.then) ? S.then(u, u) : K(S) ? m(S[1], S[0], ha(S[2]), S[3]) : m(S, 200, {}, "OK") : L.put(A, D)); y(S) && ((S = hd(c.url) ? f()[c.xsrfCookieName || a.xsrfCookieName] : void 0) && (M[c.xsrfHeaderName || a.xsrfHeaderName] = S), e(c.method, A, d, l, M, c.timeout, c.withCredentials, c.responseType, g(c.eventHandlers), g(c.uploadEventHandlers))); return D
            } function r(a, b) { 0 < b.length && (a += (-1 == a.indexOf("?") ? "?" : "&") + b); return a } var N = g("$http"); a.paramSerializer =
            F(a.paramSerializer) ? l.get(a.paramSerializer) : a.paramSerializer; var M = []; q(c, function (a) { M.unshift(F(a) ? l.get(a) : l.invoke(a)) }); n.pendingRequests = []; (function (a) { q(arguments, function (a) { n[a] = function (b, c) { return n(R({}, c || {}, { method: a, url: b })) } }) })("get", "delete", "head", "jsonp"); (function (a) { q(arguments, function (a) { n[a] = function (b, c, d) { return n(R({}, d || {}, { method: a, url: b, data: c })) } }) })("post", "put", "patch"); n.defaults = a; return n
        }]
    } function pf() { this.$get = function () { return function () { return new v.XMLHttpRequest } } }
    function of() { this.$get = ["$browser", "$window", "$document", "$xhrFactory", function (a, b, d, c) { return dg(a, c, a.defer, b.angular.callbacks, d[0]) }] } function dg(a, b, d, c, e) {
        function f(a, b, d) {
            var f = e.createElement("script"), n = null; f.type = "text/javascript"; f.src = a; f.async = !0; n = function (a) { f.removeEventListener("load", n, !1); f.removeEventListener("error", n, !1); e.body.removeChild(f); f = null; var g = -1, N = "unknown"; a && ("load" !== a.type || c[b].called || (a = { type: "error" }), N = a.type, g = "error" === a.type ? 404 : 200); d && d(g, N) }; f.addEventListener("load",
            n, !1); f.addEventListener("error", n, !1); e.body.appendChild(f); return n
        } return function (e, h, k, l, n, m, r, N, M, w) {
            function p() { z && z(); u && u.abort() } function H(b, c, e, f, g) { x(J) && d.cancel(J); z = u = null; b(c, e, f, g); a.$$completeOutstandingRequest(C) } a.$$incOutstandingRequestCount(); h = h || a.url(); if ("jsonp" == P(e)) { var t = "_" + (c.counter++).toString(36); c[t] = function (a) { c[t].data = a; c[t].called = !0 }; var z = f(h.replace("JSON_CALLBACK", "angular.callbacks." + t), t, function (a, b) { H(l, a, c[t].data, "", b); c[t] = C }) } else {
                var u = b(e, h);
                u.open(e, h, !0); q(n, function (a, b) { x(a) && u.setRequestHeader(b, a) }); u.onload = function () { var a = u.statusText || "", b = "response" in u ? u.response : u.responseText, c = 1223 === u.status ? 204 : u.status; 0 === c && (c = b ? 200 : "file" == ra(h).protocol ? 404 : 0); H(l, c, b, u.getAllResponseHeaders(), a) }; e = function () { H(l, -1, null, null, "") }; u.onerror = e; u.onabort = e; q(M, function (a, b) { u.addEventListener(b, a) }); q(w, function (a, b) { u.upload.addEventListener(b, a) }); r && (u.withCredentials = !0); if (N) try { u.responseType = N } catch (I) {
                    if ("json" !== N) throw I;
                } u.send(y(k) ? null : k)
            } if (0 < m) var J = d(p, m); else m && E(m.then) && m.then(p)
        }
    } function jf() {
        var a = "{{", b = "}}"; this.startSymbol = function (b) { return b ? (a = b, this) : a }; this.endSymbol = function (a) { return a ? (b = a, this) : b }; this.$get = ["$parse", "$exceptionHandler", "$sce", function (d, c, e) {
            function f(a) { return "\\\\\\" + a } function g(c) { return c.replace(m, a).replace(r, b) } function h(a, b, c, d) { var e; return e = a.$watch(function (a) { e(); return d(a) }, b, c) } function k(f, k, m, r) {
                function H(a) {
                    try {
                        var b = a; a = m ? e.getTrusted(m, b) : e.valueOf(b);
                        var d; if (r && !x(a)) d = a; else if (null == a) d = ""; else { switch (typeof a) { case "string": break; case "number": a = "" + a; break; default: a = ab(a) } d = a } return d
                    } catch (g) { c(Ja.interr(f, g)) }
                } if (!f.length || -1 === f.indexOf(a)) { var t; k || (k = g(f), t = da(k), t.exp = f, t.expressions = [], t.$$watchDelegate = h); return t } r = !!r; var z, u, I = 0, J = [], D = []; t = f.length; for (var L = [], S = []; I < t;) if (-1 != (z = f.indexOf(a, I)) && -1 != (u = f.indexOf(b, z + l))) I !== z && L.push(g(f.substring(I, z))), I = f.substring(z + l, u), J.push(I), D.push(d(I, H)), I = u + n, S.push(L.length), L.push("");
                else { I !== t && L.push(g(f.substring(I))); break } m && 1 < L.length && Ja.throwNoconcat(f); if (!k || J.length) { var q = function (a) { for (var b = 0, c = J.length; b < c; b++) { if (r && y(a[b])) return; L[S[b]] = a[b] } return L.join("") }; return R(function (a) { var b = 0, d = J.length, e = Array(d); try { for (; b < d; b++) e[b] = D[b](a); return q(e) } catch (g) { c(Ja.interr(f, g)) } }, { exp: f, expressions: J, $$watchDelegate: function (a, b) { var c; return a.$watchGroup(D, function (d, e) { var f = q(d); E(b) && b.call(this, f, d !== e ? c : f, a); c = f }) } }) }
            } var l = a.length, n = b.length, m = new RegExp(a.replace(/./g,
            f), "g"), r = new RegExp(b.replace(/./g, f), "g"); k.startSymbol = function () { return a }; k.endSymbol = function () { return b }; return k
        }]
    } function kf() {
        this.$get = ["$rootScope", "$window", "$q", "$$q", "$browser", function (a, b, d, c, e) {
            function f(f, k, l, n) {
                function m() { r ? f.apply(null, N) : f(p) } var r = 4 < arguments.length, N = r ? za.call(arguments, 4) : [], q = b.setInterval, w = b.clearInterval, p = 0, H = x(n) && !n, t = (H ? c : d).defer(), z = t.promise; l = x(l) ? l : 0; z.$$intervalId = q(function () {
                    H ? e.defer(m) : a.$evalAsync(m); t.notify(p++); 0 < l && p >= l && (t.resolve(p),
                    w(z.$$intervalId), delete g[z.$$intervalId]); H || a.$apply()
                }, k); g[z.$$intervalId] = t; return z
            } var g = {}; f.cancel = function (a) { return a && a.$$intervalId in g ? (g[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), delete g[a.$$intervalId], !0) : !1 }; return f
        }]
    } function cc(a) { a = a.split("/"); for (var b = a.length; b--;) a[b] = ob(a[b]); return a.join("/") } function id(a, b) { var d = ra(a); b.$$protocol = d.protocol; b.$$host = d.hostname; b.$$port = X(d.port) || eg[d.protocol] || null } function jd(a, b) {
        var d = "/" !== a.charAt(0);
        d && (a = "/" + a); var c = ra(a); b.$$path = decodeURIComponent(d && "/" === c.pathname.charAt(0) ? c.pathname.substring(1) : c.pathname); b.$$search = xc(c.search); b.$$hash = decodeURIComponent(c.hash); b.$$path && "/" != b.$$path.charAt(0) && (b.$$path = "/" + b.$$path)
    } function na(a, b) { if (0 === b.indexOf(a)) return b.substr(a.length) } function Ia(a) { var b = a.indexOf("#"); return -1 == b ? a : a.substr(0, b) } function hb(a) { return a.replace(/(#.+)|#$/, "$1") } function dc(a, b, d) {
        this.$$html5 = !0; d = d || ""; id(a, this); this.$$parse = function (a) {
            var d = na(b,
            a); if (!F(d)) throw Eb("ipthprfx", a, b); jd(d, this); this.$$path || (this.$$path = "/"); this.$$compose()
        }; this.$$compose = function () { var a = Rb(this.$$search), d = this.$$hash ? "#" + ob(this.$$hash) : ""; this.$$url = cc(this.$$path) + (a ? "?" + a : "") + d; this.$$absUrl = b + this.$$url.substr(1) }; this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; x(f = na(a, c)) ? (g = f, g = x(f = na(d, f)) ? b + (na("/", f) || f) : a + g) : x(f = na(b, c)) ? g = b + f : b == c + "/" && (g = b); g && this.$$parse(g); return !!g }
    } function ec(a, b, d) {
        id(a, this);
        this.$$parse = function (c) { var e = na(a, c) || na(b, c), f; y(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", y(e) && (a = c, this.replace())) : (f = na(d, e), y(f) && (f = e)); jd(f, this); c = this.$$path; var e = a, g = /^\/[A-Z]:(\/.*)/; 0 === f.indexOf(e) && (f = f.replace(e, "")); g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c); this.$$path = c; this.$$compose() }; this.$$compose = function () { var b = Rb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : ""; this.$$url = cc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + (this.$$url ? d + this.$$url : "") }; this.$$parseLinkUrl =
        function (b, d) { return Ia(a) == Ia(b) ? (this.$$parse(b), !0) : !1 }
    } function kd(a, b, d) { this.$$html5 = !0; ec.apply(this, arguments); this.$$parseLinkUrl = function (c, e) { if (e && "#" === e[0]) return this.hash(e.slice(1)), !0; var f, g; a == Ia(c) ? f = c : (g = na(b, c)) ? f = a + d + g : b === c + "/" && (f = b); f && this.$$parse(f); return !!f }; this.$$compose = function () { var b = Rb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : ""; this.$$url = cc(this.$$path) + (b ? "?" + b : "") + e; this.$$absUrl = a + d + this.$$url } } function Fb(a) { return function () { return this[a] } } function ld(a,
    b) { return function (d) { if (y(d)) return this[a]; this[a] = b(d); this.$$compose(); return this } } function qf() {
        var a = "", b = { enabled: !1, requireBase: !0, rewriteLinks: !0 }; this.hashPrefix = function (b) { return x(b) ? (a = b, this) : a }; this.html5Mode = function (a) { return Da(a) ? (b.enabled = a, this) : G(a) ? (Da(a.enabled) && (b.enabled = a.enabled), Da(a.requireBase) && (b.requireBase = a.requireBase), Da(a.rewriteLinks) && (b.rewriteLinks = a.rewriteLinks), this) : b }; this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function (d,
        c, e, f, g) {
            function h(a, b, d) { var e = l.url(), f = l.$$state; try { c.url(a, b, d), l.$$state = c.state() } catch (g) { throw l.url(e), l.$$state = f, g; } } function k(a, b) { d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b) } var l, n; n = c.baseHref(); var m = c.url(), r; if (b.enabled) { if (!n && b.requireBase) throw Eb("nobase"); r = m.substring(0, m.indexOf("/", m.indexOf("//") + 2)) + (n || "/"); n = e.history ? dc : kd } else r = Ia(m), n = ec; var N = r.substr(0, Ia(r).lastIndexOf("/") + 1); l = new n(r, N, "#" + a); l.$$parseLinkUrl(m, m); l.$$state = c.state();
            var q = /^\s*(javascript|mailto):/i; f.on("click", function (a) {
                if (b.rewriteLinks && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 != a.which && 2 != a.button) {
                    for (var e = B(a.target) ; "a" !== va(e[0]) ;) if (e[0] === f[0] || !(e = e.parent())[0]) return; var h = e.prop("href"), k = e.attr("href") || e.attr("xlink:href"); G(h) && "[object SVGAnimatedString]" === h.toString() && (h = ra(h.animVal).href); q.test(h) || !h || e.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(h, k) || (a.preventDefault(), l.absUrl() != c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] =
                    !0))
                }
            }); hb(l.absUrl()) != hb(m) && c.url(l.absUrl(), !0); var w = !0; c.onUrlChange(function (a, b) { y(na(N, a)) ? g.location.href = a : (d.$evalAsync(function () { var c = l.absUrl(), e = l.$$state, f; a = hb(a); l.$$parse(a); l.$$state = b; f = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented; l.absUrl() === a && (f ? (l.$$parse(c), l.$$state = e, h(c, !1, e)) : (w = !1, k(c, e))) }), d.$$phase || d.$digest()) }); d.$watch(function () {
                var a = hb(c.url()), b = hb(l.absUrl()), f = c.state(), g = l.$$replace, m = a !== b || l.$$html5 && e.history && f !== l.$$state; if (w ||
                m) w = !1, d.$evalAsync(function () { var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, f).defaultPrevented; l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = f) : (m && h(b, g, f === l.$$state ? null : l.$$state), k(a, f))) }); l.$$replace = !1
            }); return l
        }]
    } function rf() {
        var a = !0, b = this; this.debugEnabled = function (b) { return x(b) ? (a = b, this) : a }; this.$get = ["$window", function (d) {
            function c(a) {
                a instanceof Error && (a.stack ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL &&
                (a = a.message + "\n" + a.sourceURL + ":" + a.line)); return a
            } function e(a) { var b = d.console || {}, e = b[a] || b.log || C; a = !1; try { a = !!e.apply } catch (k) { } return a ? function () { var a = []; q(arguments, function (b) { a.push(c(b)) }); return e.apply(b, a) } : function (a, b) { e(a, null == b ? "" : b) } } return { log: e("log"), info: e("info"), warn: e("warn"), error: e("error"), debug: function () { var c = e("debug"); return function () { a && c.apply(b, arguments) } }() }
        }]
    } function Ta(a, b) {
        if ("__defineGetter__" === a || "__defineSetter__" === a || "__lookupGetter__" === a || "__lookupSetter__" ===
        a || "__proto__" === a) throw ca("isecfld", b); return a
    } function fg(a) { return a + "" } function sa(a, b) { if (a) { if (a.constructor === a) throw ca("isecfn", b); if (a.window === a) throw ca("isecwindow", b); if (a.children && (a.nodeName || a.prop && a.attr && a.find)) throw ca("isecdom", b); if (a === Object) throw ca("isecobj", b); } return a } function md(a, b) { if (a) { if (a.constructor === a) throw ca("isecfn", b); if (a === gg || a === hg || a === ig) throw ca("isecff", b); } } function Gb(a, b) {
        if (a && (a === (0).constructor || a === (!1).constructor || a === "".constructor ||
        a === {}.constructor || a === [].constructor || a === Function.constructor)) throw ca("isecaf", b);
    } function jg(a, b) { return "undefined" !== typeof a ? a : b } function nd(a, b) { return "undefined" === typeof a ? b : "undefined" === typeof b ? a : a + b } function aa(a, b) {
        var d, c; switch (a.type) {
            case s.Program: d = !0; q(a.body, function (a) { aa(a.expression, b); d = d && a.expression.constant }); a.constant = d; break; case s.Literal: a.constant = !0; a.toWatch = []; break; case s.UnaryExpression: aa(a.argument, b); a.constant = a.argument.constant; a.toWatch = a.argument.toWatch;
                break; case s.BinaryExpression: aa(a.left, b); aa(a.right, b); a.constant = a.left.constant && a.right.constant; a.toWatch = a.left.toWatch.concat(a.right.toWatch); break; case s.LogicalExpression: aa(a.left, b); aa(a.right, b); a.constant = a.left.constant && a.right.constant; a.toWatch = a.constant ? [] : [a]; break; case s.ConditionalExpression: aa(a.test, b); aa(a.alternate, b); aa(a.consequent, b); a.constant = a.test.constant && a.alternate.constant && a.consequent.constant; a.toWatch = a.constant ? [] : [a]; break; case s.Identifier: a.constant =
                !1; a.toWatch = [a]; break; case s.MemberExpression: aa(a.object, b); a.computed && aa(a.property, b); a.constant = a.object.constant && (!a.computed || a.property.constant); a.toWatch = [a]; break; case s.CallExpression: d = a.filter ? !b(a.callee.name).$stateful : !1; c = []; q(a.arguments, function (a) { aa(a, b); d = d && a.constant; a.constant || c.push.apply(c, a.toWatch) }); a.constant = d; a.toWatch = a.filter && !b(a.callee.name).$stateful ? c : [a]; break; case s.AssignmentExpression: aa(a.left, b); aa(a.right, b); a.constant = a.left.constant && a.right.constant;
                    a.toWatch = [a]; break; case s.ArrayExpression: d = !0; c = []; q(a.elements, function (a) { aa(a, b); d = d && a.constant; a.constant || c.push.apply(c, a.toWatch) }); a.constant = d; a.toWatch = c; break; case s.ObjectExpression: d = !0; c = []; q(a.properties, function (a) { aa(a.value, b); d = d && a.value.constant; a.value.constant || c.push.apply(c, a.value.toWatch) }); a.constant = d; a.toWatch = c; break; case s.ThisExpression: a.constant = !1; a.toWatch = []; break; case s.LocalsExpression: a.constant = !1, a.toWatch = []
        }
    } function od(a) {
        if (1 == a.length) {
            a = a[0].expression;
            var b = a.toWatch; return 1 !== b.length ? b : b[0] !== a ? b : void 0
        }
    } function pd(a) { return a.type === s.Identifier || a.type === s.MemberExpression } function qd(a) { if (1 === a.body.length && pd(a.body[0].expression)) return { type: s.AssignmentExpression, left: a.body[0].expression, right: { type: s.NGValueParameter }, operator: "=" } } function rd(a) { return 0 === a.body.length || 1 === a.body.length && (a.body[0].expression.type === s.Literal || a.body[0].expression.type === s.ArrayExpression || a.body[0].expression.type === s.ObjectExpression) } function sd(a,
    b) { this.astBuilder = a; this.$filter = b } function td(a, b) { this.astBuilder = a; this.$filter = b } function Hb(a) { return "constructor" == a } function fc(a) { return E(a.valueOf) ? a.valueOf() : kg.call(a) } function sf() {
        var a = T(), b = T(), d = { "true": !0, "false": !1, "null": null, undefined: void 0 }, c, e; this.addLiteral = function (a, b) { d[a] = b }; this.setIdentifierFns = function (a, b) { c = a; e = b; return this }; this.$get = ["$filter", function (f) {
            function g(c, d, e) {
                var g, k, D; e = e || H; switch (typeof c) {
                    case "string": D = c = c.trim(); var q = e ? b : a; g = q[D]; if (!g) {
                        ":" ===
                        c.charAt(0) && ":" === c.charAt(1) && (k = !0, c = c.substring(2)); g = e ? p : w; var S = new gc(g); g = (new hc(S, f, g)).parse(c); g.constant ? g.$$watchDelegate = r : k ? g.$$watchDelegate = g.literal ? m : n : g.inputs && (g.$$watchDelegate = l); e && (g = h(g)); q[D] = g
                    } return N(g, d); case "function": return N(c, d); default: return N(C, d)
                }
            } function h(a) {
                function b(c, d, e, f) { var g = H; H = !0; try { return a(c, d, e, f) } finally { H = g } } if (!a) return a; b.$$watchDelegate = a.$$watchDelegate; b.assign = h(a.assign); b.constant = a.constant; b.literal = a.literal; for (var c = 0; a.inputs &&
                c < a.inputs.length; ++c) a.inputs[c] = h(a.inputs[c]); b.inputs = a.inputs; return b
            } function k(a, b) { return null == a || null == b ? a === b : "object" === typeof a && (a = fc(a), "object" === typeof a) ? !1 : a === b || a !== a && b !== b } function l(a, b, c, d, e) {
                var f = d.inputs, g; if (1 === f.length) { var h = k, f = f[0]; return a.$watch(function (a) { var b = f(a); k(b, h) || (g = d(a, void 0, void 0, [b]), h = b && fc(b)); return g }, b, c, e) } for (var l = [], m = [], n = 0, r = f.length; n < r; n++) l[n] = k, m[n] = null; return a.$watch(function (a) {
                    for (var b = !1, c = 0, e = f.length; c < e; c++) {
                        var h = f[c](a);
                        if (b || (b = !k(h, l[c]))) m[c] = h, l[c] = h && fc(h)
                    } b && (g = d(a, void 0, void 0, m)); return g
                }, b, c, e)
            } function n(a, b, c, d) { var e, f; return e = a.$watch(function (a) { return d(a) }, function (a, c, d) { f = a; E(b) && b.apply(this, arguments); x(a) && d.$$postDigest(function () { x(f) && e() }) }, c) } function m(a, b, c, d) { function e(a) { var b = !0; q(a, function (a) { x(a) || (b = !1) }); return b } var f, g; return f = a.$watch(function (a) { return d(a) }, function (a, c, d) { g = a; E(b) && b.call(this, a, c, d); e(a) && d.$$postDigest(function () { e(g) && f() }) }, c) } function r(a, b, c, d) {
                var e;
                return e = a.$watch(function (a) { e(); return d(a) }, b, c)
            } function N(a, b) { if (!b) return a; var c = a.$$watchDelegate, d = !1, c = c !== m && c !== n ? function (c, e, f, g) { f = d && g ? g[0] : a(c, e, f, g); return b(f, c, e) } : function (c, d, e, f) { e = a(c, d, e, f); c = b(e, c, d); return x(e) ? c : e }; a.$$watchDelegate && a.$$watchDelegate !== l ? c.$$watchDelegate = a.$$watchDelegate : b.$stateful || (c.$$watchDelegate = l, d = !a.inputs, c.inputs = a.inputs ? a.inputs : [a]); return c } var M = Ea().noUnsafeEval, w = {
                csp: M, expensiveChecks: !1, literals: qa(d), isIdentifierStart: E(c) && c,
                isIdentifierContinue: E(e) && e
            }, p = { csp: M, expensiveChecks: !0, literals: qa(d), isIdentifierStart: E(c) && c, isIdentifierContinue: E(e) && e }, H = !1; g.$$runningExpensiveChecks = function () { return H }; return g
        }]
    } function uf() { this.$get = ["$rootScope", "$exceptionHandler", function (a, b) { return ud(function (b) { a.$evalAsync(b) }, b) }] } function vf() { this.$get = ["$browser", "$exceptionHandler", function (a, b) { return ud(function (b) { a.defer(b) }, b) }] } function ud(a, b) {
        function d() { this.$$state = { status: 0 } } function c(a, b) {
            return function (c) {
                b.call(a,
                c)
            }
        } function e(c) { !c.processScheduled && c.pending && (c.processScheduled = !0, a(function () { var a, d, e; e = c.pending; c.processScheduled = !1; c.pending = void 0; for (var f = 0, g = e.length; f < g; ++f) { d = e[f][0]; a = e[f][c.status]; try { E(a) ? d.resolve(a(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value) } catch (h) { d.reject(h), b(h) } } })) } function f() { this.promise = new d } var g = O("$q", TypeError); R(d.prototype, {
            then: function (a, b, c) {
                if (y(a) && y(b) && y(c)) return this; var d = new f; this.$$state.pending = this.$$state.pending || []; this.$$state.pending.push([d,
                a, b, c]); 0 < this.$$state.status && e(this.$$state); return d.promise
            }, "catch": function (a) { return this.then(null, a) }, "finally": function (a, b) { return this.then(function (b) { return k(b, !0, a) }, function (b) { return k(b, !1, a) }, b) }
        }); R(f.prototype, {
            resolve: function (a) { this.promise.$$state.status || (a === this.promise ? this.$$reject(g("qcycle", a)) : this.$$resolve(a)) }, $$resolve: function (a) {
                function d(a) { k || (k = !0, h.$$resolve(a)) } function f(a) { k || (k = !0, h.$$reject(a)) } var g, h = this, k = !1; try {
                    if (G(a) || E(a)) g = a && a.then; E(g) ?
                    (this.promise.$$state.status = -1, g.call(a, d, f, c(this, this.notify))) : (this.promise.$$state.value = a, this.promise.$$state.status = 1, e(this.promise.$$state))
                } catch (l) { f(l), b(l) }
            }, reject: function (a) { this.promise.$$state.status || this.$$reject(a) }, $$reject: function (a) { this.promise.$$state.value = a; this.promise.$$state.status = 2; e(this.promise.$$state) }, notify: function (c) {
                var d = this.promise.$$state.pending; 0 >= this.promise.$$state.status && d && d.length && a(function () {
                    for (var a, e, f = 0, g = d.length; f < g; f++) {
                        e = d[f][0];
                        a = d[f][3]; try { e.notify(E(a) ? a(c) : c) } catch (h) { b(h) }
                    }
                })
            }
        }); var h = function (a, b) { var c = new f; b ? c.resolve(a) : c.reject(a); return c.promise }, k = function (a, b, c) { var d = null; try { E(c) && (d = c()) } catch (e) { return h(e, !1) } return d && E(d.then) ? d.then(function () { return h(a, b) }, function (a) { return h(a, !1) }) : h(a, b) }, l = function (a, b, c, d) { var e = new f; e.resolve(a); return e.promise.then(b, c, d) }, n = function (a) { if (!E(a)) throw g("norslvr", a); var b = new f; a(function (a) { b.resolve(a) }, function (a) { b.reject(a) }); return b.promise }; n.prototype =
        d.prototype; n.defer = function () { var a = new f; a.resolve = c(a, a.resolve); a.reject = c(a, a.reject); a.notify = c(a, a.notify); return a }; n.reject = function (a) { var b = new f; b.reject(a); return b.promise }; n.when = l; n.resolve = l; n.all = function (a) { var b = new f, c = 0, d = K(a) ? [] : {}; q(a, function (a, e) { c++; l(a).then(function (a) { d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d)) }, function (a) { d.hasOwnProperty(e) || b.reject(a) }) }); 0 === c && b.resolve(d); return b.promise }; return n
    } function Ef() {
        this.$get = ["$window", "$timeout", function (a,
        b) { var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function (a) { var b = d(a); return function () { c(b) } } : function (a) { var c = b(a, 16.66, !1); return function () { b.cancel(c) } }; f.supported = e; return f }]
    } function tf() {
        function a(a) {
            function b() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$id = ++nb; this.$$ChildScope =
                null
            } b.prototype = a; return b
        } var b = 10, d = O("$rootScope"), c = null, e = null; this.digestTtl = function (a) { arguments.length && (b = a); return b }; this.$get = ["$exceptionHandler", "$parse", "$browser", function (f, g, h) {
            function k(a) { a.currentScope.$$destroyed = !0 } function l(a) { 9 === Ca && (a.$$childHead && l(a.$$childHead), a.$$nextSibling && l(a.$$nextSibling)); a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null } function n() {
                this.$id = ++nb; this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling =
                this.$$prevSibling = this.$$childHead = this.$$childTail = null; this.$root = this; this.$$destroyed = !1; this.$$listeners = {}; this.$$listenerCount = {}; this.$$watchersCount = 0; this.$$isolateBindings = null
            } function m(a) { if (H.$$phase) throw d("inprog", H.$$phase); H.$$phase = a } function r(a, b) { do a.$$watchersCount += b; while (a = a.$parent) } function N(a, b, c) { do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent) } function s() { } function w() {
                for (; u.length;) try { u.shift()() } catch (a) { f(a) } e =
                null
            } function p() { null === e && (e = h.defer(function () { H.$apply(w) })) } n.prototype = {
                constructor: n, $new: function (b, c) { var d; c = c || this; b ? (d = new n, d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), d = new this.$$ChildScope); d.$parent = c; d.$$prevSibling = c.$$childTail; c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d; (b || c != this) && d.$on("$destroy", k); return d }, $watch: function (a, b, d, e) {
                    var f = g(a); if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f,
                    a); var h = this, k = h.$$watchers, l = { fn: b, last: s, get: f, exp: e || a, eq: !!d }; c = null; E(b) || (l.fn = C); k || (k = h.$$watchers = []); k.unshift(l); r(this, 1); return function () { 0 <= Za(k, l) && r(h, -1); c = null }
                }, $watchGroup: function (a, b) {
                    function c() { h = !1; k ? (k = !1, b(e, e, g)) : b(e, d, g) } var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0; if (!a.length) { var l = !0; g.$evalAsync(function () { l && b(e, e, g) }); return function () { l = !1 } } if (1 === a.length) return this.$watch(a[0], function (a, c, f) { e[0] = a; d[0] = c; b(e, a === c ? e : d, f) }); q(a, function (a,
                    b) { var k = g.$watch(a, function (a, f) { e[b] = a; d[b] = f; h || (h = !0, g.$evalAsync(c)) }); f.push(k) }); return function () { for (; f.length;) f.shift()() }
                }, $watchCollection: function (a, b) {
                    function c(a) {
                        e = a; var b, d, g, h; if (!y(e)) {
                            if (G(e)) if (ya(e)) for (f !== m && (f = m, t = f.length = 0, l++), a = e.length, t !== a && (l++, f.length = t = a), b = 0; b < a; b++) h = f[b], g = e[b], d = h !== h && g !== g, d || h === g || (l++, f[b] = g); else {
                                f !== r && (f = r = {}, t = 0, l++); a = 0; for (b in e) ua.call(e, b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, d || h === g || (l++, f[b] = g)) : (t++, f[b] = g, l++)); if (t >
                                a) for (b in l++, f) ua.call(e, b) || (t--, delete f[b])
                            } else f !== e && (f = e, l++); return l
                        }
                    } c.$stateful = !0; var d = this, e, f, h, k = 1 < b.length, l = 0, n = g(a, c), m = [], r = {}, p = !0, t = 0; return this.$watch(n, function () { p ? (p = !1, b(e, e, d)) : b(e, h, d); if (k) if (G(e)) if (ya(e)) { h = Array(e.length); for (var a = 0; a < e.length; a++) h[a] = e[a] } else for (a in h = {}, e) ua.call(e, a) && (h[a] = e[a]); else h = e })
                }, $digest: function () {
                    var a, g, k, l, n, r, p, q, N = b, u, x = [], y, v; m("$digest"); h.$$checkUrlChange(); this === H && null !== e && (h.defer.cancel(e), w()); c = null; do {
                        q = !1;
                        for (u = this; t.length;) { try { v = t.shift(), v.scope.$eval(v.expression, v.locals) } catch (C) { f(C) } c = null }a: do {
                            if (r = u.$$watchers) for (p = r.length; p--;) try { if (a = r[p]) if (n = a.get, (g = n(u)) !== (k = a.last) && !(a.eq ? pa(g, k) : "number" === typeof g && "number" === typeof k && isNaN(g) && isNaN(k))) q = !0, c = a, a.last = a.eq ? qa(g, null) : g, l = a.fn, l(g, k === s ? g : k, u), 5 > N && (y = 4 - N, x[y] || (x[y] = []), x[y].push({ msg: E(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp, newVal: g, oldVal: k })); else if (a === c) { q = !1; break a } } catch (F) { f(F) } if (!(r = u.$$watchersCount &&
                            u.$$childHead || u !== this && u.$$nextSibling)) for (; u !== this && !(r = u.$$nextSibling) ;) u = u.$parent
                        } while (u = r); if ((q || t.length) && !N--) throw H.$$phase = null, d("infdig", b, x);
                    } while (q || t.length); for (H.$$phase = null; z.length;) try { z.shift()() } catch (B) { f(B) }
                }, $destroy: function () {
                    if (!this.$$destroyed) {
                        var a = this.$parent; this.$broadcast("$destroy"); this.$$destroyed = !0; this === H && h.$$applicationDestroyed(); r(this, -this.$$watchersCount); for (var b in this.$$listenerCount) N(this, this.$$listenerCount[b], b); a && a.$$childHead ==
                        this && (a.$$childHead = this.$$nextSibling); a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling); this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling); this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling); this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = C; this.$on = this.$watch = this.$watchGroup = function () { return C }; this.$$listeners = {}; this.$$nextSibling = null; l(this)
                    }
                }, $eval: function (a, b) { return g(a)(this, b) }, $evalAsync: function (a, b) {
                    H.$$phase ||
                    t.length || h.defer(function () { t.length && H.$digest() }); t.push({ scope: this, expression: g(a), locals: b })
                }, $$postDigest: function (a) { z.push(a) }, $apply: function (a) { try { m("$apply"); try { return this.$eval(a) } finally { H.$$phase = null } } catch (b) { f(b) } finally { try { H.$digest() } catch (c) { throw f(c), c; } } }, $applyAsync: function (a) { function b() { c.$eval(a) } var c = this; a && u.push(b); a = g(a); p() }, $on: function (a, b) {
                    var c = this.$$listeners[a]; c || (this.$$listeners[a] = c = []); c.push(b); var d = this; do d.$$listenerCount[a] || (d.$$listenerCount[a] =
                    0), d.$$listenerCount[a]++; while (d = d.$parent); var e = this; return function () { var d = c.indexOf(b); -1 !== d && (c[d] = null, N(e, 1, a)) }
                }, $emit: function (a, b) {
                    var c = [], d, e = this, g = !1, h = { name: a, targetScope: e, stopPropagation: function () { g = !0 }, preventDefault: function () { h.defaultPrevented = !0 }, defaultPrevented: !1 }, k = $a([h], arguments, 1), l, n; do { d = e.$$listeners[a] || c; h.currentScope = e; l = 0; for (n = d.length; l < n; l++) if (d[l]) try { d[l].apply(null, k) } catch (m) { f(m) } else d.splice(l, 1), l--, n--; if (g) return h.currentScope = null, h; e = e.$parent } while (e);
                    h.currentScope = null; return h
                }, $broadcast: function (a, b) {
                    var c = this, d = this, e = { name: a, targetScope: this, preventDefault: function () { e.defaultPrevented = !0 }, defaultPrevented: !1 }; if (!this.$$listenerCount[a]) return e; for (var g = $a([e], arguments, 1), h, k; c = d;) { e.currentScope = c; d = c.$$listeners[a] || []; h = 0; for (k = d.length; h < k; h++) if (d[h]) try { d[h].apply(null, g) } catch (l) { f(l) } else d.splice(h, 1), h--, k--; if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (; c !== this && !(d = c.$$nextSibling) ;) c = c.$parent } e.currentScope =
                    null; return e
                }
            }; var H = new n, t = H.$$asyncQueue = [], z = H.$$postDigestQueue = [], u = H.$$applyAsyncQueue = []; return H
        }]
    } function me() { var a = /^\s*(https?|ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/; this.aHrefSanitizationWhitelist = function (b) { return x(b) ? (a = b, this) : a }; this.imgSrcSanitizationWhitelist = function (a) { return x(a) ? (b = a, this) : b }; this.$get = function () { return function (d, c) { var e = c ? b : a, f; f = ra(d).href; return "" === f || f.match(e) ? d : "unsafe:" + f } } } function lg(a) {
        if ("self" === a) return a;
        if (F(a)) { if (-1 < a.indexOf("***")) throw ta("iwcard", a); a = vd(a).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"); return new RegExp("^" + a + "$") } if (Wa(a)) return new RegExp("^" + a.source + "$"); throw ta("imatcher");
    } function wd(a) { var b = []; x(a) && q(a, function (a) { b.push(lg(a)) }); return b } function xf() {
        this.SCE_CONTEXTS = oa; var a = ["self"], b = []; this.resourceUrlWhitelist = function (b) { arguments.length && (a = wd(b)); return a }; this.resourceUrlBlacklist = function (a) { arguments.length && (b = wd(a)); return b }; this.$get = ["$injector",
        function (d) {
            function c(a, b) { return "self" === a ? hd(b) : !!a.exec(b.href) } function e(a) { var b = function (a) { this.$$unwrapTrustedValue = function () { return a } }; a && (b.prototype = new a); b.prototype.valueOf = function () { return this.$$unwrapTrustedValue() }; b.prototype.toString = function () { return this.$$unwrapTrustedValue().toString() }; return b } var f = function (a) { throw ta("unsafe"); }; d.has("$sanitize") && (f = d.get("$sanitize")); var g = e(), h = {}; h[oa.HTML] = e(g); h[oa.CSS] = e(g); h[oa.URL] = e(g); h[oa.JS] = e(g); h[oa.RESOURCE_URL] =
            e(h[oa.URL]); return {
                trustAs: function (a, b) { var c = h.hasOwnProperty(a) ? h[a] : null; if (!c) throw ta("icontext", a, b); if (null === b || y(b) || "" === b) return b; if ("string" !== typeof b) throw ta("itype", a); return new c(b) }, getTrusted: function (d, e) {
                    if (null === e || y(e) || "" === e) return e; var g = h.hasOwnProperty(d) ? h[d] : null; if (g && e instanceof g) return e.$$unwrapTrustedValue(); if (d === oa.RESOURCE_URL) {
                        var g = ra(e.toString()), m, r, q = !1; m = 0; for (r = a.length; m < r; m++) if (c(a[m], g)) { q = !0; break } if (q) for (m = 0, r = b.length; m < r; m++) if (c(b[m],
                        g)) { q = !1; break } if (q) return e; throw ta("insecurl", e.toString());
                    } if (d === oa.HTML) return f(e); throw ta("unsafe");
                }, valueOf: function (a) { return a instanceof g ? a.$$unwrapTrustedValue() : a }
            }
        }]
    } function wf() {
        var a = !0; this.enabled = function (b) { arguments.length && (a = !!b); return a }; this.$get = ["$parse", "$sceDelegate", function (b, d) {
            if (a && 8 > Ca) throw ta("iequirks"); var c = ha(oa); c.isEnabled = function () { return a }; c.trustAs = d.trustAs; c.getTrusted = d.getTrusted; c.valueOf = d.valueOf; a || (c.trustAs = c.getTrusted = function (a, b) { return b },
            c.valueOf = Xa); c.parseAs = function (a, d) { var e = b(d); return e.literal && e.constant ? e : b(d, function (b) { return c.getTrusted(a, b) }) }; var e = c.parseAs, f = c.getTrusted, g = c.trustAs; q(oa, function (a, b) { var d = P(b); c[cb("parse_as_" + d)] = function (b) { return e(a, b) }; c[cb("get_trusted_" + d)] = function (b) { return f(a, b) }; c[cb("trust_as_" + d)] = function (b) { return g(a, b) } }); return c
        }]
    } function yf() {
        this.$get = ["$window", "$document", function (a, b) {
            var d = {}, c = !(a.chrome && a.chrome.app && a.chrome.app.runtime) && a.history && a.history.pushState,
            e = X((/android (\d+)/.exec(P((a.navigator || {}).userAgent)) || [])[1]), f = /Boxee/i.test((a.navigator || {}).userAgent), g = b[0] || {}, h, k = /^(Moz|webkit|ms)(?=[A-Z])/, l = g.body && g.body.style, n = !1, m = !1; if (l) { for (var r in l) if (n = k.exec(r)) { h = n[0]; h = h.substr(0, 1).toUpperCase() + h.substr(1); break } h || (h = "WebkitOpacity" in l && "webkit"); n = !!("transition" in l || h + "Transition" in l); m = !!("animation" in l || h + "Animation" in l); !e || n && m || (n = F(l.webkitTransition), m = F(l.webkitAnimation)) } return {
                history: !(!c || 4 > e || f), hasEvent: function (a) {
                    if ("input" ===
                    a && 11 >= Ca) return !1; if (y(d[a])) { var b = g.createElement("div"); d[a] = "on" + a in b } return d[a]
                }, csp: Ea(), vendorPrefix: h, transitions: n, animations: m, android: e
            }
        }]
    } function Af() {
        var a; this.httpOptions = function (b) { return b ? (a = b, this) : a }; this.$get = ["$templateCache", "$http", "$q", "$sce", function (b, d, c, e) {
            function f(g, h) {
                f.totalPendingRequests++; F(g) && b.get(g) || (g = e.getTrustedResourceUrl(g)); var k = d.defaults && d.defaults.transformResponse; K(k) ? k = k.filter(function (a) { return a !== ac }) : k === ac && (k = null); return d.get(g,
                R({ cache: b, transformResponse: k }, a))["finally"](function () { f.totalPendingRequests-- }).then(function (a) { b.put(g, a.data); return a.data }, function (a) { if (!h) throw mg("tpload", g, a.status, a.statusText); return c.reject(a) })
            } f.totalPendingRequests = 0; return f
        }]
    } function Bf() {
        this.$get = ["$rootScope", "$browser", "$location", function (a, b, d) {
            return {
                findBindings: function (a, b, d) {
                    a = a.getElementsByClassName("ng-binding"); var g = []; q(a, function (a) {
                        var c = ea.element(a).data("$binding"); c && q(c, function (c) {
                            d ? (new RegExp("(^|\\s)" +
                            vd(b) + "(\\s|\\||$)")).test(c) && g.push(a) : -1 != c.indexOf(b) && g.push(a)
                        })
                    }); return g
                }, findModels: function (a, b, d) { for (var g = ["ng-", "data-ng-", "ng\\:"], h = 0; h < g.length; ++h) { var k = a.querySelectorAll("[" + g[h] + "model" + (d ? "=" : "*=") + '"' + b + '"]'); if (k.length) return k } }, getLocation: function () { return d.url() }, setLocation: function (b) { b !== d.url() && (d.url(b), a.$digest()) }, whenStable: function (a) { b.notifyWhenNoOutstandingRequests(a) }
            }
        }]
    } function Cf() {
        this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler",
        function (a, b, d, c, e) { function f(f, k, l) { E(f) || (l = k, k = f, f = C); var n = za.call(arguments, 3), m = x(l) && !l, r = (m ? c : d).defer(), q = r.promise, s; s = b.defer(function () { try { r.resolve(f.apply(null, n)) } catch (b) { r.reject(b), e(b) } finally { delete g[q.$$timeoutId] } m || a.$apply() }, k); q.$$timeoutId = s; g[s] = r; return q } var g = {}; f.cancel = function (a) { return a && a.$$timeoutId in g ? (g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], b.defer.cancel(a.$$timeoutId)) : !1 }; return f }]
    } function ra(a) {
        Ca && (Y.setAttribute("href", a), a =
        Y.href); Y.setAttribute("href", a); return { href: Y.href, protocol: Y.protocol ? Y.protocol.replace(/:$/, "") : "", host: Y.host, search: Y.search ? Y.search.replace(/^\?/, "") : "", hash: Y.hash ? Y.hash.replace(/^#/, "") : "", hostname: Y.hostname, port: Y.port, pathname: "/" === Y.pathname.charAt(0) ? Y.pathname : "/" + Y.pathname }
    } function hd(a) { a = F(a) ? ra(a) : a; return a.protocol === xd.protocol && a.host === xd.host } function Df() { this.$get = da(v) } function yd(a) {
        function b(a) { try { return decodeURIComponent(a) } catch (b) { return a } } var d = a[0] || {},
        c = {}, e = ""; return function () { var a, g, h, k, l; a = d.cookie || ""; if (a !== e) for (e = a, a = e.split("; "), c = {}, h = 0; h < a.length; h++) g = a[h], k = g.indexOf("="), 0 < k && (l = b(g.substring(0, k)), y(c[l]) && (c[l] = b(g.substring(k + 1)))); return c }
    } function Hf() { this.$get = yd } function Jc(a) {
        function b(d, c) { if (G(d)) { var e = {}; q(d, function (a, c) { e[c] = b(c, a) }); return e } return a.factory(d + "Filter", c) } this.register = b; this.$get = ["$injector", function (a) { return function (b) { return a.get(b + "Filter") } }]; b("currency", zd); b("date", Ad); b("filter", ng);
        b("json", og); b("limitTo", pg); b("lowercase", qg); b("number", Bd); b("orderBy", Cd); b("uppercase", rg)
    } function ng() { return function (a, b, d) { if (!ya(a)) { if (null == a) return a; throw O("filter")("notarray", a); } var c; switch (ic(b)) { case "function": break; case "boolean": case "null": case "number": case "string": c = !0; case "object": b = sg(b, d, c); break; default: return a } return Array.prototype.filter.call(a, b) } } function sg(a, b, d) {
        var c = G(a) && "$" in a; !0 === b ? b = pa : E(b) || (b = function (a, b) {
            if (y(a)) return !1; if (null === a || null === b) return a ===
            b; if (G(b) || G(a) && !rc(a)) return !1; a = P("" + a); b = P("" + b); return -1 !== a.indexOf(b)
        }); return function (e) { return c && !G(e) ? Ka(e, a.$, b, !1) : Ka(e, a, b, d) }
    } function Ka(a, b, d, c, e) {
        var f = ic(a), g = ic(b); if ("string" === g && "!" === b.charAt(0)) return !Ka(a, b.substring(1), d, c); if (K(a)) return a.some(function (a) { return Ka(a, b, d, c) }); switch (f) {
            case "object": var h; if (c) { for (h in a) if ("$" !== h.charAt(0) && Ka(a[h], b, d, !0)) return !0; return e ? !1 : Ka(a, b, d, !1) } if ("object" === g) {
                for (h in b) if (e = b[h], !E(e) && !y(e) && (f = "$" === h, !Ka(f ? a : a[h],
                e, d, f, f))) return !1; return !0
            } return d(a, b); case "function": return !1; default: return d(a, b)
        }
    } function ic(a) { return null === a ? "null" : typeof a } function zd(a) { var b = a.NUMBER_FORMATS; return function (a, c, e) { y(c) && (c = b.CURRENCY_SYM); y(e) && (e = b.PATTERNS[1].maxFrac); return null == a ? a : Dd(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(/\u00A4/g, c) } } function Bd(a) { var b = a.NUMBER_FORMATS; return function (a, c) { return null == a ? a : Dd(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c) } } function tg(a) {
        var b = 0, d, c, e, f, g; -1 <
        (c = a.indexOf(Ed)) && (a = a.replace(Ed, "")); 0 < (e = a.search(/e/i)) ? (0 > c && (c = e), c += +a.slice(e + 1), a = a.substring(0, e)) : 0 > c && (c = a.length); for (e = 0; a.charAt(e) == jc; e++); if (e == (g = a.length)) d = [0], c = 1; else { for (g--; a.charAt(g) == jc;) g--; c -= e; d = []; for (f = 0; e <= g; e++, f++) d[f] = +a.charAt(e) } c > Fd && (d = d.splice(0, Fd - 1), b = c - 1, c = 1); return { d: d, e: b, i: c }
    } function ug(a, b, d, c) {
        var e = a.d, f = e.length - a.i; b = y(b) ? Math.min(Math.max(d, f), c) : +b; d = b + a.i; c = e[d]; if (0 < d) { e.splice(Math.max(a.i, d)); for (var g = d; g < e.length; g++) e[g] = 0 } else for (f =
        Math.max(0, f), a.i = 1, e.length = Math.max(1, d = b + 1), e[0] = 0, g = 1; g < d; g++) e[g] = 0; if (5 <= c) if (0 > d - 1) { for (c = 0; c > d; c--) e.unshift(0), a.i++; e.unshift(1); a.i++ } else e[d - 1]++; for (; f < Math.max(0, b) ; f++) e.push(0); if (b = e.reduceRight(function (a, b, c, d) { b += a; d[c] = b % 10; return Math.floor(b / 10) }, 0)) e.unshift(b), a.i++
    } function Dd(a, b, d, c, e) {
        if (!F(a) && !Q(a) || isNaN(a)) return ""; var f = !isFinite(a), g = !1, h = Math.abs(a) + "", k = ""; if (f) k = "\u221e"; else {
            g = tg(h); ug(g, e, b.minFrac, b.maxFrac); k = g.d; h = g.i; e = g.e; f = []; for (g = k.reduce(function (a,
            b) { return a && !b }, !0) ; 0 > h;) k.unshift(0), h++; 0 < h ? f = k.splice(h) : (f = k, k = [0]); h = []; for (k.length >= b.lgSize && h.unshift(k.splice(-b.lgSize).join("")) ; k.length > b.gSize;) h.unshift(k.splice(-b.gSize).join("")); k.length && h.unshift(k.join("")); k = h.join(d); f.length && (k += c + f.join("")); e && (k += "e+" + e)
        } return 0 > a && !g ? b.negPre + k + b.negSuf : b.posPre + k + b.posSuf
    } function Ib(a, b, d, c) { var e = ""; if (0 > a || c && 0 >= a) c ? a = -a + 1 : (a = -a, e = "-"); for (a = "" + a; a.length < b;) a = jc + a; d && (a = a.substr(a.length - b)); return e + a } function W(a, b, d, c, e) {
        d =
        d || 0; return function (f) { f = f["get" + a](); if (0 < d || f > -d) f += d; 0 === f && -12 == d && (f = 12); return Ib(f, b, c, e) }
    } function ib(a, b, d) { return function (c, e) { var f = c["get" + a](), g = sb((d ? "STANDALONE" : "") + (b ? "SHORT" : "") + a); return e[g][f] } } function Gd(a) { var b = (new Date(a, 0, 1)).getDay(); return new Date(a, 0, (4 >= b ? 5 : 12) - b) } function Hd(a) { return function (b) { var d = Gd(b.getFullYear()); b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d; b = 1 + Math.round(b / 6048E5); return Ib(b, a) } } function kc(a, b) {
        return 0 >= a.getFullYear() ?
        b.ERAS[0] : b.ERAS[1]
    } function Ad(a) {
        function b(a) { var b; if (b = a.match(d)) { a = new Date(0); var f = 0, g = 0, h = b[8] ? a.setUTCFullYear : a.setFullYear, k = b[8] ? a.setUTCHours : a.setHours; b[9] && (f = X(b[9] + b[10]), g = X(b[9] + b[11])); h.call(a, X(b[1]), X(b[2]) - 1, X(b[3])); f = X(b[4] || 0) - f; g = X(b[5] || 0) - g; h = X(b[6] || 0); b = Math.round(1E3 * parseFloat("0." + (b[7] || 0))); k.call(a, f, g, h, b) } return a } var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/; return function (c, d, f) {
            var g = "", h =
            [], k, l; d = d || "mediumDate"; d = a.DATETIME_FORMATS[d] || d; F(c) && (c = vg.test(c) ? X(c) : b(c)); Q(c) && (c = new Date(c)); if (!fa(c) || !isFinite(c.getTime())) return c; for (; d;) (l = wg.exec(d)) ? (h = $a(h, l, 1), d = h.pop()) : (h.push(d), d = null); var n = c.getTimezoneOffset(); f && (n = vc(f, n), c = Qb(c, f, !0)); q(h, function (b) { k = xg[b]; g += k ? k(c, a.DATETIME_FORMATS, n) : "''" === b ? "'" : b.replace(/(^'|'$)/g, "").replace(/''/g, "'") }); return g
        }
    } function og() { return function (a, b) { y(b) && (b = 2); return ab(a, b) } } function pg() {
        return function (a, b, d) {
            b = Infinity ===
            Math.abs(Number(b)) ? Number(b) : X(b); if (isNaN(b)) return a; Q(a) && (a = a.toString()); if (!K(a) && !F(a)) return a; d = !d || isNaN(d) ? 0 : X(d); d = 0 > d ? Math.max(0, a.length + d) : d; return 0 <= b ? a.slice(d, d + b) : 0 === d ? a.slice(b, a.length) : a.slice(Math.max(0, d + b), d)
        }
    } function Cd(a) {
        function b(b, d) {
            d = d ? -1 : 1; return b.map(function (b) {
                var c = 1, h = Xa; if (E(b)) h = b; else if (F(b)) { if ("+" == b.charAt(0) || "-" == b.charAt(0)) c = "-" == b.charAt(0) ? -1 : 1, b = b.substring(1); if ("" !== b && (h = a(b), h.constant)) var k = h(), h = function (a) { return a[k] } } return {
                    get: h,
                    descending: c * d
                }
            })
        } function d(a) { switch (typeof a) { case "number": case "boolean": case "string": return !0; default: return !1 } } return function (a, e, f) {
            if (null == a) return a; if (!ya(a)) throw O("orderBy")("notarray", a); K(e) || (e = [e]); 0 === e.length && (e = ["+"]); var g = b(e, f); g.push({ get: function () { return {} }, descending: f ? -1 : 1 }); a = Array.prototype.map.call(a, function (a, b) {
                return {
                    value: a, predicateValues: g.map(function (c) {
                        var e = c.get(a); c = typeof e; if (null === e) c = "string", e = "null"; else if ("string" === c) e = e.toLowerCase(); else if ("object" ===
                        c) a: { if ("function" === typeof e.valueOf && (e = e.valueOf(), d(e))) break a; if (rc(e) && (e = e.toString(), d(e))) break a; e = b } return { value: e, type: c }
                    })
                }
            }); a.sort(function (a, b) { for (var c = 0, d = 0, e = g.length; d < e; ++d) { var c = a.predicateValues[d], f = b.predicateValues[d], q = 0; c.type === f.type ? c.value !== f.value && (q = c.value < f.value ? -1 : 1) : q = c.type < f.type ? -1 : 1; if (c = q * g[d].descending) break } return c }); return a = a.map(function (a) { return a.value })
        }
    } function La(a) { E(a) && (a = { link: a }); a.restrict = a.restrict || "AC"; return da(a) } function Id(a,
    b, d, c, e) {
        var f = this, g = []; f.$error = {}; f.$$success = {}; f.$pending = void 0; f.$name = e(b.name || b.ngForm || "")(d); f.$dirty = !1; f.$pristine = !0; f.$valid = !0; f.$invalid = !1; f.$submitted = !1; f.$$parentForm = Jb; f.$rollbackViewValue = function () { q(g, function (a) { a.$rollbackViewValue() }) }; f.$commitViewValue = function () { q(g, function (a) { a.$commitViewValue() }) }; f.$addControl = function (a) { Qa(a.$name, "input"); g.push(a); a.$name && (f[a.$name] = a); a.$$parentForm = f }; f.$$renameControl = function (a, b) {
            var c = a.$name; f[c] === a && delete f[c];
            f[b] = a; a.$name = b
        }; f.$removeControl = function (a) { a.$name && f[a.$name] === a && delete f[a.$name]; q(f.$pending, function (b, c) { f.$setValidity(c, null, a) }); q(f.$error, function (b, c) { f.$setValidity(c, null, a) }); q(f.$$success, function (b, c) { f.$setValidity(c, null, a) }); Za(g, a); a.$$parentForm = Jb }; Jd({ ctrl: this, $element: a, set: function (a, b, c) { var d = a[b]; d ? -1 === d.indexOf(c) && d.push(c) : a[b] = [c] }, unset: function (a, b, c) { var d = a[b]; d && (Za(d, c), 0 === d.length && delete a[b]) }, $animate: c }); f.$setDirty = function () {
            c.removeClass(a, Ua);
            c.addClass(a, Kb); f.$dirty = !0; f.$pristine = !1; f.$$parentForm.$setDirty()
        }; f.$setPristine = function () { c.setClass(a, Ua, Kb + " ng-submitted"); f.$dirty = !1; f.$pristine = !0; f.$submitted = !1; q(g, function (a) { a.$setPristine() }) }; f.$setUntouched = function () { q(g, function (a) { a.$setUntouched() }) }; f.$setSubmitted = function () { c.addClass(a, "ng-submitted"); f.$submitted = !0; f.$$parentForm.$setSubmitted() }
    } function lc(a) { a.$formatters.push(function (b) { return a.$isEmpty(b) ? b : b.toString() }) } function jb(a, b, d, c, e, f) {
        var g = P(b[0].type);
        if (!e.android) { var h = !1; b.on("compositionstart", function () { h = !0 }); b.on("compositionend", function () { h = !1; l() }) } var k, l = function (a) { k && (f.defer.cancel(k), k = null); if (!h) { var e = b.val(); a = a && a.type; "password" === g || d.ngTrim && "false" === d.ngTrim || (e = V(e)); (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a) } }; if (e.hasEvent("input")) b.on("input", l); else {
            var n = function (a, b, c) { k || (k = f.defer(function () { k = null; b && b.value === c || l(a) })) }; b.on("keydown", function (a) {
                var b = a.keyCode; 91 === b || 15 <
                b && 19 > b || 37 <= b && 40 >= b || n(a, this, this.value)
            }); if (e.hasEvent("paste")) b.on("paste cut", n)
        } b.on("change", l); if (Kd[g] && c.$$hasNativeValidators && g === d.type) b.on("keydown wheel mousedown", function (a) { if (!k) { var b = this.validity, c = b.badInput, d = b.typeMismatch; k = f.defer(function () { k = null; b.badInput === c && b.typeMismatch === d || l(a) }) } }); c.$render = function () { var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue; b.val() !== a && b.val(a) }
    } function Lb(a, b) {
        return function (d, c) {
            var e, f; if (fa(d)) return d; if (F(d)) {
                '"' == d.charAt(0) &&
                '"' == d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1)); if (yg.test(d)) return new Date(d); a.lastIndex = 0; if (e = a.exec(d)) return e.shift(), f = c ? { yyyy: c.getFullYear(), MM: c.getMonth() + 1, dd: c.getDate(), HH: c.getHours(), mm: c.getMinutes(), ss: c.getSeconds(), sss: c.getMilliseconds() / 1E3 } : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }, q(e, function (a, c) { c < b.length && (f[b[c]] = +a) }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1E3 * f.sss || 0)
            } return NaN
        }
    } function kb(a, b, d, c) {
        return function (e, f, g, h, k, l, n) {
            function m(a) {
                return a &&
                !(a.getTime && a.getTime() !== a.getTime())
            } function r(a) { return x(a) && !fa(a) ? d(a) || void 0 : a } Ld(e, f, g, h); jb(e, f, g, h, k, l); var q = h && h.$options && h.$options.timezone, s; h.$$parserName = a; h.$parsers.push(function (a) { if (h.$isEmpty(a)) return null; if (b.test(a)) return a = d(a, s), q && (a = Qb(a, q)), a }); h.$formatters.push(function (a) { if (a && !fa(a)) throw lb("datefmt", a); if (m(a)) return (s = a) && q && (s = Qb(s, q, !0)), n("date")(a, c, q); s = null; return "" }); if (x(g.min) || g.ngMin) {
                var w; h.$validators.min = function (a) {
                    return !m(a) || y(w) || d(a) >=
                    w
                }; g.$observe("min", function (a) { w = r(a); h.$validate() })
            } if (x(g.max) || g.ngMax) { var p; h.$validators.max = function (a) { return !m(a) || y(p) || d(a) <= p }; g.$observe("max", function (a) { p = r(a); h.$validate() }) }
        }
    } function Ld(a, b, d, c) { (c.$$hasNativeValidators = G(b[0].validity)) && c.$parsers.push(function (a) { var c = b.prop("validity") || {}; return c.badInput || c.typeMismatch ? void 0 : a }) } function Md(a, b, d, c, e) { if (x(c)) { a = a(c); if (!a.constant) throw lb("constexpr", d, c); return a(b) } return e } function mc(a, b) {
        a = "ngClass" + a; return ["$animate",
        function (d) {
            function c(a, b) { var c = [], d = 0; a: for (; d < a.length; d++) { for (var e = a[d], n = 0; n < b.length; n++) if (e == b[n]) continue a; c.push(e) } return c } function e(a) { var b = []; return K(a) ? (q(a, function (a) { b = b.concat(e(a)) }), b) : F(a) ? a.split(" ") : G(a) ? (q(a, function (a, c) { a && (b = b.concat(c.split(" "))) }), b) : a } return {
                restrict: "AC", link: function (f, g, h) {
                    function k(a) { a = l(a, 1); h.$addClass(a) } function l(a, b) {
                        var c = g.data("$classCounts") || T(), d = []; q(a, function (a) { if (0 < b || c[a]) c[a] = (c[a] || 0) + b, c[a] === +(0 < b) && d.push(a) }); g.data("$classCounts",
                        c); return d.join(" ")
                    } function n(a, b) { var e = c(b, a), f = c(a, b), e = l(e, 1), f = l(f, -1); e && e.length && d.addClass(g, e); f && f.length && d.removeClass(g, f) } function m(a) { if (!0 === b || f.$index % 2 === b) { var c = e(a || []); if (!r) k(c); else if (!pa(a, r)) { var d = e(r); n(d, c) } } r = K(a) ? a.map(function (a) { return ha(a) }) : ha(a) } var r; f.$watch(h[a], m, !0); h.$observe("class", function (b) { m(f.$eval(h[a])) }); "ngClass" !== a && f.$watch("$index", function (c, d) { var g = c & 1; if (g !== (d & 1)) { var m = e(f.$eval(h[a])); g === b ? k(m) : (g = l(m, -1), h.$removeClass(g)) } })
                }
            }
        }]
    }
    function Jd(a) {
        function b(a, b) { b && !f[a] ? (k.addClass(e, a), f[a] = !0) : !b && f[a] && (k.removeClass(e, a), f[a] = !1) } function d(a, c) { a = a ? "-" + zc(a, "-") : ""; b(mb + a, !0 === c); b(Nd + a, !1 === c) } var c = a.ctrl, e = a.$element, f = {}, g = a.set, h = a.unset, k = a.$animate; f[Nd] = !(f[mb] = e.hasClass(mb)); c.$setValidity = function (a, e, f) {
            y(e) ? (c.$pending || (c.$pending = {}), g(c.$pending, a, f)) : (c.$pending && h(c.$pending, a, f), Od(c.$pending) && (c.$pending = void 0)); Da(e) ? e ? (h(c.$error, a, f), g(c.$$success, a, f)) : (g(c.$error, a, f), h(c.$$success, a, f)) : (h(c.$error,
            a, f), h(c.$$success, a, f)); c.$pending ? (b(Pd, !0), c.$valid = c.$invalid = void 0, d("", null)) : (b(Pd, !1), c.$valid = Od(c.$error), c.$invalid = !c.$valid, d("", c.$valid)); e = c.$pending && c.$pending[a] ? void 0 : c.$error[a] ? !1 : c.$$success[a] ? !0 : null; d(a, e); c.$$parentForm.$setValidity(a, e, c)
        }
    } function Od(a) { if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1; return !0 } var zg = /^\/(.+)\/([a-z]*)$/, ua = Object.prototype.hasOwnProperty, P = function (a) { return F(a) ? a.toLowerCase() : a }, sb = function (a) { return F(a) ? a.toUpperCase() : a }, Ca,
    B, Z, za = [].slice, Zf = [].splice, Ag = [].push, ma = Object.prototype.toString, sc = Object.getPrototypeOf, Aa = O("ng"), ea = v.angular || (v.angular = {}), Sb, nb = 0; Ca = v.document.documentMode; C.$inject = []; Xa.$inject = []; var K = Array.isArray, $d = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/, V = function (a) { return F(a) ? a.trim() : a }, vd = function (a) { return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08") }, Ea = function () {
        if (!x(Ea.rules)) {
            var a = v.document.querySelector("[ng-csp]") ||
            v.document.querySelector("[data-ng-csp]"); if (a) { var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp"); Ea.rules = { noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"), noInlineStyle: !b || -1 !== b.indexOf("no-inline-style") } } else { a = Ea; try { new Function(""), b = !1 } catch (d) { b = !0 } a.rules = { noUnsafeEval: b, noInlineStyle: !1 } }
        } return Ea.rules
    }, pb = function () {
        if (x(pb.name_)) return pb.name_; var a, b, d = Na.length, c, e; for (b = 0; b < d; ++b) if (c = Na[b], a = v.document.querySelector("[" + c.replace(":", "\\:") + "jq]")) {
            e = a.getAttribute(c +
            "jq"); break
        } return pb.name_ = e
    }, ce = /:/g, Na = ["ng-", "data-ng-", "ng:", "x-ng-"], he = /[A-Z]/g, Ac = !1, Ma = 3, le = { full: "1.5.5", major: 1, minor: 5, dot: 5, codeName: "material-conspiration" }; U.expando = "ng339"; var eb = U.cache = {}, Nf = 1; U._data = function (a) { return this.cache[a[this.expando]] || {} }; var If = /([\:\-\_]+(.))/g, Jf = /^moz([A-Z])/, wb = { mouseleave: "mouseout", mouseenter: "mouseover" }, Ub = O("jqLite"), Mf = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, Tb = /<|&#?\w+;/, Kf = /<([\w:-]+)/, Lf = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    ia = { option: [1, '<select multiple="multiple">', "</select>"], thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; ia.optgroup = ia.option; ia.tbody = ia.tfoot = ia.colgroup = ia.caption = ia.thead; ia.th = ia.td; var Sf = v.Node.prototype.contains || function (a) { return !!(this.compareDocumentPosition(a) & 16) }, Oa = U.prototype = {
        ready: function (a) {
            function b() { d || (d = !0, a()) } var d = !1; "complete" ===
            v.document.readyState ? v.setTimeout(b) : (this.on("DOMContentLoaded", b), U(v).on("load", b))
        }, toString: function () { var a = []; q(this, function (b) { a.push("" + b) }); return "[" + a.join(", ") + "]" }, eq: function (a) { return 0 <= a ? B(this[a]) : B(this[this.length + a]) }, length: 0, push: Ag, sort: [].sort, splice: [].splice
    }, Cb = {}; q("multiple selected checked disabled readOnly required open".split(" "), function (a) { Cb[P(a)] = a }); var Sc = {}; q("input select option textarea button form details".split(" "), function (a) { Sc[a] = !0 }); var ad = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength", ngMin: "min", ngMax: "max", ngPattern: "pattern"
    }; q({ data: Wb, removeData: db, hasData: function (a) { for (var b in eb[a.ng339]) return !0; return !1 }, cleanData: function (a) { for (var b = 0, d = a.length; b < d; b++) db(a[b]) } }, function (a, b) { U[b] = a }); q({
        data: Wb, inheritedData: Ab, scope: function (a) { return B.data(a, "$scope") || Ab(a.parentNode || a, ["$isolateScope", "$scope"]) }, isolateScope: function (a) { return B.data(a, "$isolateScope") || B.data(a, "$isolateScopeNoTemplate") }, controller: Pc, injector: function (a) {
            return Ab(a,
            "$injector")
        }, removeAttr: function (a, b) { a.removeAttribute(b) }, hasClass: xb, css: function (a, b, d) { b = cb(b); if (x(d)) a.style[b] = d; else return a.style[b] }, attr: function (a, b, d) { var c = a.nodeType; if (c !== Ma && 2 !== c && 8 !== c) if (c = P(b), Cb[c]) if (x(d)) d ? (a[b] = !0, a.setAttribute(b, c)) : (a[b] = !1, a.removeAttribute(c)); else return a[b] || (a.attributes.getNamedItem(b) || C).specified ? c : void 0; else if (x(d)) a.setAttribute(b, d); else if (a.getAttribute) return a = a.getAttribute(b, 2), null === a ? void 0 : a }, prop: function (a, b, d) {
            if (x(d)) a[b] =
            d; else return a[b]
        }, text: function () { function a(a, d) { if (y(d)) { var c = a.nodeType; return 1 === c || c === Ma ? a.textContent : "" } a.textContent = d } a.$dv = ""; return a }(), val: function (a, b) { if (y(b)) { if (a.multiple && "select" === va(a)) { var d = []; q(a.options, function (a) { a.selected && d.push(a.value || a.text) }); return 0 === d.length ? null : d } return a.value } a.value = b }, html: function (a, b) { if (y(b)) return a.innerHTML; ub(a, !0); a.innerHTML = b }, empty: Qc
    }, function (a, b) {
        U.prototype[b] = function (b, c) {
            var e, f, g = this.length; if (a !== Qc && y(2 == a.length &&
            a !== xb && a !== Pc ? b : c)) { if (G(b)) { for (e = 0; e < g; e++) if (a === Wb) a(this[e], b); else for (f in b) a(this[e], f, b[f]); return this } e = a.$dv; g = y(e) ? Math.min(g, 1) : g; for (f = 0; f < g; f++) { var h = a(this[f], b, c); e = e ? e + h : h } return e } for (e = 0; e < g; e++) a(this[e], b, c); return this
        }
    }); q({
        removeData: db, on: function (a, b, d, c) {
            if (x(c)) throw Ub("onargs"); if (Kc(a)) {
                c = vb(a, !0); var e = c.events, f = c.handle; f || (f = c.handle = Pf(a, e)); c = 0 <= b.indexOf(" ") ? b.split(" ") : [b]; for (var g = c.length, h = function (b, c, g) {
                var h = e[b]; h || (h = e[b] = [], h.specialHandlerWrapper =
                c, "$destroy" === b || g || a.addEventListener(b, f, !1)); h.push(d)
                }; g--;) b = c[g], wb[b] ? (h(wb[b], Rf), h(b, void 0, !0)) : h(b)
            }
        }, off: Oc, one: function (a, b, d) { a = B(a); a.on(b, function e() { a.off(b, d); a.off(b, e) }); a.on(b, d) }, replaceWith: function (a, b) { var d, c = a.parentNode; ub(a); q(new U(b), function (b) { d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a); d = b }) }, children: function (a) { var b = []; q(a.childNodes, function (a) { 1 === a.nodeType && b.push(a) }); return b }, contents: function (a) { return a.contentDocument || a.childNodes || [] }, append: function (a,
        b) { var d = a.nodeType; if (1 === d || 11 === d) { b = new U(b); for (var d = 0, c = b.length; d < c; d++) a.appendChild(b[d]) } }, prepend: function (a, b) { if (1 === a.nodeType) { var d = a.firstChild; q(new U(b), function (b) { a.insertBefore(b, d) }) } }, wrap: function (a, b) { Mc(a, B(b).eq(0).clone()[0]) }, remove: Bb, detach: function (a) { Bb(a, !0) }, after: function (a, b) { var d = a, c = a.parentNode; b = new U(b); for (var e = 0, f = b.length; e < f; e++) { var g = b[e]; c.insertBefore(g, d.nextSibling); d = g } }, addClass: zb, removeClass: yb, toggleClass: function (a, b, d) {
            b && q(b.split(" "),
            function (b) { var e = d; y(e) && (e = !xb(a, b)); (e ? zb : yb)(a, b) })
        }, parent: function (a) { return (a = a.parentNode) && 11 !== a.nodeType ? a : null }, next: function (a) { return a.nextElementSibling }, find: function (a, b) { return a.getElementsByTagName ? a.getElementsByTagName(b) : [] }, clone: Vb, triggerHandler: function (a, b, d) {
            var c, e, f = b.type || b, g = vb(a); if (g = (g = g && g.events) && g[f]) c = {
                preventDefault: function () { this.defaultPrevented = !0 }, isDefaultPrevented: function () { return !0 === this.defaultPrevented }, stopImmediatePropagation: function () {
                    this.immediatePropagationStopped =
                    !0
                }, isImmediatePropagationStopped: function () { return !0 === this.immediatePropagationStopped }, stopPropagation: C, type: f, target: a
            }, b.type && (c = R(c, b)), b = ha(g), e = d ? [c].concat(d) : [c], q(b, function (b) { c.isImmediatePropagationStopped() || b.apply(a, e) })
        }
    }, function (a, b) { U.prototype[b] = function (b, c, e) { for (var f, g = 0, h = this.length; g < h; g++) y(f) ? (f = a(this[g], b, c, e), x(f) && (f = B(f))) : Nc(f, a(this[g], b, c, e)); return x(f) ? f : this }; U.prototype.bind = U.prototype.on; U.prototype.unbind = U.prototype.off }); Ra.prototype = {
        put: function (a,
        b) { this[Fa(a, this.nextUid)] = b }, get: function (a) { return this[Fa(a, this.nextUid)] }, remove: function (a) { var b = this[a = Fa(a, this.nextUid)]; delete this[a]; return b }
    }; var Gf = [function () { this.$get = [function () { return Ra }] }], Uf = /^([^\(]+?)=>/, Vf = /^[^\(]*\(\s*([^\)]*)\)/m, Bg = /,/, Cg = /^\s*(_?)(\S+?)\1\s*$/, Tf = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, Ga = O("$injector"); bb.$$annotate = function (a, b, d) {
        var c; if ("function" === typeof a) {
            if (!(c = a.$inject)) {
                c = []; if (a.length) {
                    if (b) throw F(d) && d || (d = a.name || Wf(a)), Ga("strictdi", d);
                    b = Tc(a); q(b[1].split(Bg), function (a) { a.replace(Cg, function (a, b, d) { c.push(d) }) })
                } a.$inject = c
            }
        } else K(a) ? (b = a.length - 1, Pa(a[b], "fn"), c = a.slice(0, b)) : Pa(a, "fn", !0); return c
    }; var Qd = O("$animate"), Ze = function () { this.$get = C }, $e = function () {
        var a = new Ra, b = []; this.$get = ["$$AnimateRunner", "$rootScope", function (d, c) {
            function e(a, b, c) { var d = !1; b && (b = F(b) ? b.split(" ") : K(b) ? b : [], q(b, function (b) { b && (d = !0, a[b] = c) })); return d } function f() {
                q(b, function (b) {
                    var c = a.get(b); if (c) {
                        var d = Xf(b.attr("class")), e = "", f = ""; q(c,
                        function (a, b) { a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b) }); q(b, function (a) { e && zb(a, e); f && yb(a, f) }); a.remove(b)
                    }
                }); b.length = 0
            } return { enabled: C, on: C, off: C, pin: C, push: function (g, h, k, l) { l && l(); k = k || {}; k.from && g.css(k.from); k.to && g.css(k.to); if (k.addClass || k.removeClass) if (h = k.addClass, l = k.removeClass, k = a.get(g) || {}, h = e(k, h, !0), l = e(k, l, !1), h || l) a.put(g, k), b.push(g), 1 === b.length && c.$$postDigest(f); g = new d; g.complete(); return g } }
        }]
    }, Xe = ["$provide", function (a) {
        var b = this; this.$$registeredAnimations =
        Object.create(null); this.register = function (d, c) { if (d && "." !== d.charAt(0)) throw Qd("notcsel", d); var e = d + "-animation"; b.$$registeredAnimations[d.substr(1)] = e; a.factory(e, c) }; this.classNameFilter = function (a) { if (1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null) && /(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString())) throw Qd("nongcls", "ng-animate"); return this.$$classNameFilter }; this.$get = ["$$animateQueue", function (a) {
            function b(a, c, d) {
                if (d) {
                    var h; a: {
                        for (h = 0; h < d.length; h++) {
                            var k =
                            d[h]; if (1 === k.nodeType) { h = k; break a }
                        } h = void 0
                    } !h || h.parentNode || h.previousElementSibling || (d = null)
                } d ? d.after(a) : c.prepend(a)
            } return {
                on: a.on, off: a.off, pin: a.pin, enabled: a.enabled, cancel: function (a) { a.end && a.end() }, enter: function (e, f, g, h) { f = f && B(f); g = g && B(g); f = f || g.parent(); b(e, f, g); return a.push(e, "enter", Ha(h)) }, move: function (e, f, g, h) { f = f && B(f); g = g && B(g); f = f || g.parent(); b(e, f, g); return a.push(e, "move", Ha(h)) }, leave: function (b, c) { return a.push(b, "leave", Ha(c), function () { b.remove() }) }, addClass: function (b,
                c, g) { g = Ha(g); g.addClass = fb(g.addclass, c); return a.push(b, "addClass", g) }, removeClass: function (b, c, g) { g = Ha(g); g.removeClass = fb(g.removeClass, c); return a.push(b, "removeClass", g) }, setClass: function (b, c, g, h) { h = Ha(h); h.addClass = fb(h.addClass, c); h.removeClass = fb(h.removeClass, g); return a.push(b, "setClass", h) }, animate: function (b, c, g, h, k) { k = Ha(k); k.from = k.from ? R(k.from, c) : c; k.to = k.to ? R(k.to, g) : g; k.tempClasses = fb(k.tempClasses, h || "ng-inline-animate"); return a.push(b, "animate", k) }
            }
        }]
    }], bf = function () {
        this.$get =
        ["$$rAF", function (a) { function b(b) { d.push(b); 1 < d.length || a(function () { for (var a = 0; a < d.length; a++) d[a](); d = [] }) } var d = []; return function () { var a = !1; b(function () { a = !0 }); return function (d) { a ? d() : b(d) } } }]
    }, af = function () {
        this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$document", "$timeout", function (a, b, d, c, e) {
            function f(a) { this.setHost(a); var b = d(); this._doneCallbacks = []; this._tick = function (a) { var d = c[0]; d && d.hidden ? e(a, 0, !1) : b(a) }; this._state = 0 } f.chain = function (a, b) {
                function c() {
                    if (d === a.length) b(!0);
                    else a[d](function (a) { !1 === a ? b(!1) : (d++, c()) })
                } var d = 0; c()
            }; f.all = function (a, b) { function c(f) { e = e && f; ++d === a.length && b(e) } var d = 0, e = !0; q(a, function (a) { a.done(c) }) }; f.prototype = {
                setHost: function (a) { this.host = a || {} }, done: function (a) { 2 === this._state ? a() : this._doneCallbacks.push(a) }, progress: C, getPromise: function () { if (!this.promise) { var b = this; this.promise = a(function (a, c) { b.done(function (b) { !1 === b ? c() : a() }) }) } return this.promise }, then: function (a, b) { return this.getPromise().then(a, b) }, "catch": function (a) { return this.getPromise()["catch"](a) },
                "finally": function (a) { return this.getPromise()["finally"](a) }, pause: function () { this.host.pause && this.host.pause() }, resume: function () { this.host.resume && this.host.resume() }, end: function () { this.host.end && this.host.end(); this._resolve(!0) }, cancel: function () { this.host.cancel && this.host.cancel(); this._resolve(!1) }, complete: function (a) { var b = this; 0 === b._state && (b._state = 1, b._tick(function () { b._resolve(a) })) }, _resolve: function (a) {
                    2 !== this._state && (q(this._doneCallbacks, function (b) { b(a) }), this._doneCallbacks.length =
                    0, this._state = 2)
                }
            }; return f
        }]
    }, Ye = function () { this.$get = ["$$rAF", "$q", "$$AnimateRunner", function (a, b, d) { return function (b, e) { function f() { a(function () { g.addClass && (b.addClass(g.addClass), g.addClass = null); g.removeClass && (b.removeClass(g.removeClass), g.removeClass = null); g.to && (b.css(g.to), g.to = null); h || k.complete(); h = !0 }); return k } var g = e || {}; g.$$prepared || (g = qa(g)); g.cleanupStyles && (g.from = g.to = null); g.from && (b.css(g.from), g.from = null); var h, k = new d; return { start: f, end: f } } }] }, ga = O("$compile"), Zb = new function () { };
    Cc.$inject = ["$provide", "$$sanitizeUriProvider"]; Db.prototype.isFirstChange = function () { return this.previousValue === Zb }; var Vc = /^((?:x|data)[\:\-_])/i, $f = O("$controller"), bd = /^(\S+)(\s+as\s+([\w$]+))?$/, hf = function () { this.$get = ["$document", function (a) { return function (b) { b ? !b.nodeType && b instanceof B && (b = b[0]) : b = a[0].body; return b.offsetWidth + 1 } }] }, cd = "application/json", bc = { "Content-Type": cd + ";charset=utf-8" }, bg = /^\[|^\{(?!\{)/, cg = { "[": /]$/, "{": /}$/ }, ag = /^\)\]\}',?\n/, Dg = O("$http"), gd = function (a) {
        return function () {
            throw Dg("legacy",
            a);
        }
    }, Ja = ea.$interpolateMinErr = O("$interpolate"); Ja.throwNoconcat = function (a) { throw Ja("noconcat", a); }; Ja.interr = function (a, b) { return Ja("interr", a, b.toString()) }; var Eg = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, eg = { http: 80, https: 443, ftp: 21 }, Eb = O("$location"), Fg = {
        $$html5: !1, $$replace: !1, absUrl: Fb("$$absUrl"), url: function (a) { if (y(a)) return this.$$url; var b = Eg.exec(a); (b[1] || "" === a) && this.path(decodeURIComponent(b[1])); (b[2] || b[1] || "" === a) && this.search(b[3] || ""); this.hash(b[5] || ""); return this }, protocol: Fb("$$protocol"),
        host: Fb("$$host"), port: Fb("$$port"), path: ld("$$path", function (a) { a = null !== a ? a.toString() : ""; return "/" == a.charAt(0) ? a : "/" + a }), search: function (a, b) { switch (arguments.length) { case 0: return this.$$search; case 1: if (F(a) || Q(a)) a = a.toString(), this.$$search = xc(a); else if (G(a)) a = qa(a, {}), q(a, function (b, c) { null == b && delete a[c] }), this.$$search = a; else throw Eb("isrcharg"); break; default: y(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b } this.$$compose(); return this }, hash: ld("$$hash", function (a) {
            return null !==
            a ? a.toString() : ""
        }), replace: function () { this.$$replace = !0; return this }
    }; q([kd, ec, dc], function (a) { a.prototype = Object.create(Fg); a.prototype.state = function (b) { if (!arguments.length) return this.$$state; if (a !== dc || !this.$$html5) throw Eb("nostate"); this.$$state = y(b) ? null : b; return this } }); var ca = O("$parse"), gg = Function.prototype.call, hg = Function.prototype.apply, ig = Function.prototype.bind, Mb = T(); q("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (a) { Mb[a] = !0 }); var Gg = {
        n: "\n", f: "\f", r: "\r",
        t: "\t", v: "\v", "'": "'", '"': '"'
    }, gc = function (a) { this.options = a }; gc.prototype = {
        constructor: gc, lex: function (a) {
            this.text = a; this.index = 0; for (this.tokens = []; this.index < this.text.length;) if (a = this.text.charAt(this.index), '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({ index: this.index, text: a }), this.index++; else if (this.isWhitespace(a)) this.index++;
            else { var b = a + this.peek(), d = b + this.peek(2), c = Mb[b], e = Mb[d]; Mb[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({ index: this.index, text: a, operator: !0 }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1) } return this.tokens
        }, is: function (a, b) { return -1 !== b.indexOf(a) }, peek: function (a) { a = a || 1; return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1 }, isNumber: function (a) { return "0" <= a && "9" >= a && "string" === typeof a }, isWhitespace: function (a) {
            return " " === a || "\r" === a ||
            "\t" === a || "\n" === a || "\v" === a || "\u00a0" === a
        }, isIdentifierStart: function (a) { return this.options.isIdentifierStart ? this.options.isIdentifierStart(a, this.codePointAt(a)) : this.isValidIdentifierStart(a) }, isValidIdentifierStart: function (a) { return "a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a }, isIdentifierContinue: function (a) { return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(a, this.codePointAt(a)) : this.isValidIdentifierContinue(a) }, isValidIdentifierContinue: function (a, b) {
            return this.isValidIdentifierStart(a,
            b) || this.isNumber(a)
        }, codePointAt: function (a) { return 1 === a.length ? a.charCodeAt(0) : (a.charCodeAt(0) << 10) + a.charCodeAt(1) - 56613888 }, peekMultichar: function () { var a = this.text.charAt(this.index), b = this.peek(); if (!b) return a; var d = a.charCodeAt(0), c = b.charCodeAt(0); return 55296 <= d && 56319 >= d && 56320 <= c && 57343 >= c ? a + b : a }, isExpOperator: function (a) { return "-" === a || "+" === a || this.isNumber(a) }, throwError: function (a, b, d) {
            d = d || this.index; b = x(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d; throw ca("lexerr",
            a, b, this.text);
        }, readNumber: function () { for (var a = "", b = this.index; this.index < this.text.length;) { var d = P(this.text.charAt(this.index)); if ("." == d || this.isNumber(d)) a += d; else { var c = this.peek(); if ("e" == d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" == a.charAt(a.length - 1)) a += d; else if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" != a.charAt(a.length - 1)) break; else this.throwError("Invalid exponent") } this.index++ } this.tokens.push({ index: b, text: a, constant: !0, value: Number(a) }) },
        readIdent: function () { var a = this.index; for (this.index += this.peekMultichar().length; this.index < this.text.length;) { var b = this.peekMultichar(); if (!this.isIdentifierContinue(b)) break; this.index += b.length } this.tokens.push({ index: a, text: this.text.slice(a, this.index), identifier: !0 }) }, readString: function (a) {
            var b = this.index; this.index++; for (var d = "", c = a, e = !1; this.index < this.text.length;) {
                var f = this.text.charAt(this.index), c = c + f; if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) ||
                this.throwError("Invalid unicode escape [\\u" + e + "]"), this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d += Gg[f] || f, e = !1; else if ("\\" === f) e = !0; else { if (f === a) { this.index++; this.tokens.push({ index: b, text: c, constant: !0, value: d }); return } d += f } this.index++
            } this.throwError("Unterminated quote", b)
        }
    }; var s = function (a, b) { this.lexer = a; this.options = b }; s.Program = "Program"; s.ExpressionStatement = "ExpressionStatement"; s.AssignmentExpression = "AssignmentExpression"; s.ConditionalExpression = "ConditionalExpression";
    s.LogicalExpression = "LogicalExpression"; s.BinaryExpression = "BinaryExpression"; s.UnaryExpression = "UnaryExpression"; s.CallExpression = "CallExpression"; s.MemberExpression = "MemberExpression"; s.Identifier = "Identifier"; s.Literal = "Literal"; s.ArrayExpression = "ArrayExpression"; s.Property = "Property"; s.ObjectExpression = "ObjectExpression"; s.ThisExpression = "ThisExpression"; s.LocalsExpression = "LocalsExpression"; s.NGValueParameter = "NGValueParameter"; s.prototype = {
        ast: function (a) {
            this.text = a; this.tokens = this.lexer.lex(a);
            a = this.program(); 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]); return a
        }, program: function () { for (var a = []; ;) if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), !this.expect(";")) return { type: s.Program, body: a } }, expressionStatement: function () { return { type: s.ExpressionStatement, expression: this.filterChain() } }, filterChain: function () { for (var a = this.expression() ; this.expect("|") ;) a = this.filter(a); return a }, expression: function () { return this.assignment() },
        assignment: function () { var a = this.ternary(); this.expect("=") && (a = { type: s.AssignmentExpression, left: a, right: this.assignment(), operator: "=" }); return a }, ternary: function () { var a = this.logicalOR(), b, d; return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), { type: s.ConditionalExpression, test: a, alternate: b, consequent: d }) : a }, logicalOR: function () { for (var a = this.logicalAND() ; this.expect("||") ;) a = { type: s.LogicalExpression, operator: "||", left: a, right: this.logicalAND() }; return a }, logicalAND: function () {
            for (var a =
            this.equality() ; this.expect("&&") ;) a = { type: s.LogicalExpression, operator: "&&", left: a, right: this.equality() }; return a
        }, equality: function () { for (var a = this.relational(), b; b = this.expect("==", "!=", "===", "!==") ;) a = { type: s.BinaryExpression, operator: b.text, left: a, right: this.relational() }; return a }, relational: function () { for (var a = this.additive(), b; b = this.expect("<", ">", "<=", ">=") ;) a = { type: s.BinaryExpression, operator: b.text, left: a, right: this.additive() }; return a }, additive: function () {
            for (var a = this.multiplicative(),
            b; b = this.expect("+", "-") ;) a = { type: s.BinaryExpression, operator: b.text, left: a, right: this.multiplicative() }; return a
        }, multiplicative: function () { for (var a = this.unary(), b; b = this.expect("*", "/", "%") ;) a = { type: s.BinaryExpression, operator: b.text, left: a, right: this.unary() }; return a }, unary: function () { var a; return (a = this.expect("+", "-", "!")) ? { type: s.UnaryExpression, operator: a.text, prefix: !0, argument: this.unary() } : this.primary() }, primary: function () {
            var a; this.expect("(") ? (a = this.filterChain(), this.consume(")")) :
            this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ? a = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? a = qa(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? a = { type: s.Literal, value: this.options.literals[this.consume().text] } : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek()); for (var b; b = this.expect("(", "[", ".") ;) "(" === b.text ? (a = {
                type: s.CallExpression,
                callee: a, arguments: this.parseArguments()
            }, this.consume(")")) : "[" === b.text ? (a = { type: s.MemberExpression, object: a, property: this.expression(), computed: !0 }, this.consume("]")) : "." === b.text ? a = { type: s.MemberExpression, object: a, property: this.identifier(), computed: !1 } : this.throwError("IMPOSSIBLE"); return a
        }, filter: function (a) { a = [a]; for (var b = { type: s.CallExpression, callee: this.identifier(), arguments: a, filter: !0 }; this.expect(":") ;) a.push(this.expression()); return b }, parseArguments: function () {
            var a = []; if (")" !==
            this.peekToken().text) { do a.push(this.expression()); while (this.expect(",")) } return a
        }, identifier: function () { var a = this.consume(); a.identifier || this.throwError("is not a valid identifier", a); return { type: s.Identifier, name: a.text } }, constant: function () { return { type: s.Literal, value: this.consume().value } }, arrayDeclaration: function () { var a = []; if ("]" !== this.peekToken().text) { do { if (this.peek("]")) break; a.push(this.expression()) } while (this.expect(",")) } this.consume("]"); return { type: s.ArrayExpression, elements: a } },
        object: function () { var a = [], b; if ("}" !== this.peekToken().text) { do { if (this.peek("}")) break; b = { type: s.Property, kind: "init" }; this.peek().constant ? b.key = this.constant() : this.peek().identifier ? b.key = this.identifier() : this.throwError("invalid key", this.peek()); this.consume(":"); b.value = this.expression(); a.push(b) } while (this.expect(",")) } this.consume("}"); return { type: s.ObjectExpression, properties: a } }, throwError: function (a, b) { throw ca("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index)); }, consume: function (a) {
            if (0 ===
            this.tokens.length) throw ca("ueoe", this.text); var b = this.expect(a); b || this.throwError("is unexpected, expecting [" + a + "]", this.peek()); return b
        }, peekToken: function () { if (0 === this.tokens.length) throw ca("ueoe", this.text); return this.tokens[0] }, peek: function (a, b, d, c) { return this.peekAhead(0, a, b, d, c) }, peekAhead: function (a, b, d, c, e) { if (this.tokens.length > a) { a = this.tokens[a]; var f = a.text; if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a } return !1 }, expect: function (a, b, d, c) {
            return (a = this.peek(a, b, d, c)) ?
            (this.tokens.shift(), a) : !1
        }, selfReferential: { "this": { type: s.ThisExpression }, $locals: { type: s.LocalsExpression } }
    }; sd.prototype = {
        compile: function (a, b) {
            var d = this, c = this.astBuilder.ast(a); this.state = { nextId: 0, filters: {}, expensiveChecks: b, fn: { vars: [], body: [], own: {} }, assign: { vars: [], body: [], own: {} }, inputs: [] }; aa(c, d.$filter); var e = "", f; this.stage = "assign"; if (f = qd(c)) this.state.computing = "assign", e = this.nextId(), this.recurse(f, e), this.return_(e), e = "fn.assign=" + this.generateFunction("assign", "s,v,l"); f = od(c.body);
            d.stage = "inputs"; q(f, function (a, b) { var c = "fn" + b; d.state[c] = { vars: [], body: [], own: {} }; d.state.computing = c; var e = d.nextId(); d.recurse(a, e); d.return_(e); d.state.inputs.push(c); a.watchId = b }); this.state.computing = "fn"; this.stage = "main"; this.recurse(c); e = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + e + this.watchFns() + "return fn;"; e = (new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext",
            "ifDefined", "plus", "text", e))(this.$filter, Ta, sa, md, fg, Gb, jg, nd, a); this.state = this.stage = void 0; e.literal = rd(c); e.constant = c.constant; return e
        }, USE: "use", STRICT: "strict", watchFns: function () { var a = [], b = this.state.inputs, d = this; q(b, function (b) { a.push("var " + b + "=" + d.generateFunction(b, "s")) }); b.length && a.push("fn.inputs=[" + b.join(",") + "];"); return a.join("") }, generateFunction: function (a, b) { return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};" }, filterPrefix: function () {
            var a = [], b = this; q(this.state.filters,
            function (d, c) { a.push(d + "=$filter(" + b.escape(c) + ")") }); return a.length ? "var " + a.join(",") + ";" : ""
        }, varsPrefix: function (a) { return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : "" }, body: function (a) { return this.state[a].body.join("") }, recurse: function (a, b, d, c, e, f) {
            var g, h, k = this, l, n; c = c || C; if (!f && x(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
                case s.Program: q(a.body, function (b, c) {
                    k.recurse(b.expression,
                    void 0, void 0, function (a) { h = a }); c !== a.body.length - 1 ? k.current().body.push(h, ";") : k.return_(h)
                }); break; case s.Literal: n = this.escape(a.value); this.assign(b, n); c(n); break; case s.UnaryExpression: this.recurse(a.argument, void 0, void 0, function (a) { h = a }); n = a.operator + "(" + this.ifDefined(h, 0) + ")"; this.assign(b, n); c(n); break; case s.BinaryExpression: this.recurse(a.left, void 0, void 0, function (a) { g = a }); this.recurse(a.right, void 0, void 0, function (a) { h = a }); n = "+" === a.operator ? this.plus(g, h) : "-" === a.operator ? this.ifDefined(g,
                0) + a.operator + this.ifDefined(h, 0) : "(" + g + ")" + a.operator + "(" + h + ")"; this.assign(b, n); c(n); break; case s.LogicalExpression: b = b || this.nextId(); k.recurse(a.left, b); k.if_("&&" === a.operator ? b : k.not(b), k.lazyRecurse(a.right, b)); c(b); break; case s.ConditionalExpression: b = b || this.nextId(); k.recurse(a.test, b); k.if_(b, k.lazyRecurse(a.alternate, b), k.lazyRecurse(a.consequent, b)); c(b); break; case s.Identifier: b = b || this.nextId(); d && (d.context = "inputs" === k.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l",
                a.name) + "?l:s"), d.computed = !1, d.name = a.name); Ta(a.name); k.if_("inputs" === k.stage || k.not(k.getHasOwnProperty("l", a.name)), function () { k.if_("inputs" === k.stage || "s", function () { e && 1 !== e && k.if_(k.not(k.nonComputedMember("s", a.name)), k.lazyAssign(k.nonComputedMember("s", a.name), "{}")); k.assign(b, k.nonComputedMember("s", a.name)) }) }, b && k.lazyAssign(b, k.nonComputedMember("l", a.name))); (k.state.expensiveChecks || Hb(a.name)) && k.addEnsureSafeObject(b); c(b); break; case s.MemberExpression: g = d && (d.context = this.nextId()) ||
                this.nextId(); b = b || this.nextId(); k.recurse(a.object, g, void 0, function () {
                    k.if_(k.notNull(g), function () {
                        e && 1 !== e && k.addEnsureSafeAssignContext(g); if (a.computed) h = k.nextId(), k.recurse(a.property, h), k.getStringValue(h), k.addEnsureSafeMemberName(h), e && 1 !== e && k.if_(k.not(k.computedMember(g, h)), k.lazyAssign(k.computedMember(g, h), "{}")), n = k.ensureSafeObject(k.computedMember(g, h)), k.assign(b, n), d && (d.computed = !0, d.name = h); else {
                            Ta(a.property.name); e && 1 !== e && k.if_(k.not(k.nonComputedMember(g, a.property.name)),
                            k.lazyAssign(k.nonComputedMember(g, a.property.name), "{}")); n = k.nonComputedMember(g, a.property.name); if (k.state.expensiveChecks || Hb(a.property.name)) n = k.ensureSafeObject(n); k.assign(b, n); d && (d.computed = !1, d.name = a.property.name)
                        }
                    }, function () { k.assign(b, "undefined") }); c(b)
                }, !!e); break; case s.CallExpression: b = b || this.nextId(); a.filter ? (h = k.filter(a.callee.name), l = [], q(a.arguments, function (a) { var b = k.nextId(); k.recurse(a, b); l.push(b) }), n = h + "(" + l.join(",") + ")", k.assign(b, n), c(b)) : (h = k.nextId(), g = {}, l =
                [], k.recurse(a.callee, h, g, function () { k.if_(k.notNull(h), function () { k.addEnsureSafeFunction(h); q(a.arguments, function (a) { k.recurse(a, k.nextId(), void 0, function (a) { l.push(k.ensureSafeObject(a)) }) }); g.name ? (k.state.expensiveChecks || k.addEnsureSafeObject(g.context), n = k.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")") : n = h + "(" + l.join(",") + ")"; n = k.ensureSafeObject(n); k.assign(b, n) }, function () { k.assign(b, "undefined") }); c(b) })); break; case s.AssignmentExpression: h = this.nextId(); g = {}; if (!pd(a.left)) throw ca("lval");
                    this.recurse(a.left, void 0, g, function () { k.if_(k.notNull(g.context), function () { k.recurse(a.right, h); k.addEnsureSafeObject(k.member(g.context, g.name, g.computed)); k.addEnsureSafeAssignContext(g.context); n = k.member(g.context, g.name, g.computed) + a.operator + h; k.assign(b, n); c(b || n) }) }, 1); break; case s.ArrayExpression: l = []; q(a.elements, function (a) { k.recurse(a, k.nextId(), void 0, function (a) { l.push(a) }) }); n = "[" + l.join(",") + "]"; this.assign(b, n); c(n); break; case s.ObjectExpression: l = []; q(a.properties, function (a) {
                        k.recurse(a.value,
                        k.nextId(), void 0, function (b) { l.push(k.escape(a.key.type === s.Identifier ? a.key.name : "" + a.key.value) + ":" + b) })
                    }); n = "{" + l.join(",") + "}"; this.assign(b, n); c(n); break; case s.ThisExpression: this.assign(b, "s"); c("s"); break; case s.LocalsExpression: this.assign(b, "l"); c("l"); break; case s.NGValueParameter: this.assign(b, "v"), c("v")
            }
        }, getHasOwnProperty: function (a, b) { var d = a + "." + b, c = this.current().own; c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")")); return c[d] }, assign: function (a, b) {
            if (a) return this.current().body.push(a,
            "=", b, ";"), a
        }, filter: function (a) { this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0)); return this.state.filters[a] }, ifDefined: function (a, b) { return "ifDefined(" + a + "," + this.escape(b) + ")" }, plus: function (a, b) { return "plus(" + a + "," + b + ")" }, return_: function (a) { this.current().body.push("return ", a, ";") }, if_: function (a, b, d) { if (!0 === a) b(); else { var c = this.current().body; c.push("if(", a, "){"); b(); c.push("}"); d && (c.push("else{"), d(), c.push("}")) } }, not: function (a) { return "!(" + a + ")" }, notNull: function (a) {
            return a +
            "!=null"
        }, nonComputedMember: function (a, b) { var d = /[^$_a-zA-Z0-9]/g; return /[$_a-zA-Z][$_a-zA-Z0-9]*/.test(b) ? a + "." + b : a + '["' + b.replace(d, this.stringEscapeFn) + '"]' }, computedMember: function (a, b) { return a + "[" + b + "]" }, member: function (a, b, d) { return d ? this.computedMember(a, b) : this.nonComputedMember(a, b) }, addEnsureSafeObject: function (a) { this.current().body.push(this.ensureSafeObject(a), ";") }, addEnsureSafeMemberName: function (a) { this.current().body.push(this.ensureSafeMemberName(a), ";") }, addEnsureSafeFunction: function (a) {
            this.current().body.push(this.ensureSafeFunction(a),
            ";")
        }, addEnsureSafeAssignContext: function (a) { this.current().body.push(this.ensureSafeAssignContext(a), ";") }, ensureSafeObject: function (a) { return "ensureSafeObject(" + a + ",text)" }, ensureSafeMemberName: function (a) { return "ensureSafeMemberName(" + a + ",text)" }, ensureSafeFunction: function (a) { return "ensureSafeFunction(" + a + ",text)" }, getStringValue: function (a) { this.assign(a, "getStringValue(" + a + ")") }, ensureSafeAssignContext: function (a) { return "ensureSafeAssignContext(" + a + ",text)" }, lazyRecurse: function (a, b, d, c, e, f) {
            var g =
            this; return function () { g.recurse(a, b, d, c, e, f) }
        }, lazyAssign: function (a, b) { var d = this; return function () { d.assign(a, b) } }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (a) { return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4) }, escape: function (a) { if (F(a)) return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'"; if (Q(a)) return a.toString(); if (!0 === a) return "true"; if (!1 === a) return "false"; if (null === a) return "null"; if ("undefined" === typeof a) return "undefined"; throw ca("esc"); }, nextId: function (a,
        b) { var d = "v" + this.state.nextId++; a || this.current().vars.push(d + (b ? "=" + b : "")); return d }, current: function () { return this.state[this.state.computing] }
    }; td.prototype = {
        compile: function (a, b) {
            var d = this, c = this.astBuilder.ast(a); this.expression = a; this.expensiveChecks = b; aa(c, d.$filter); var e, f; if (e = qd(c)) f = this.recurse(e); e = od(c.body); var g; e && (g = [], q(e, function (a, b) { var c = d.recurse(a); a.input = c; g.push(c); a.watchId = b })); var h = []; q(c.body, function (a) { h.push(d.recurse(a.expression)) }); e = 0 === c.body.length ? C : 1 ===
            c.body.length ? h[0] : function (a, b) { var c; q(h, function (d) { c = d(a, b) }); return c }; f && (e.assign = function (a, b, c) { return f(a, c, b) }); g && (e.inputs = g); e.literal = rd(c); e.constant = c.constant; return e
        }, recurse: function (a, b, d) {
            var c, e, f = this, g; if (a.input) return this.inputs(a.input, a.watchId); switch (a.type) {
                case s.Literal: return this.value(a.value, b); case s.UnaryExpression: return e = this.recurse(a.argument), this["unary" + a.operator](e, b); case s.BinaryExpression: return c = this.recurse(a.left), e = this.recurse(a.right),
                this["binary" + a.operator](c, e, b); case s.LogicalExpression: return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b); case s.ConditionalExpression: return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b); case s.Identifier: return Ta(a.name, f.expression), f.identifier(a.name, f.expensiveChecks || Hb(a.name), b, d, f.expression); case s.MemberExpression: return c = this.recurse(a.object, !1, !!d), a.computed || (Ta(a.property.name, f.expression),
                e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d, f.expression) : this.nonComputedMember(c, e, f.expensiveChecks, b, d, f.expression); case s.CallExpression: return g = [], q(a.arguments, function (a) { g.push(f.recurse(a)) }), a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), a.filter ? function (a, c, d, f) { for (var m = [], r = 0; r < g.length; ++r) m.push(g[r](a, c, d, f)); a = e.apply(void 0, m, f); return b ? { context: void 0, name: void 0, value: a } : a } : function (a,
                c, d, n) { var m = e(a, c, d, n), r; if (null != m.value) { sa(m.context, f.expression); md(m.value, f.expression); r = []; for (var q = 0; q < g.length; ++q) r.push(sa(g[q](a, c, d, n), f.expression)); r = sa(m.value.apply(m.context, r), f.expression) } return b ? { value: r } : r }; case s.AssignmentExpression: return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function (a, d, g, n) { var m = c(a, d, g, n); a = e(a, d, g, n); sa(m.value, f.expression); Gb(m.context); m.context[m.name] = a; return b ? { value: a } : a }; case s.ArrayExpression: return g = [], q(a.elements, function (a) { g.push(f.recurse(a)) }),
                function (a, c, d, e) { for (var f = [], r = 0; r < g.length; ++r) f.push(g[r](a, c, d, e)); return b ? { value: f } : f }; case s.ObjectExpression: return g = [], q(a.properties, function (a) { g.push({ key: a.key.type === s.Identifier ? a.key.name : "" + a.key.value, value: f.recurse(a.value) }) }), function (a, c, d, e) { for (var f = {}, r = 0; r < g.length; ++r) f[g[r].key] = g[r].value(a, c, d, e); return b ? { value: f } : f }; case s.ThisExpression: return function (a) { return b ? { value: a } : a }; case s.LocalsExpression: return function (a, c) { return b ? { value: c } : c }; case s.NGValueParameter: return function (a,
                c, d) { return b ? { value: d } : d }
            }
        }, "unary+": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = x(d) ? +d : 0; return b ? { value: d } : d } }, "unary-": function (a, b) { return function (d, c, e, f) { d = a(d, c, e, f); d = x(d) ? -d : 0; return b ? { value: d } : d } }, "unary!": function (a, b) { return function (d, c, e, f) { d = !a(d, c, e, f); return b ? { value: d } : d } }, "binary+": function (a, b, d) { return function (c, e, f, g) { var h = a(c, e, f, g); c = b(c, e, f, g); h = nd(h, c); return d ? { value: h } : h } }, "binary-": function (a, b, d) {
            return function (c, e, f, g) {
                var h = a(c, e, f, g); c = b(c, e, f, g);
                h = (x(h) ? h : 0) - (x(c) ? c : 0); return d ? { value: h } : h
            }
        }, "binary*": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) * b(c, e, f, g); return d ? { value: c } : c } }, "binary/": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) / b(c, e, f, g); return d ? { value: c } : c } }, "binary%": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) % b(c, e, f, g); return d ? { value: c } : c } }, "binary===": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) === b(c, e, f, g); return d ? { value: c } : c } }, "binary!==": function (a, b, d) {
            return function (c, e, f, g) {
                c = a(c,
                e, f, g) !== b(c, e, f, g); return d ? { value: c } : c
            }
        }, "binary==": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) == b(c, e, f, g); return d ? { value: c } : c } }, "binary!=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) != b(c, e, f, g); return d ? { value: c } : c } }, "binary<": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) < b(c, e, f, g); return d ? { value: c } : c } }, "binary>": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) > b(c, e, f, g); return d ? { value: c } : c } }, "binary<=": function (a, b, d) {
            return function (c, e, f, g) {
                c = a(c, e, f,
                g) <= b(c, e, f, g); return d ? { value: c } : c
            }
        }, "binary>=": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) >= b(c, e, f, g); return d ? { value: c } : c } }, "binary&&": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) && b(c, e, f, g); return d ? { value: c } : c } }, "binary||": function (a, b, d) { return function (c, e, f, g) { c = a(c, e, f, g) || b(c, e, f, g); return d ? { value: c } : c } }, "ternary?:": function (a, b, d, c) { return function (e, f, g, h) { e = a(e, f, g, h) ? b(e, f, g, h) : d(e, f, g, h); return c ? { value: e } : e } }, value: function (a, b) {
            return function () {
                return b ? {
                    context: void 0,
                    name: void 0, value: a
                } : a
            }
        }, identifier: function (a, b, d, c, e) { return function (f, g, h, k) { f = g && a in g ? g : f; c && 1 !== c && f && !f[a] && (f[a] = {}); g = f ? f[a] : void 0; b && sa(g, e); return d ? { context: f, name: a, value: g } : g } }, computedMember: function (a, b, d, c, e) { return function (f, g, h, k) { var l = a(f, g, h, k), n, m; null != l && (n = b(f, g, h, k), n += "", Ta(n, e), c && 1 !== c && (Gb(l), l && !l[n] && (l[n] = {})), m = l[n], sa(m, e)); return d ? { context: l, name: n, value: m } : m } }, nonComputedMember: function (a, b, d, c, e, f) {
            return function (g, h, k, l) {
                g = a(g, h, k, l); e && 1 !== e && (Gb(g),
                g && !g[b] && (g[b] = {})); h = null != g ? g[b] : void 0; (d || Hb(b)) && sa(h, f); return c ? { context: g, name: b, value: h } : h
            }
        }, inputs: function (a, b) { return function (d, c, e, f) { return f ? f[b] : a(d, c, e) } }
    }; var hc = function (a, b, d) { this.lexer = a; this.$filter = b; this.options = d; this.ast = new s(a, d); this.astCompiler = d.csp ? new td(this.ast, b) : new sd(this.ast, b) }; hc.prototype = { constructor: hc, parse: function (a) { return this.astCompiler.compile(a, this.options.expensiveChecks) } }; var kg = Object.prototype.valueOf, ta = O("$sce"), oa = {
        HTML: "html", CSS: "css",
        URL: "url", RESOURCE_URL: "resourceUrl", JS: "js"
    }, mg = O("$compile"), Y = v.document.createElement("a"), xd = ra(v.location.href); yd.$inject = ["$document"]; Jc.$inject = ["$provide"]; var Fd = 22, Ed = ".", jc = "0"; zd.$inject = ["$locale"]; Bd.$inject = ["$locale"]; var xg = {
        yyyy: W("FullYear", 4, 0, !1, !0), yy: W("FullYear", 2, 0, !0, !0), y: W("FullYear", 1, 0, !1, !0), MMMM: ib("Month"), MMM: ib("Month", !0), MM: W("Month", 2, 1), M: W("Month", 1, 1), LLLL: ib("Month", !1, !0), dd: W("Date", 2), d: W("Date", 1), HH: W("Hours", 2), H: W("Hours", 1), hh: W("Hours", 2, -12),
        h: W("Hours", 1, -12), mm: W("Minutes", 2), m: W("Minutes", 1), ss: W("Seconds", 2), s: W("Seconds", 1), sss: W("Milliseconds", 3), EEEE: ib("Day"), EEE: ib("Day", !0), a: function (a, b) { return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1] }, Z: function (a, b, d) { a = -1 * d; return a = (0 <= a ? "+" : "") + (Ib(Math[0 < a ? "floor" : "ceil"](a / 60), 2) + Ib(Math.abs(a % 60), 2)) }, ww: Hd(2), w: Hd(1), G: kc, GG: kc, GGG: kc, GGGG: function (a, b) { return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1] }
    }, wg = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
    vg = /^\-?\d+$/; Ad.$inject = ["$locale"]; var qg = da(P), rg = da(sb); Cd.$inject = ["$parse"]; var ne = da({ restrict: "E", compile: function (a, b) { if (!b.href && !b.xlinkHref) return function (a, b) { if ("a" === b[0].nodeName.toLowerCase()) { var e = "[object SVGAnimatedString]" === ma.call(b.prop("href")) ? "xlink:href" : "href"; b.on("click", function (a) { b.attr(e) || a.preventDefault() }) } } } }), tb = {}; q(Cb, function (a, b) {
        function d(a, d, e) { a.$watch(e[c], function (a) { e.$set(b, !!a) }) } if ("multiple" != a) {
            var c = xa("ng-" + b), e = d; "checked" === a && (e = function (a,
            b, e) { e.ngModel !== e[c] && d(a, b, e) }); tb[c] = function () { return { restrict: "A", priority: 100, link: e } }
        }
    }); q(ad, function (a, b) { tb[b] = function () { return { priority: 100, link: function (a, c, e) { if ("ngPattern" === b && "/" == e.ngPattern.charAt(0) && (c = e.ngPattern.match(zg))) { e.$set("ngPattern", new RegExp(c[1], c[2])); return } a.$watch(e[b], function (a) { e.$set(b, a) }) } } } }); q(["src", "srcset", "href"], function (a) {
        var b = xa("ng-" + a); tb[b] = function () {
            return {
                priority: 99, link: function (d, c, e) {
                    var f = a, g = a; "href" === a && "[object SVGAnimatedString]" ===
                    ma.call(c.prop("href")) && (g = "xlinkHref", e.$attr[g] = "xlink:href", f = null); e.$observe(b, function (b) { b ? (e.$set(g, b), Ca && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null) })
                }
            }
        }
    }); var Jb = { $addControl: C, $$renameControl: function (a, b) { a.$name = b }, $removeControl: C, $setValidity: C, $setDirty: C, $setPristine: C, $setSubmitted: C }; Id.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"]; var Rd = function (a) {
        return ["$timeout", "$parse", function (b, d) {
            function c(a) { return "" === a ? d('this[""]').assign : d(a).assign || C } return {
                name: "form",
                restrict: a ? "EAC" : "E", require: ["form", "^^?form"], controller: Id, compile: function (d, f) {
                    d.addClass(Ua).addClass(mb); var g = f.name ? "name" : a && f.ngForm ? "ngForm" : !1; return {
                        pre: function (a, d, e, f) {
                            var m = f[0]; if (!("action" in e)) { var r = function (b) { a.$apply(function () { m.$commitViewValue(); m.$setSubmitted() }); b.preventDefault() }; d[0].addEventListener("submit", r, !1); d.on("$destroy", function () { b(function () { d[0].removeEventListener("submit", r, !1) }, 0, !1) }) } (f[1] || m.$$parentForm).$addControl(m); var q = g ? c(m.$name) : C; g &&
                            (q(a, m), e.$observe(g, function (b) { m.$name !== b && (q(a, void 0), m.$$parentForm.$$renameControl(m, b), q = c(m.$name), q(a, m)) })); d.on("$destroy", function () { m.$$parentForm.$removeControl(m); q(a, void 0); R(m, Jb) })
                        }
                    }
                }
            }
        }]
    }, oe = Rd(), Be = Rd(!0), yg = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, Hg = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, Ig = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,
    Jg = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, Sd = /^(\d{4,})-(\d{2})-(\d{2})$/, Td = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, nc = /^(\d{4,})-W(\d\d)$/, Ud = /^(\d{4,})-(\d\d)$/, Vd = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Kd = T(); q(["date", "datetime-local", "month", "time", "week"], function (a) { Kd[a] = !0 }); var Wd = {
        text: function (a, b, d, c, e, f) { jb(a, b, d, c, e, f); lc(c) }, date: kb("date", Sd, Lb(Sd, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"), "datetime-local": kb("datetimelocal", Td, Lb(Td, "yyyy MM dd HH mm ss sss".split(" ")),
        "yyyy-MM-ddTHH:mm:ss.sss"), time: kb("time", Vd, Lb(Vd, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"), week: kb("week", nc, function (a, b) { if (fa(a)) return a; if (F(a)) { nc.lastIndex = 0; var d = nc.exec(a); if (d) { var c = +d[1], e = +d[2], f = d = 0, g = 0, h = 0, k = Gd(c), e = 7 * (e - 1); b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), h = b.getMilliseconds()); return new Date(c, 0, k.getDate() + e, d, f, g, h) } } return NaN }, "yyyy-Www"), month: kb("month", Ud, Lb(Ud, ["yyyy", "MM"]), "yyyy-MM"), number: function (a, b, d, c, e, f) {
            Ld(a, b, d, c); jb(a, b, d, c, e, f); c.$$parserName =
            "number"; c.$parsers.push(function (a) { if (c.$isEmpty(a)) return null; if (Jg.test(a)) return parseFloat(a) }); c.$formatters.push(function (a) { if (!c.$isEmpty(a)) { if (!Q(a)) throw lb("numfmt", a); a = a.toString() } return a }); if (x(d.min) || d.ngMin) { var g; c.$validators.min = function (a) { return c.$isEmpty(a) || y(g) || a >= g }; d.$observe("min", function (a) { x(a) && !Q(a) && (a = parseFloat(a, 10)); g = Q(a) && !isNaN(a) ? a : void 0; c.$validate() }) } if (x(d.max) || d.ngMax) {
                var h; c.$validators.max = function (a) { return c.$isEmpty(a) || y(h) || a <= h }; d.$observe("max",
                function (a) { x(a) && !Q(a) && (a = parseFloat(a, 10)); h = Q(a) && !isNaN(a) ? a : void 0; c.$validate() })
            }
        }, url: function (a, b, d, c, e, f) { jb(a, b, d, c, e, f); lc(c); c.$$parserName = "url"; c.$validators.url = function (a, b) { var d = a || b; return c.$isEmpty(d) || Hg.test(d) } }, email: function (a, b, d, c, e, f) { jb(a, b, d, c, e, f); lc(c); c.$$parserName = "email"; c.$validators.email = function (a, b) { var d = a || b; return c.$isEmpty(d) || Ig.test(d) } }, radio: function (a, b, d, c) {
            y(d.name) && b.attr("name", ++nb); b.on("click", function (a) {
                b[0].checked && c.$setViewValue(d.value,
                a && a.type)
            }); c.$render = function () { b[0].checked = d.value == c.$viewValue }; d.$observe("value", c.$render)
        }, checkbox: function (a, b, d, c, e, f, g, h) { var k = Md(h, a, "ngTrueValue", d.ngTrueValue, !0), l = Md(h, a, "ngFalseValue", d.ngFalseValue, !1); b.on("click", function (a) { c.$setViewValue(b[0].checked, a && a.type) }); c.$render = function () { b[0].checked = c.$viewValue }; c.$isEmpty = function (a) { return !1 === a }; c.$formatters.push(function (a) { return pa(a, k) }); c.$parsers.push(function (a) { return a ? k : l }) }, hidden: C, button: C, submit: C, reset: C,
        file: C
    }, Dc = ["$browser", "$sniffer", "$filter", "$parse", function (a, b, d, c) { return { restrict: "E", require: ["?ngModel"], link: { pre: function (e, f, g, h) { h[0] && (Wd[P(g.type)] || Wd.text)(e, f, g, h[0], b, a, d, c) } } } }], Kg = /^(true|false|\d+)$/, Te = function () { return { restrict: "A", priority: 100, compile: function (a, b) { return Kg.test(b.ngValue) ? function (a, b, e) { e.$set("value", a.$eval(e.ngValue)) } : function (a, b, e) { a.$watch(e.ngValue, function (a) { e.$set("value", a) }) } } } }, te = ["$compile", function (a) {
        return {
            restrict: "AC", compile: function (b) {
                a.$$addBindingClass(b);
                return function (b, c, e) { a.$$addBindingInfo(c, e.ngBind); c = c[0]; b.$watch(e.ngBind, function (a) { c.textContent = y(a) ? "" : a }) }
            }
        }
    }], ve = ["$interpolate", "$compile", function (a, b) { return { compile: function (d) { b.$$addBindingClass(d); return function (c, d, f) { c = a(d.attr(f.$attr.ngBindTemplate)); b.$$addBindingInfo(d, c.expressions); d = d[0]; f.$observe("ngBindTemplate", function (a) { d.textContent = y(a) ? "" : a }) } } } }], ue = ["$sce", "$parse", "$compile", function (a, b, d) {
        return {
            restrict: "A", compile: function (c, e) {
                var f = b(e.ngBindHtml), g =
                b(e.ngBindHtml, function (a) { return (a || "").toString() }); d.$$addBindingClass(c); return function (b, c, e) { d.$$addBindingInfo(c, e.ngBindHtml); b.$watch(g, function () { c.html(a.getTrustedHtml(f(b)) || "") }) }
            }
        }
    }], Se = da({ restrict: "A", require: "ngModel", link: function (a, b, d, c) { c.$viewChangeListeners.push(function () { a.$eval(d.ngChange) }) } }), we = mc("", !0), ye = mc("Odd", 0), xe = mc("Even", 1), ze = La({ compile: function (a, b) { b.$set("ngCloak", void 0); a.removeClass("ng-cloak") } }), Ae = [function () {
        return {
            restrict: "A", scope: !0, controller: "@",
            priority: 500
        }
    }], Ic = {}, Lg = { blur: !0, focus: !0 }; q("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (a) { var b = xa("ng-" + a); Ic[b] = ["$parse", "$rootScope", function (d, c) { return { restrict: "A", compile: function (e, f) { var g = d(f[b], null, !0); return function (b, d) { d.on(a, function (d) { var e = function () { g(b, { $event: d }) }; Lg[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e) }) } } } }] }); var De = ["$animate", "$compile", function (a,
    b) { return { multiElement: !0, transclude: "element", priority: 600, terminal: !0, restrict: "A", $$tlb: !0, link: function (d, c, e, f, g) { var h, k, l; d.$watch(e.ngIf, function (d) { d ? k || g(function (d, f) { k = f; d[d.length++] = b.$$createComment("end ngIf", e.ngIf); h = { clone: d }; a.enter(d, c.parent(), c) }) : (l && (l.remove(), l = null), k && (k.$destroy(), k = null), h && (l = rb(h.clone), a.leave(l).then(function () { l = null }), h = null)) }) } } }], Ee = ["$templateRequest", "$anchorScroll", "$animate", function (a, b, d) {
        return {
            restrict: "ECA", priority: 400, terminal: !0,
            transclude: "element", controller: ea.noop, compile: function (c, e) {
                var f = e.ngInclude || e.src, g = e.onload || "", h = e.autoscroll; return function (c, e, n, m, r) {
                    var q = 0, s, w, p, y = function () { w && (w.remove(), w = null); s && (s.$destroy(), s = null); p && (d.leave(p).then(function () { w = null }), w = p, p = null) }; c.$watch(f, function (f) {
                        var n = function () { !x(h) || h && !c.$eval(h) || b() }, u = ++q; f ? (a(f, !0).then(function (a) {
                            if (!c.$$destroyed && u === q) {
                                var b = c.$new(); m.template = a; a = r(b, function (a) { y(); d.enter(a, null, e).then(n) }); s = b; p = a; s.$emit("$includeContentLoaded",
                                f); c.$eval(g)
                            }
                        }, function () { c.$$destroyed || u !== q || (y(), c.$emit("$includeContentError", f)) }), c.$emit("$includeContentRequested", f)) : (y(), m.template = null)
                    })
                }
            }
        }
    }], Ve = ["$compile", function (a) { return { restrict: "ECA", priority: -400, require: "ngInclude", link: function (b, d, c, e) { ma.call(d[0]).match(/SVG/) ? (d.empty(), a(Lc(e.template, v.document).childNodes)(b, function (a) { d.append(a) }, { futureParentElement: d })) : (d.html(e.template), a(d.contents())(b)) } } }], Fe = La({
        priority: 450, compile: function () {
            return {
                pre: function (a,
                b, d) { a.$eval(d.ngInit) }
            }
        }
    }), Re = function () { return { restrict: "A", priority: 100, require: "ngModel", link: function (a, b, d, c) { var e = b.attr(d.$attr.ngList) || ", ", f = "false" !== d.ngTrim, g = f ? V(e) : e; c.$parsers.push(function (a) { if (!y(a)) { var b = []; a && q(a.split(g), function (a) { a && b.push(f ? V(a) : a) }); return b } }); c.$formatters.push(function (a) { if (K(a)) return a.join(e) }); c.$isEmpty = function (a) { return !a || !a.length } } } }, mb = "ng-valid", Nd = "ng-invalid", Ua = "ng-pristine", Kb = "ng-dirty", Pd = "ng-pending", lb = O("ngModel"), Mg = ["$scope",
    "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function (a, b, d, c, e, f, g, h, k, l) {
        this.$modelValue = this.$viewValue = Number.NaN; this.$$rawModelValue = void 0; this.$validators = {}; this.$asyncValidators = {}; this.$parsers = []; this.$formatters = []; this.$viewChangeListeners = []; this.$untouched = !0; this.$touched = !1; this.$pristine = !0; this.$dirty = !1; this.$valid = !0; this.$invalid = !1; this.$error = {}; this.$$success = {}; this.$pending = void 0; this.$name = l(d.name || "", !1)(a);
        this.$$parentForm = Jb; var n = e(d.ngModel), m = n.assign, r = n, s = m, v = null, w, p = this; this.$$setOptions = function (a) { if ((p.$options = a) && a.getterSetter) { var b = e(d.ngModel + "()"), f = e(d.ngModel + "($$$p)"); r = function (a) { var c = n(a); E(c) && (c = b(a)); return c }; s = function (a, b) { E(n(a)) ? f(a, { $$$p: b }) : m(a, b) } } else if (!n.assign) throw lb("nonassign", d.ngModel, wa(c)); }; this.$render = C; this.$isEmpty = function (a) { return y(a) || "" === a || null === a || a !== a }; this.$$updateEmptyClasses = function (a) {
            p.$isEmpty(a) ? (f.removeClass(c, "ng-not-empty"),
            f.addClass(c, "ng-empty")) : (f.removeClass(c, "ng-empty"), f.addClass(c, "ng-not-empty"))
        }; var H = 0; Jd({ ctrl: this, $element: c, set: function (a, b) { a[b] = !0 }, unset: function (a, b) { delete a[b] }, $animate: f }); this.$setPristine = function () { p.$dirty = !1; p.$pristine = !0; f.removeClass(c, Kb); f.addClass(c, Ua) }; this.$setDirty = function () { p.$dirty = !0; p.$pristine = !1; f.removeClass(c, Ua); f.addClass(c, Kb); p.$$parentForm.$setDirty() }; this.$setUntouched = function () { p.$touched = !1; p.$untouched = !0; f.setClass(c, "ng-untouched", "ng-touched") };
        this.$setTouched = function () { p.$touched = !0; p.$untouched = !1; f.setClass(c, "ng-touched", "ng-untouched") }; this.$rollbackViewValue = function () { g.cancel(v); p.$viewValue = p.$$lastCommittedViewValue; p.$render() }; this.$validate = function () { if (!Q(p.$modelValue) || !isNaN(p.$modelValue)) { var a = p.$$rawModelValue, b = p.$valid, c = p.$modelValue, d = p.$options && p.$options.allowInvalid; p.$$runValidators(a, p.$$lastCommittedViewValue, function (e) { d || b === e || (p.$modelValue = e ? a : void 0, p.$modelValue !== c && p.$$writeModelToScope()) }) } };
        this.$$runValidators = function (a, b, c) {
            function d() { var c = !0; q(p.$validators, function (d, e) { var g = d(a, b); c = c && g; f(e, g) }); return c ? !0 : (q(p.$asyncValidators, function (a, b) { f(b, null) }), !1) } function e() { var c = [], d = !0; q(p.$asyncValidators, function (e, g) { var h = e(a, b); if (!h || !E(h.then)) throw lb("nopromise", h); f(g, void 0); c.push(h.then(function () { f(g, !0) }, function () { d = !1; f(g, !1) })) }); c.length ? k.all(c).then(function () { g(d) }, C) : g(!0) } function f(a, b) { h === H && p.$setValidity(a, b) } function g(a) { h === H && c(a) } H++; var h =
            H; (function () { var a = p.$$parserName || "parse"; if (y(w)) f(a, null); else return w || (q(p.$validators, function (a, b) { f(b, null) }), q(p.$asyncValidators, function (a, b) { f(b, null) })), f(a, w), w; return !0 })() ? d() ? e() : g(!1) : g(!1)
        }; this.$commitViewValue = function () { var a = p.$viewValue; g.cancel(v); if (p.$$lastCommittedViewValue !== a || "" === a && p.$$hasNativeValidators) p.$$updateEmptyClasses(a), p.$$lastCommittedViewValue = a, p.$pristine && this.$setDirty(), this.$$parseAndValidate() }; this.$$parseAndValidate = function () {
            var b = p.$$lastCommittedViewValue;
            if (w = y(b) ? void 0 : !0) for (var c = 0; c < p.$parsers.length; c++) if (b = p.$parsers[c](b), y(b)) { w = !1; break } Q(p.$modelValue) && isNaN(p.$modelValue) && (p.$modelValue = r(a)); var d = p.$modelValue, e = p.$options && p.$options.allowInvalid; p.$$rawModelValue = b; e && (p.$modelValue = b, p.$modelValue !== d && p.$$writeModelToScope()); p.$$runValidators(b, p.$$lastCommittedViewValue, function (a) { e || (p.$modelValue = a ? b : void 0, p.$modelValue !== d && p.$$writeModelToScope()) })
        }; this.$$writeModelToScope = function () {
            s(a, p.$modelValue); q(p.$viewChangeListeners,
            function (a) { try { a() } catch (c) { b(c) } })
        }; this.$setViewValue = function (a, b) { p.$viewValue = a; p.$options && !p.$options.updateOnDefault || p.$$debounceViewValueCommit(b) }; this.$$debounceViewValueCommit = function (b) { var c = 0, d = p.$options; d && x(d.debounce) && (d = d.debounce, Q(d) ? c = d : Q(d[b]) ? c = d[b] : Q(d["default"]) && (c = d["default"])); g.cancel(v); c ? v = g(function () { p.$commitViewValue() }, c) : h.$$phase ? p.$commitViewValue() : a.$apply(function () { p.$commitViewValue() }) }; a.$watch(function () {
            var b = r(a); if (b !== p.$modelValue && (p.$modelValue ===
            p.$modelValue || b === b)) { p.$modelValue = p.$$rawModelValue = b; w = void 0; for (var c = p.$formatters, d = c.length, e = b; d--;) e = c[d](e); p.$viewValue !== e && (p.$$updateEmptyClasses(e), p.$viewValue = p.$$lastCommittedViewValue = e, p.$render(), p.$$runValidators(b, e, C)) } return b
        })
    }], Qe = ["$rootScope", function (a) {
        return {
            restrict: "A", require: ["ngModel", "^?form", "^?ngModelOptions"], controller: Mg, priority: 1, compile: function (b) {
                b.addClass(Ua).addClass("ng-untouched").addClass(mb); return {
                    pre: function (a, b, e, f) {
                        var g = f[0]; b = f[1] ||
                        g.$$parentForm; g.$$setOptions(f[2] && f[2].$options); b.$addControl(g); e.$observe("name", function (a) { g.$name !== a && g.$$parentForm.$$renameControl(g, a) }); a.$on("$destroy", function () { g.$$parentForm.$removeControl(g) })
                    }, post: function (b, c, e, f) { var g = f[0]; if (g.$options && g.$options.updateOn) c.on(g.$options.updateOn, function (a) { g.$$debounceViewValueCommit(a && a.type) }); c.on("blur", function () { g.$touched || (a.$$phase ? b.$evalAsync(g.$setTouched) : b.$apply(g.$setTouched)) }) }
                }
            }
        }
    }], Ng = /(\s+|^)default(\s+|$)/, Ue = function () {
        return {
            restrict: "A",
            controller: ["$scope", "$attrs", function (a, b) { var d = this; this.$options = qa(a.$eval(b.ngModelOptions)); x(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, this.$options.updateOn = V(this.$options.updateOn.replace(Ng, function () { d.$options.updateOnDefault = !0; return " " }))) : this.$options.updateOnDefault = !0 }]
        }
    }, Ge = La({ terminal: !0, priority: 1E3 }), Og = O("ngOptions"), Pg = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
    Oe = ["$compile", "$document", "$parse", function (a, b, d) {
        function c(a, b, c) {
            function e(a, b, c, d, f) { this.selectValue = a; this.viewValue = b; this.label = c; this.group = d; this.disabled = f } function f(a) { var b; if (!q && ya(a)) b = a; else { b = []; for (var c in a) a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c) } return b } var m = a.match(Pg); if (!m) throw Og("iexp", a, wa(b)); var r = m[5] || m[7], q = m[6]; a = / as /.test(m[0]) && m[1]; var s = m[9]; b = d(m[2] ? m[1] : r); var w = a && d(a) || b, p = s && d(s), v = s ? function (a, b) { return p(c, b) } : function (a) { return Fa(a) },
            t = function (a, b) { return v(a, L(a, b)) }, z = d(m[2] || m[1]), u = d(m[3] || ""), y = d(m[4] || ""), x = d(m[8]), D = {}, L = q ? function (a, b) { D[q] = b; D[r] = a; return D } : function (a) { D[r] = a; return D }; return {
                trackBy: s, getTrackByValue: t, getWatchables: d(x, function (a) { var b = []; a = a || []; for (var d = f(a), e = d.length, g = 0; g < e; g++) { var h = a === d ? g : d[g], l = a[h], h = L(l, h), l = v(l, h); b.push(l); if (m[2] || m[1]) l = z(c, h), b.push(l); m[4] && (h = y(c, h), b.push(h)) } return b }), getOptions: function () {
                    for (var a = [], b = {}, d = x(c) || [], g = f(d), h = g.length, m = 0; m < h; m++) {
                        var p = d ===
                        g ? m : g[m], q = L(d[p], p), r = w(c, q), p = v(r, q), D = z(c, q), N = u(c, q), q = y(c, q), r = new e(p, r, D, N, q); a.push(r); b[p] = r
                    } return { items: a, selectValueMap: b, getOptionFromViewValue: function (a) { return b[t(a)] }, getViewValueFromOption: function (a) { return s ? ea.copy(a.viewValue) : a.viewValue } }
                }
            }
        } var e = v.document.createElement("option"), f = v.document.createElement("optgroup"); return {
            restrict: "A", terminal: !0, require: ["select", "ngModel"], link: {
                pre: function (a, b, c, d) { d[0].registerOption = C }, post: function (d, h, k, l) {
                    function n(a, b) {
                        a.element =
                        b; b.disabled = a.disabled; a.label !== b.label && (b.label = a.label, b.textContent = a.label); a.value !== b.value && (b.value = a.selectValue)
                    } function m() {
                        var a = u && r.readValue(); if (u) for (var b = u.items.length - 1; 0 <= b; b--) { var c = u.items[b]; c.group ? Bb(c.element.parentNode) : Bb(c.element) } u = I.getOptions(); var d = {}; t && h.prepend(w); u.items.forEach(function (a) {
                            var b; if (x(a.group)) { b = d[a.group]; b || (b = f.cloneNode(!1), E.appendChild(b), b.label = a.group, d[a.group] = b); var c = e.cloneNode(!1) } else b = E, c = e.cloneNode(!1); b.appendChild(c);
                            n(a, c)
                        }); h[0].appendChild(E); s.$render(); s.$isEmpty(a) || (b = r.readValue(), (I.trackBy || v ? pa(a, b) : a === b) || (s.$setViewValue(b), s.$render()))
                    } var r = l[0], s = l[1], v = k.multiple, w; l = 0; for (var p = h.children(), y = p.length; l < y; l++) if ("" === p[l].value) { w = p.eq(l); break } var t = !!w, z = B(e.cloneNode(!1)); z.val("?"); var u, I = c(k.ngOptions, h, d), E = b[0].createDocumentFragment(); v ? (s.$isEmpty = function (a) { return !a || 0 === a.length }, r.writeValue = function (a) {
                        u.items.forEach(function (a) { a.element.selected = !1 }); a && a.forEach(function (a) {
                            if (a =
                            u.getOptionFromViewValue(a)) a.element.selected = !0
                        })
                    }, r.readValue = function () { var a = h.val() || [], b = []; q(a, function (a) { (a = u.selectValueMap[a]) && !a.disabled && b.push(u.getViewValueFromOption(a)) }); return b }, I.trackBy && d.$watchCollection(function () { if (K(s.$viewValue)) return s.$viewValue.map(function (a) { return I.getTrackByValue(a) }) }, function () { s.$render() })) : (r.writeValue = function (a) {
                        var b = u.getOptionFromViewValue(a); b ? (h[0].value !== b.selectValue && (z.remove(), t || w.remove(), h[0].value = b.selectValue, b.element.selected =
                        !0), b.element.setAttribute("selected", "selected")) : null === a || t ? (z.remove(), t || h.prepend(w), h.val(""), w.prop("selected", !0), w.attr("selected", !0)) : (t || w.remove(), h.prepend(z), h.val("?"), z.prop("selected", !0), z.attr("selected", !0))
                    }, r.readValue = function () { var a = u.selectValueMap[h.val()]; return a && !a.disabled ? (t || w.remove(), z.remove(), u.getViewValueFromOption(a)) : null }, I.trackBy && d.$watch(function () { return I.getTrackByValue(s.$viewValue) }, function () { s.$render() })); t ? (w.remove(), a(w)(d), w.removeClass("ng-scope")) :
                    w = B(e.cloneNode(!1)); h.empty(); m(); d.$watchCollection(I.getWatchables, m)
                }
            }
        }
    }], He = ["$locale", "$interpolate", "$log", function (a, b, d) {
        var c = /{}/g, e = /^when(Minus)?(.+)$/; return {
            link: function (f, g, h) {
                function k(a) { g.text(a || "") } var l = h.count, n = h.$attr.when && g.attr(h.$attr.when), m = h.offset || 0, r = f.$eval(n) || {}, s = {}, v = b.startSymbol(), w = b.endSymbol(), p = v + l + "-" + m + w, x = ea.noop, t; q(h, function (a, b) { var c = e.exec(b); c && (c = (c[1] ? "-" : "") + P(c[2]), r[c] = g.attr(h.$attr[b])) }); q(r, function (a, d) { s[d] = b(a.replace(c, p)) }); f.$watch(l,
                function (b) { var c = parseFloat(b), e = isNaN(c); e || c in r || (c = a.pluralCat(c - m)); c === t || e && Q(t) && isNaN(t) || (x(), e = s[c], y(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + n), x = C, k()) : x = f.$watch(e, k), t = c) })
            }
        }
    }], Ie = ["$parse", "$animate", "$compile", function (a, b, d) {
        var c = O("ngRepeat"), e = function (a, b, c, d, e, n, m) { a[c] = d; e && (a[e] = n); a.$index = b; a.$first = 0 === b; a.$last = b === m - 1; a.$middle = !(a.$first || a.$last); a.$odd = !(a.$even = 0 === (b & 1)) }; return {
            restrict: "A", multiElement: !0, transclude: "element", priority: 1E3,
            terminal: !0, $$tlb: !0, compile: function (f, g) {
                var h = g.ngRepeat, k = d.$$createComment("end ngRepeat", h), l = h.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/); if (!l) throw c("iexp", h); var n = l[1], m = l[2], r = l[3], s = l[4], l = n.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/); if (!l) throw c("iidexp", n); var v = l[3] || l[1], w = l[2]; if (r && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r))) throw c("badident",
                r); var p, y, t, z, u = { $id: Fa }; s ? p = a(s) : (t = function (a, b) { return Fa(b) }, z = function (a) { return a }); return function (a, d, f, g, l) {
                    p && (y = function (b, c, d) { w && (u[w] = b); u[v] = c; u.$index = d; return p(a, u) }); var n = T(); a.$watchCollection(m, function (f) {
                        var g, m, p = d[0], s, u = T(), x, D, E, C, F, B, G; r && (a[r] = f); if (ya(f)) F = f, m = y || t; else for (G in m = y || z, F = [], f) ua.call(f, G) && "$" !== G.charAt(0) && F.push(G); x = F.length; G = Array(x); for (g = 0; g < x; g++) if (D = f === F ? g : F[g], E = f[D], C = m(D, E, g), n[C]) B = n[C], delete n[C], u[C] = B, G[g] = B; else {
                            if (u[C]) throw q(G,
                            function (a) { a && a.scope && (n[a.id] = a) }), c("dupes", h, C, E); G[g] = { id: C, scope: void 0, clone: void 0 }; u[C] = !0
                        } for (s in n) { B = n[s]; C = rb(B.clone); b.leave(C); if (C[0].parentNode) for (g = 0, m = C.length; g < m; g++) C[g].$$NG_REMOVED = !0; B.scope.$destroy() } for (g = 0; g < x; g++) if (D = f === F ? g : F[g], E = f[D], B = G[g], B.scope) { s = p; do s = s.nextSibling; while (s && s.$$NG_REMOVED); B.clone[0] != s && b.move(rb(B.clone), null, p); p = B.clone[B.clone.length - 1]; e(B.scope, g, v, E, w, D, x) } else l(function (a, c) {
                            B.scope = c; var d = k.cloneNode(!1); a[a.length++] = d; b.enter(a,
                            null, p); p = d; B.clone = a; u[B.id] = B; e(B.scope, g, v, E, w, D, x)
                        }); n = u
                    })
                }
            }
        }
    }], Je = ["$animate", function (a) { return { restrict: "A", multiElement: !0, link: function (b, d, c) { b.$watch(c.ngShow, function (b) { a[b ? "removeClass" : "addClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) }) } } }], Ce = ["$animate", function (a) { return { restrict: "A", multiElement: !0, link: function (b, d, c) { b.$watch(c.ngHide, function (b) { a[b ? "addClass" : "removeClass"](d, "ng-hide", { tempClasses: "ng-hide-animate" }) }) } } }], Ke = La(function (a, b, d) {
        a.$watch(d.ngStyle, function (a,
        d) { d && a !== d && q(d, function (a, c) { b.css(c, "") }); a && b.css(a) }, !0)
    }), Le = ["$animate", "$compile", function (a, b) {
        return {
            require: "ngSwitch", controller: ["$scope", function () { this.cases = {} }], link: function (d, c, e, f) {
                var g = [], h = [], k = [], l = [], n = function (a, b) { return function () { a.splice(b, 1) } }; d.$watch(e.ngSwitch || e.on, function (c) {
                    var d, e; d = 0; for (e = k.length; d < e; ++d) a.cancel(k[d]); d = k.length = 0; for (e = l.length; d < e; ++d) { var s = rb(h[d].clone); l[d].$destroy(); (k[d] = a.leave(s)).then(n(k, d)) } h.length = 0; l.length = 0; (g = f.cases["!" +
                    c] || f.cases["?"]) && q(g, function (c) { c.transclude(function (d, e) { l.push(e); var f = c.element; d[d.length++] = b.$$createComment("end ngSwitchWhen"); h.push({ clone: d }); a.enter(d, f.parent(), f) }) })
                })
            }
        }
    }], Me = La({ transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a, b, d, c, e) { c.cases["!" + d.ngSwitchWhen] = c.cases["!" + d.ngSwitchWhen] || []; c.cases["!" + d.ngSwitchWhen].push({ transclude: e, element: b }) } }), Ne = La({
        transclude: "element", priority: 1200, require: "^ngSwitch", multiElement: !0, link: function (a,
        b, d, c, e) { c.cases["?"] = c.cases["?"] || []; c.cases["?"].push({ transclude: e, element: b }) }
    }), Qg = O("ngTransclude"), Pe = La({ restrict: "EAC", link: function (a, b, d, c, e) { d.ngTransclude === d.$attr.ngTransclude && (d.ngTransclude = ""); if (!e) throw Qg("orphan", wa(b)); e(function (a) { a.length && (b.empty(), b.append(a)) }, null, d.ngTransclude || d.ngTranscludeSlot) } }), pe = ["$templateCache", function (a) { return { restrict: "E", terminal: !0, compile: function (b, d) { "text/ng-template" == d.type && a.put(d.id, b[0].text) } } }], Rg = { $setViewValue: C, $render: C },
    Sg = ["$element", "$scope", function (a, b) {
        var d = this, c = new Ra; d.ngModelCtrl = Rg; d.unknownOption = B(v.document.createElement("option")); d.renderUnknownOption = function (b) { b = "? " + Fa(b) + " ?"; d.unknownOption.val(b); a.prepend(d.unknownOption); a.val(b) }; b.$on("$destroy", function () { d.renderUnknownOption = C }); d.removeUnknownOption = function () { d.unknownOption.parent() && d.unknownOption.remove() }; d.readValue = function () { d.removeUnknownOption(); return a.val() }; d.writeValue = function (b) {
            d.hasOption(b) ? (d.removeUnknownOption(),
            a.val(b), "" === b && d.emptyOption.prop("selected", !0)) : null == b && d.emptyOption ? (d.removeUnknownOption(), a.val("")) : d.renderUnknownOption(b)
        }; d.addOption = function (a, b) { if (8 !== b[0].nodeType) { Qa(a, '"option value"'); "" === a && (d.emptyOption = b); var g = c.get(a) || 0; c.put(a, g + 1); d.ngModelCtrl.$render(); b[0].hasAttribute("selected") && (b[0].selected = !0) } }; d.removeOption = function (a) { var b = c.get(a); b && (1 === b ? (c.remove(a), "" === a && (d.emptyOption = void 0)) : c.put(a, b - 1)) }; d.hasOption = function (a) { return !!c.get(a) }; d.registerOption =
        function (a, b, c, h, k) { if (h) { var l; c.$observe("value", function (a) { x(l) && d.removeOption(l); l = a; d.addOption(a, b) }) } else k ? a.$watch(k, function (a, e) { c.$set("value", a); e !== a && d.removeOption(e); d.addOption(a, b) }) : d.addOption(c.value, b); b.on("$destroy", function () { d.removeOption(c.value); d.ngModelCtrl.$render() }) }
    }], qe = function () {
        return {
            restrict: "E", require: ["select", "?ngModel"], controller: Sg, priority: 1, link: {
                pre: function (a, b, d, c) {
                    var e = c[1]; if (e) {
                        var f = c[0]; f.ngModelCtrl = e; b.on("change", function () { a.$apply(function () { e.$setViewValue(f.readValue()) }) });
                        if (d.multiple) { f.readValue = function () { var a = []; q(b.find("option"), function (b) { b.selected && a.push(b.value) }); return a }; f.writeValue = function (a) { var c = new Ra(a); q(b.find("option"), function (a) { a.selected = x(c.get(a.value)) }) }; var g, h = NaN; a.$watch(function () { h !== e.$viewValue || pa(g, e.$viewValue) || (g = ha(e.$viewValue), e.$render()); h = e.$viewValue }); e.$isEmpty = function (a) { return !a || 0 === a.length } }
                    }
                }, post: function (a, b, d, c) { var e = c[1]; if (e) { var f = c[0]; e.$render = function () { f.writeValue(e.$viewValue) } } }
            }
        }
    }, se = ["$interpolate",
    function (a) { return { restrict: "E", priority: 100, compile: function (b, d) { if (x(d.value)) var c = a(d.value, !0); else { var e = a(b.text(), !0); e || d.$set("value", b.text()) } return function (a, b, d) { var k = b.parent(); (k = k.data("$selectController") || k.parent().data("$selectController")) && k.registerOption(a, b, d, c, e) } } } }], re = da({ restrict: "E", terminal: !1 }), Fc = function () {
        return {
            restrict: "A", require: "?ngModel", link: function (a, b, d, c) {
                c && (d.required = !0, c.$validators.required = function (a, b) { return !d.required || !c.$isEmpty(b) }, d.$observe("required",
                function () { c.$validate() }))
            }
        }
    }, Ec = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) { var e, f = d.ngPattern || d.pattern; d.$observe("pattern", function (a) { F(a) && 0 < a.length && (a = new RegExp("^" + a + "$")); if (a && !a.test) throw O("ngPattern")("noregexp", f, a, wa(b)); e = a || void 0; c.$validate() }); c.$validators.pattern = function (a, b) { return c.$isEmpty(b) || y(e) || e.test(b) } } } } }, Hc = function () {
        return {
            restrict: "A", require: "?ngModel", link: function (a, b, d, c) {
                if (c) {
                    var e = -1; d.$observe("maxlength", function (a) {
                        a =
                        X(a); e = isNaN(a) ? -1 : a; c.$validate()
                    }); c.$validators.maxlength = function (a, b) { return 0 > e || c.$isEmpty(b) || b.length <= e }
                }
            }
        }
    }, Gc = function () { return { restrict: "A", require: "?ngModel", link: function (a, b, d, c) { if (c) { var e = 0; d.$observe("minlength", function (a) { e = X(a) || 0; c.$validate() }); c.$validators.minlength = function (a, b) { return c.$isEmpty(b) || b.length >= e } } } } }; v.angular.bootstrap ? v.console && console.log("WARNING: Tried to load angular more than once.") : (ie(), ke(ea), ea.module("ngLocale", [], ["$provide", function (a) {
        function b(a) {
            a +=
            ""; var b = a.indexOf("."); return -1 == b ? 0 : a.length - b - 1
        } a.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: ["AM", "PM"], DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), ERANAMES: ["Before Christ", "Anno Domini"], ERAS: ["BC", "AD"], FIRSTDAYOFWEEK: 6, MONTH: "January February March April May June July August September October November December".split(" "), SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "), SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), STANDALONEMONTH: "January February March April May June July August September October November December".split(" "),
                WEEKENDRANGE: [5, 6], fullDate: "EEEE, MMMM d, y", longDate: "MMMM d, y", medium: "MMM d, y h:mm:ss a", mediumDate: "MMM d, y", mediumTime: "h:mm:ss a", "short": "M/d/yy h:mm a", shortDate: "M/d/yy", shortTime: "h:mm a"
            }, NUMBER_FORMATS: { CURRENCY_SYM: "$", DECIMAL_SEP: ".", GROUP_SEP: ",", PATTERNS: [{ gSize: 3, lgSize: 3, maxFrac: 3, minFrac: 0, minInt: 1, negPre: "-", negSuf: "", posPre: "", posSuf: "" }, { gSize: 3, lgSize: 3, maxFrac: 2, minFrac: 2, minInt: 1, negPre: "-\u00a4", negSuf: "", posPre: "\u00a4", posSuf: "" }] }, id: "en-us", localeID: "en_US", pluralCat: function (a,
            c) { var e = a | 0, f = c; void 0 === f && (f = Math.min(b(a), 3)); Math.pow(10, f); return 1 == e && 0 == f ? "one" : "other" }
        })
    }]), B(v.document).ready(function () { ee(v.document, yc) }))
})(window); !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
//# sourceMappingURL=angular.min.js.map

/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.1.0-rc2
 */
(function(n,t,i){"use strict";(function(){t.module("ngMaterial",["ng","ngAnimate","ngAria","material.core","material.core.gestures","material.core.layout","material.core.theming.palette","material.core.theming","material.core.animate","material.components.autocomplete","material.components.bottomSheet","material.components.backdrop","material.components.button","material.components.card","material.components.checkbox","material.components.chips","material.components.content","material.components.datepicker","material.components.dialog","material.components.divider","material.components.fabActions","material.components.fabShared","material.components.fabSpeedDial","material.components.fabToolbar","material.components.gridList","material.components.fabTrigger","material.components.icon","material.components.input","material.components.list","material.components.menuBar","material.components.menu","material.components.progressCircular","material.components.progressLinear","material.components.radioButton","material.components.select","material.components.showHide","material.components.sidenav","material.components.sticky","material.components.slider","material.components.subheader","material.components.swipe","material.components.switch","material.components.tabs","material.components.toast","material.components.toolbar","material.components.virtualRepeat","material.components.tooltip","material.components.whiteframe"])})(),function(){function n(n,t){if(t.has("$swipe"))n.warn("You are using the ngTouch module. \nAngular Material already has mobile click, tap, and swipe support... \nngTouch is not supported with Angular Material!")}function i(n,t){n.decorator("$$rAF",["$delegate",r]);t.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey")}function r(n){return n.throttle=function(t){var r,i,u,f;return function(){r=arguments;f=this;u=t;i||(i=!0,n(function(){u.apply(f,Array.prototype.slice.call(r));i=!1}))}},n}t.module("material.core",["ngAnimate","material.core.animate","material.core.layout","material.core.gestures","material.core.theming"]).config(i).run(n);n.$inject=["$log","$injector"];i.$inject=["$provide","$mdThemingProvider"];r.$inject=["$delegate"]}(),function(){function n(){return{restrict:"A",link:i}}function i(n,t,i){var r=i.mdAutoFocus||i.mdAutofocus||i.mdSidenavFocus;n.$watch(r,function(n){t.toggleClass("_md-autofocus",n)})}t.module("material.core").directive("mdAutofocus",n).directive("mdAutoFocus",n).directive("mdSidenavFocus",n)}(),function(){function n(n){function t(n){return i?"webkit"+n.charAt(0).toUpperCase()+n.substring(1):n}var i=/webkit/i.test(n.vendorPrefix);return{KEY_CODE:{COMMA:188,SEMICOLON:186,ENTER:13,ESCAPE:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT_ARROW:37,UP_ARROW:38,RIGHT_ARROW:39,DOWN_ARROW:40,TAB:9,BACKSPACE:8,DELETE:46},CSS:{TRANSITIONEND:"transitionend"+(i?" webkitTransitionEnd":""),ANIMATIONEND:"animationend"+(i?" webkitAnimationEnd":""),TRANSFORM:t("transform"),TRANSFORM_ORIGIN:t("transformOrigin"),TRANSITION:t("transition"),TRANSITION_DURATION:t("transitionDuration"),ANIMATION_PLAY_STATE:t("animationPlayState"),ANIMATION_DURATION:t("animationDuration"),ANIMATION_NAME:t("animationName"),ANIMATION_TIMING:t("animationTimingFunction"),ANIMATION_DIRECTION:t("animationDirection")},MEDIA:{xs:"(max-width: 599px)","gt-xs":"(min-width: 600px)",sm:"(min-width: 600px) and (max-width: 959px)","gt-sm":"(min-width: 960px)",md:"(min-width: 960px) and (max-width: 1279px)","gt-md":"(min-width: 1280px)",lg:"(min-width: 1280px) and (max-width: 1919px)","gt-lg":"(min-width: 1920px)",xl:"(min-width: 1920px)",print:"print"},MEDIA_PRIORITY:["xl","gt-lg","lg","gt-md","md","gt-sm","sm","gt-xs","xs","print"]}}t.module("material.core").factory("$mdConstant",n);n.$inject=["$sniffer"]}(),function(){function n(n,i){function l(){return[].concat(r)}function a(){return r.length}function f(n){return r.length&&n>-1&&n<r.length}function v(n){return n?f(u(n)+1):!1}function y(n){return n?f(u(n)-1):!1}function p(n){return f(n)?r[n]:null}function w(n,t){return r.filter(function(i){return i[n]===t})}function b(n,i){return n?(t.isNumber(i)||(i=r.length),r.splice(i,0,n),u(n)):-1}function k(n){e(n)&&r.splice(u(n),1)}function u(n){return r.indexOf(n)}function e(n){return n&&u(n)>-1}function o(){return r.length?r[0]:null}function s(){return r.length?r[r.length-1]:null}function h(n,e,h,l){var y,a,v;for(h=h||c,y=u(e);;){if(!f(y)||(a=y+(n?-1:1),v=null,f(a)?v=r[a]:i&&(v=n?s():o(),a=u(v)),v===null||a===l))return null;if(h(v))return v;t.isUndefined(l)&&(l=a);y=a}}var c=function(){return!0},r;return n&&!t.isArray(n)&&(n=Array.prototype.slice.call(n)),i=!!i,r=n||[],{items:l,count:a,inRange:f,contains:e,indexOf:u,itemAt:p,findBy:w,add:b,remove:k,first:o,last:s,next:t.bind(null,h,!1),previous:t.bind(null,h,!0),hasPrevious:y,hasNext:v}}t.module("material.core").config(["$provide",function(t){t.decorator("$mdUtil",["$delegate",function(t){return t.iterator=n,t}])}])}(),function(){function n(n,i,r){function f(n){var i=o[n],r;return t.isUndefined(i)&&(i=o[n]=c(n)),r=s[i],t.isUndefined(r)&&(r=l(i)),r}function c(t){return n.MEDIA[t]||(t.charAt(0)!=="("?"("+t+")":t)}function l(n){var t=u[n];return t||(t=u[n]=r.matchMedia(n)),t.addListener(a),s[t.media]=!!t.matches}function a(n){i.$evalAsync(function(){s[n.media]=!!n.matches})}function v(n){return u[n]}function y(t,i){for(var f,s,r=0;r<n.MEDIA_PRIORITY.length;r++)if((f=n.MEDIA_PRIORITY[r],u[o[f]].matches)&&(s=e(t,i+"-"+f),t[s]))return t[s];return t[e(t,i)]}function p(i,r,u){var f=[];return i.forEach(function(i){var o=e(r,i),s;t.isDefined(r[o])&&f.push(r.$observe(o,t.bind(void 0,u,null)));for(s in n.MEDIA)o=e(r,i+"-"+s),t.isDefined(r[o])&&f.push(r.$observe(o,t.bind(void 0,u,s)))}),function(){f.forEach(function(n){n()})}}function e(n,t){return h[t]||(h[t]=n.$normalize(t))}var o={},u={},s={},h={};return f.getResponsiveAttribute=y,f.getQuery=v,f.watchResponsiveAttributes=p,f}t.module("material.core").factory("$mdMedia",n);n.$inject=["$mdConstant","$rootScope","$window"]}(),function(){function r(r,f,e,o,s,h,c,l,a){function b(n){return n[0]||n}var y=h.startSymbol(),p=h.endSymbol(),k=y==="{{"&&p==="}}",w=function(n,i,r){var f=!1,u;return n&&n.length&&(u=a.getComputedStyle(n[0]),f=t.isDefined(u[i])&&(r?u[i]==r:!0)),f},v={dom:{},now:n.performance?t.bind(n.performance,n.performance.now):Date.now||function(){return(new Date).getTime()},bidi:function(n,i,u,f){function o(n){return n?s(n)?n:n+"px":"0"}function s(n){return String(n).indexOf("px")>-1}var e=!(r[0].dir=="rtl"||r[0].body.dir=="rtl");if(arguments.length==0)return e?"ltr":"rtl";e&&t.isDefined(u)?t.element(n).css(i,o(u)):!e&&t.isDefined(f)&&t.element(n).css(i,o(f))},clientRect:function(n,t,i){var f=b(n),r,u;return t=b(t||f.offsetParent||document.body),r=f.getBoundingClientRect(),u=i?t.getBoundingClientRect():{left:0,top:0,width:0,height:0},{left:r.left-u.left,top:r.top-u.top,width:r.width,height:r.height}},offsetRect:function(n,t){return v.clientRect(n,t,!0)},nodesToArray:function(n){var i,t;for(n=n||[],i=[],t=0;t<n.length;++t)i.push(n.item(t));return i},scrollTop:function(n){n=t.element(n||r[0].body);var u=n[0]==r[0].body?r[0].body:i,f=u?u.scrollTop+u.parentElement.scrollTop:0;return f||Math.abs(n[0].getBoundingClientRect().top)},findFocusTarget:function(n,i){function f(n,i){var u,r=n[0].querySelectorAll(i);return r&&r.length&&r.length&&t.forEach(r,function(n){n=t.element(n);var i=n.hasClass("_md-autofocus");i&&(u=n)}),u}var u="[md-autofocus]",r;return r=f(n,i||u),r||i==u||(r=f(n,"[md-auto-focus]"),r||(r=f(n,u))),r},disableScrollAround:function(n,i){function s(n){function r(n){n.preventDefault()}n=t.element(n||u)[0];var f=50,i=t.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"><\/div><\/div>').css("z-index",f);n.appendChild(i[0]);i.on("wheel",r);i.on("touchmove",r);return function(){i.off("wheel");i.off("touchmove");i[0].parentNode.removeChild(i[0]);delete v.disableScrollAround._enableScrolling}}function h(){var n=u.parentNode,i=n.style.cssText||"",r=u.style.cssText||"",t=v.scrollTop(u),e=u.clientWidth;return u.scrollHeight>u.clientHeight+1&&(f(u,{position:"fixed",width:"100%",top:-t+"px"}),f(n,{overflowY:"scroll"})),u.clientWidth<e&&f(u,{overflow:"hidden"}),function(){u.style.cssText=r;n.style.cssText=i;u.scrollTop=t;n.scrollTop=t}}function f(n,t){for(var i in t)n.style[i]=t[i]}if(v.disableScrollAround._count=v.disableScrollAround._count||0,++v.disableScrollAround._count,v.disableScrollAround._enableScrolling)return v.disableScrollAround._enableScrolling;n=t.element(n);var u=r[0].body,e=h(),o=s(i);return v.disableScrollAround._enableScrolling=function(){--v.disableScrollAround._count||(e(),o(),delete v.disableScrollAround._enableScrolling)}},enableScrolling:function(){var n=this.disableScrollAround._enableScrolling;n&&n()},floatingScrollbars:function(){if(this.floatingScrollbars.cached===i){var n=t.element("<div><div><\/div><\/div>").css({width:"100%","z-index":-1,position:"absolute",height:"35px","overflow-y":"scroll"});n.children().css("height","60px");r[0].body.appendChild(n[0]);this.floatingScrollbars.cached=n[0].offsetWidth==n[0].childNodes[0].offsetWidth;n.remove()}return this.floatingScrollbars.cached},forceFocus:function(t){var r=t[0]||t,i;document.addEventListener("click",function u(n){n.target===r&&n.$focus&&(r.focus(),n.stopImmediatePropagation(),n.preventDefault(),r.removeEventListener("click",u))},!0);i=document.createEvent("MouseEvents");i.initMouseEvent("click",!1,!0,n,{},0,0,0,0,!1,!1,!1,!1,0,null);i.$material=!0;i.$focus=!0;r.dispatchEvent(i)},createBackdrop:function(n,t){return e(v.supplant('<md-backdrop class="{0}">',[t]))(n)},supplant:function(n,t,i){return i=i||/\{([^\{\}]*)\}/g,n.replace(i,function(n,i){var u=i.split("."),r=t,f;try{for(f in u)u.hasOwnProperty(f)&&(r=r[u[f]])}catch(e){r=n}return typeof r=="string"||typeof r=="number"?r:n})},fakeNgModel:function(){return{$fake:!0,$setTouched:t.noop,$setViewValue:function(n){this.$viewValue=n;this.$render(n);this.$viewChangeListeners.forEach(function(n){n()})},$isEmpty:function(n){return(""+n).length===0},$parsers:[],$formatters:[],$viewChangeListeners:[],$render:t.noop}},debounce:function(n,t,r,u){var e;return function(){var o=r,s=Array.prototype.slice.call(arguments);f.cancel(e);e=f(function(){e=i;n.apply(o,s)},t||10,u)}},throttle:function(n,t){var i;return function(){var u=this,f=arguments,r=v.now();(!i||r-i>t)&&(n.apply(u,f),i=r)}},time:function(n){var t=v.now();return n(),v.now()-t},valueOnUse:function(n,t,i){var r=null,u=Array.prototype.slice.call(arguments),f=u.length>3?u.slice(3):[];Object.defineProperty(n,t,{get:function(){return r===null&&(r=i.apply(n,f)),r}})},nextUid:function(){return""+u++},disconnectScope:function(n){if(n&&n.$root!==n&&!n.$$destroyed){var t=n.$parent;n.$$disconnected=!0;t.$$childHead===n&&(t.$$childHead=n.$$nextSibling);t.$$childTail===n&&(t.$$childTail=n.$$prevSibling);n.$$prevSibling&&(n.$$prevSibling.$$nextSibling=n.$$nextSibling);n.$$nextSibling&&(n.$$nextSibling.$$prevSibling=n.$$prevSibling);n.$$nextSibling=n.$$prevSibling=null}},reconnectScope:function(n){if(n&&n.$root!==n&&n.$$disconnected){var t=n,i=t.$parent;t.$$disconnected=!1;t.$$prevSibling=i.$$childTail;i.$$childHead?(i.$$childTail.$$nextSibling=t,i.$$childTail=t):i.$$childHead=i.$$childTail=t}},getClosest:function(n,i,r){if(n instanceof t.element&&(n=n[0]),i=i.toUpperCase(),r&&(n=n.parentNode),!n)return null;do if(n.nodeName===i)return n;while(n=n.parentNode);return null},elementContains:function(i,r){var u=n.Node&&n.Node.prototype&&Node.prototype.contains,f=u?t.bind(i,i.contains):t.bind(i,function(n){return i===r||!!(this.compareDocumentPosition(n)&16)});return f(r)},extractElementByName:function(n,i,r,u){function e(n){return o(n)||(!r?null:s(n))}function o(n){if(n)for(var t=0,r=n.length;t<r;t++)if(n[t].nodeName.toLowerCase()===i)return n[t];return null}function s(n){var t,i,f,u,r,o;if(n)for(i=0,f=n.length;i<f;i++)if(u=n[i],!t)for(r=0,o=u.childNodes.length;r<o;r++)t=t||e([u.childNodes[r]]);return t}var f=e(n);return f||!u||c.warn(v.supplant("Unable to find node '{0}' in element '{1}'.",[i,n[0].outerHTML])),t.element(f||n)},initOptionalProperties:function(n,i,r){r=r||{};t.forEach(n.$$isolateBindings,function(u,f){if(u.optional&&t.isUndefined(n[f])){var e=t.isDefined(i[u.attrName]);n[f]=t.isDefined(r[f])?r[f]:e}})},nextTick:function(n,t,i){function s(){var n=i&&i.$$destroyed,t=n?[]:r.queue,u=n?null:r.digest;r.queue=[];r.timeout=null;r.digest=!1;t.forEach(function(n){n()});u&&o.$digest()}var r=v.nextTick,e=r.timeout,u=r.queue||[];return u.push(n),t==null&&(t=!0),r.digest=r.digest||t,r.queue=u,e||(r.timeout=f(s,0,!1))},processTemplate:function(n){return k?n:!n||!t.isString(n)?n:n.replace(/\{\{/g,y).replace(/}}/g,p)},getParentWithPointerEvents:function(n){for(var t=n.parent();w(t,"pointer-events","none");)t=t.parent();return t},getNearestContentElement:function(n){for(var t=n.parent()[0];t&&t!==l[0]&&t!==document.body&&t.nodeName.toUpperCase()!=="MD-CONTENT";)t=t.parentNode;return t},parseAttributeBoolean:function(n,t){return n===""||!!n&&(t===!1||n!=="false"&&n!=="0")},hasComputedStyle:w};return v.dom.animator=s(v),v}var u=0;t.module("material.core").factory("$mdUtil",r);r.$inject=["$document","$timeout","$compile","$rootScope","$$mdAnimate","$interpolate","$log","$rootElement","$window"];t.element.prototype.focus=t.element.prototype.focus||function(){return this.length&&this[0].focus(),this};t.element.prototype.blur=t.element.prototype.blur||function(){return this.length&&this[0].blur(),this}}(),function(){function n(n,i,r,u){function f(n,r,u){var f=t.element(n)[0]||n;!f||f.hasAttribute(r)&&f.getAttribute(r).length!==0||h(f,r)||(u=t.isString(u)?u.trim():"",u.length?n.attr(r,u):i.warn('ARIA: Attribute "',r,'", required for accessibility, is missing on node:',f))}function e(t,i,r){n(function(){f(t,i,r())})}function s(n,t){var i=o(n)||"",r=i.indexOf(u.startSymbol())>-1;r?e(n,t,function(){return o(n)}):f(n,t,i)}function o(n){return(n.text()||"").trim()}function h(n,t){function s(n){var t=n.currentStyle?n.currentStyle:r.getComputedStyle(n);return t.display==="none"}var o=n.hasChildNodes(),e=!1,f,i,u;if(o)for(f=n.childNodes,i=0;i<f.length;i++)u=f[i],u.nodeType===1&&u.hasAttribute(t)&&(s(u)||(e=!0));return e}return{expect:f,expectAsync:e,expectWithText:s}}t.module("material.core").service("$mdAria",n);n.$inject=["$$rAF","$log","$window","$interpolate"]}(),function(){function n(n,i,r,u,f,e){this.compile=function(o){var h=o.templateUrl,a=o.template||"",c=o.controller,l=o.controllerAs,s=t.extend({},o.resolve||{}),v=t.extend({},o.locals||{}),y=o.transformTemplate||t.identity,p=o.bindToController;return t.forEach(s,function(n,i){s[i]=t.isString(n)?r.get(n):r.invoke(n)}),t.extend(s,v),s.$template=h?i.get(h,{cache:e}).then(function(n){return n.data}):n.when(a),n.all(s).then(function(n){var r,e=y(n.$template,o),i=o.element||t.element("<div>").html(e.trim()).contents(),s=u(i);return r={locals:n,element:i,link:function(u){var o,e;return n.$scope=u,c&&(o=f(c,n,!0),p&&t.extend(o.instance,n),e=o(),i.data("$ngControllerController",e),i.children().data("$ngControllerController",e),l&&(u[l]=e),r.controller=e),s(u)}}})}}t.module("material.core").service("$mdCompiler",n);n.$inject=["$q","$http","$injector","$compile","$controller","$templateCache"]}(),function(){function c(){}function l(i,r,f){function l(n){return function(t,i){i.distance<this.state.options.maxDistance&&this.dispatchEvent(t,n,i)}}function w(n,t,i){var r=u[t.replace(/^\$md./,"")];if(!r)throw new Error("Failed to register element with handler "+t+". Available handlers: "+Object.keys(u).join(", "));return r.registerElement(n,i)}function b(n,r){var f=new i(n);return t.extend(f,r),u[n]=f,o}var c=navigator.userAgent||navigator.vendor||n.opera,a=c.match(/ipad|iphone|ipod/i),v=c.match(/android/i),p=typeof n.jQuery!="undefined"&&t.element===n.jQuery,o={handler:b,register:w,isHijackingClicks:(a||v)&&!p&&!s},h;return o.isHijackingClicks&&(h=6,o.handler("click",{options:{maxDistance:h},onEnd:l("click")}),o.handler("focus",{options:{maxDistance:h},onEnd:function(n,t){function i(n){return n.getAttribute("tabindex")!="-1"&&!n.hasAttribute("DISABLED")&&(n.hasAttribute("tabindex")||n.hasAttribute("href")||["INPUT","SELECT","BUTTON","TEXTAREA","VIDEO","AUDIO"].indexOf(n.nodeName)!=-1)}t.distance<this.state.options.maxDistance&&i(n.target)&&(this.dispatchEvent(n,"focus",t),n.target.focus())}}),o.handler("mouseup",{options:{maxDistance:h},onEnd:l("mouseup")}),o.handler("mousedown",{onStart:function(n){this.dispatchEvent(n,"mousedown")}})),o.handler("press",{onStart:function(n){this.dispatchEvent(n,"$md.pressdown")},onEnd:function(n){this.dispatchEvent(n,"$md.pressup")}}).handler("hold",{options:{maxDistance:6,delay:500},onCancel:function(){f.cancel(this.state.timeout)},onStart:function(n,i){if(!this.state.registeredParent)return this.cancel();this.state.pos={x:i.x,y:i.y};this.state.timeout=f(t.bind(this,function(){this.dispatchEvent(n,"$md.hold");this.cancel()}),this.state.options.delay,!1)},onMove:function(n,t){n.preventDefault();var i=this.state.pos.x-t.x,r=this.state.pos.y-t.y;Math.sqrt(i*i+r*r)>this.options.maxDistance&&this.cancel()},onEnd:function(){this.onCancel()}}).handler("drag",{options:{minDistance:6,horizontal:!0,cancelMultiplier:1.5},onStart:function(){this.state.registeredParent||this.cancel()},onMove:function(n,t){var i,r;n.preventDefault();this.state.dragPointer?this.dispatchDragMove(n):(this.state.options.horizontal?(i=Math.abs(t.distanceX)>this.state.options.minDistance,r=Math.abs(t.distanceY)>this.state.options.minDistance*this.state.options.cancelMultiplier):(i=Math.abs(t.distanceY)>this.state.options.minDistance,r=Math.abs(t.distanceX)>this.state.options.minDistance*this.state.options.cancelMultiplier),i?(this.state.dragPointer=y(n),e(n,this.state.dragPointer),this.dispatchEvent(n,"$md.dragstart",this.state.dragPointer)):r&&this.cancel())},dispatchDragMove:r.throttle(function(n){this.state.isRunning&&(e(n,this.state.dragPointer),this.dispatchEvent(n,"$md.drag",this.state.dragPointer))}),onEnd:function(n){this.state.dragPointer&&(e(n,this.state.dragPointer),this.dispatchEvent(n,"$md.dragend",this.state.dragPointer))}}).handler("swipe",{options:{minVelocity:.65,minDistance:10},onEnd:function(n,t){var i;Math.abs(t.velocityX)>this.state.options.minVelocity&&Math.abs(t.distanceX)>this.state.options.minDistance?(i=t.directionX=="left"?"$md.swipeleft":"$md.swiperight",this.dispatchEvent(n,i)):Math.abs(t.velocityY)>this.state.options.minVelocity&&Math.abs(t.distanceY)>this.state.options.minDistance&&(i=t.directionY=="up"?"$md.swipeup":"$md.swipedown",this.dispatchEvent(n,i))}})}function a(n){this.name=n;this.state={}}function b(){function u(n,r,u){u=u||i;var f=new t.element.Event(r);f.$material=!0;f.pointer=u;f.srcEvent=n;t.extend(f,{clientX:u.x,clientY:u.y,screenX:u.x,screenY:u.y,pageX:u.x,pageY:u.y,ctrlKey:n.ctrlKey,altKey:n.altKey,shiftKey:n.shiftKey,metaKey:n.metaKey});t.element(u.target).trigger(f)}function f(t,r,u){u=u||i;var f;r==="click"||r=="mouseup"||r=="mousedown"?(f=document.createEvent("MouseEvents"),f.initMouseEvent(r,!0,!0,n,t.detail,u.x,u.y,u.x,u.y,t.ctrlKey,t.altKey,t.shiftKey,t.metaKey,t.button,t.relatedTarget||null)):(f=document.createEvent("CustomEvent"),f.initCustomEvent(r,!0,!0,{}));f.$material=!0;f.pointer=u;f.srcEvent=t;u.target.dispatchEvent(f)}var r=typeof n.jQuery!="undefined"&&t.element===n.jQuery;return a.prototype={options:{},dispatchEvent:r?u:f,onStart:t.noop,onMove:t.noop,onEnd:t.noop,onCancel:t.noop,start:function(n,i){if(!this.state.isRunning){var r=this.getNearestParent(n.target),u=r&&r.$mdGesture[this.name]||{};this.state={isRunning:!0,options:t.extend({},this.options,u),registeredParent:r};this.onStart(n,i)}},move:function(n,t){if(this.state.isRunning)this.onMove(n,t)},end:function(n,t){if(this.state.isRunning){this.onEnd(n,t);this.state.isRunning=!1}},cancel:function(n,t){this.onCancel(n,t);this.state={}},getNearestParent:function(n){for(var t=n;t;){if((t.$mdGesture||{})[this.name])return t;t=t.parentNode}return null},registerElement:function(n,t){function i(){delete n[0].$mdGesture[r.name];n.off("$destroy",i)}var r=this;n[0].$mdGesture=n[0].$mdGesture||{};n[0].$mdGesture[this.name]=t||{};n.on("$destroy",i);return i}},a}function v(n,s){function c(n){var t=!n.clientX&&!n.clientY;t||n.$material||n.isIonicTap||p(n)||(n.preventDefault(),n.stopPropagation())}function a(n){var t=n.clientX===0&&n.clientY===0;t||n.$material||n.isIonicTap||p(n)?(r=null,n.target.tagName.toLowerCase()=="label"&&(r={x:n.x,y:n.y})):(n.preventDefault(),n.stopPropagation(),r=null)}function l(n,t){var r;for(var f in u)r=u[f],r instanceof s&&(n==="start"&&r.cancel(),r[n](t,i))}function v(n){if(!i){var t=+Date.now();f&&!o(n,f)&&t-f.endTime<1500||(i=y(n),l("start",n))}}function w(n){i&&o(n,i)&&(e(n,i),l("move",n))}function b(n){i&&o(n,i)&&(e(n,i),i.endTime=+Date.now(),l("end",n),f=i,i=null)}document.contains||(document.contains=function(n){return document.body.contains(n)});!h&&n.isHijackingClicks&&(document.addEventListener("click",a,!0),document.addEventListener("mouseup",c,!0),document.addEventListener("mousedown",c,!0),document.addEventListener("focus",c,!0),h=!0);t.element(document).on("mousedown touchstart pointerdown",v).on("mousemove touchmove pointermove",w).on("mouseup mouseleave touchend touchcancel pointerup pointercancel",b).on("$$mdGestureReset",function(){f=i=null})}function y(n){var i=w(n),t={startTime:+Date.now(),target:n.target,type:n.type.charAt(0)};return t.startX=t.x=i.pageX,t.startY=t.y=i.pageY,t}function o(n,t){return n&&t&&n.type.charAt(0)===t.type}function p(n){return r&&r.x==n.x&&r.y==n.y}function e(n,t){var i=w(n),r=t.x=i.pageX,u=t.y=i.pageY;t.distanceX=r-t.startX;t.distanceY=u-t.startY;t.distance=Math.sqrt(t.distanceX*t.distanceX+t.distanceY*t.distanceY);t.directionX=t.distanceX>0?"right":t.distanceX<0?"left":"";t.directionY=t.distanceY>0?"down":t.distanceY<0?"up":"";t.duration=+Date.now()-t.startTime;t.velocityX=t.distanceX/t.duration;t.velocityY=t.distanceY/t.duration}function w(n){return n=n.originalEvent||n,n.touches&&n.touches[0]||n.changedTouches&&n.changedTouches[0]||n}var u={},i,f,s=!1,r=null,h=!1;t.module("material.core.gestures",[]).provider("$mdGesture",c).factory("$$MdGestureHandler",b).run(v);c.prototype={skipClickHijack:function(){return s=!0},$get:["$$MdGestureHandler","$$rAF","$timeout",function(n,t,i){return new l(n,t,i)}]};l.$inject=["$$MdGestureHandler","$$rAF","$timeout"];v.$inject=["$mdGesture","$$MdGestureHandler"]}(),function(){function n(){function n(n){function o(n){return i.optionsFactory=n.options,i.methods=(n.methods||[]).concat(u),r}function s(n,t){return f[n]=t,r}function h(t,f){if(f=f||{},f.methods=f.methods||[],f.options=f.options||function(){return{}},/^cancel|hide|show$/.test(t))throw new Error("Preset '"+t+"' in "+n+" is reserved!");if(f.methods.indexOf("_options")>-1)throw new Error("Method '_options' in "+n+" is reserved!");return i.presets[t]={methods:f.methods.concat(u),optionsFactory:f.options,argOption:f.argOption},r}function e(r,u){function l(n){return n=n||{},n._options&&(n=n._options),o.show(t.extend({},h,n))}function a(n){return o.destroy(n)}function c(t,i){var r={};return r[n]=e,u.invoke(t||function(){return i},{},r)}var s,h,o=r(),e={hide:o.hide,cancel:o.cancel,show:l,destroy:a};return s=i.methods||[],h=c(i.optionsFactory,{}),t.forEach(f,function(n,t){e[t]=n}),t.forEach(i.presets,function(n,i){function r(n){this._options=t.extend({},u,n)}var u=c(n.optionsFactory,{}),o=(n.methods||[]).concat(s),f;t.extend(u,{$type:i});t.forEach(o,function(n){r.prototype[n]=function(t){return this._options[n]=t,this}});n.argOption&&(f="show"+i.charAt(0).toUpperCase()+i.slice(1),e[f]=function(n){var t=e[i](n);return e.show(t)});e[i]=function(i){return arguments.length&&n.argOption&&!t.isObject(i)&&!t.isArray(i)?(new r)[n.argOption](i):new r(i)}}),e}var u=["onHide","onShow","onRemove"],f={},i={presets:{}},r={setDefaults:o,addPreset:h,addMethod:s,$get:e};return r.addPreset("build",{methods:["controller","controllerAs","resolve","template","templateUrl","themable","transformTemplate","parent"]}),e.$inject=["$$interimElement","$injector"],r}function r(n,r,u,f,e,o,s,h,c,l,a){return function(){function w(n){n=n||{};var t=new g(n||{}),i=!n.skipHide&&v.length?y.hide():r.when(!0);return i.finally(function(){v.push(t);t.show().catch(function(n){return n})}),t.deferred.promise}function b(n,t){function u(i){return i.remove(n,!1,t||{}).catch(function(n){return n}),i.deferred.promise}var f,e;return v.length?(t=t||{},t.closeAll?(f=r.all(v.reverse().map(u)),v=[],f):t.closeTo!==i?r.all(v.splice(t.closeTo).map(u)):(e=v.pop(),u(e))):r.when(n)}function k(n,t){var i=v.pop();return i?(i.remove(n,!0,t||{}).catch(function(n){return n}),i.deferred.promise):r.when(n)}function d(n){var i=n?null:v.shift(),f=t.element(n).length?t.element(n)[0].parentNode:null,u;return f&&(u=v.filter(function(n){var t=n.options.element[0];return t===f}),u.length>0&&(i=u[0],v.splice(v.indexOf(i),1))),i?i.remove(p,!1,{$destroy:!0}):r.when(p)}function g(a){function k(){return r(function(n,t){function i(n){v.deferred.reject(n);t(n)}nt(a).then(function(t){p=tt(t,a);w=ut(p,a,t.controller).then(n,i)},i)})}function d(n,i,u){function e(n){v.deferred.resolve(n)}function f(n){v.deferred.reject(n)}return p?(a=t.extend(a||{},u||{}),a.cancelAutoHide&&a.cancelAutoHide(),a.element.triggerHandler("$mdInterimElementRemove"),a.$destroy===!0?b(a.element,a).then(function(){i&&f(n)||e(n)}):(r.when(w).finally(function(){b(a.element,a).then(function(){i&&f(n)||e(n)},f)}),v.deferred.promise)):r.when(!1)}function g(n){return n=n||{},n.template&&(n.template=h.processTemplate(n.template)),t.extend({preserveScope:!1,cancelAutoHide:t.noop,scope:n.scope||f.$new(n.isolateScope),onShow:function(n,t,i){return s.enter(t,i.parent)},onRemove:function(n,t){return t&&s.leave(t)||r.when()}},n)}function nt(n){var t=n.skipCompile?null:c.compile(n);return t||r(function(t){t({locals:{},link:function(){return n.element}})})}function tt(n,i){t.extend(n.locals,i);var r=n.link(i.scope);return i.element=r,i.parent=it(r,i),i.themable&&l(r),r}function it(i,r){var u=r.parent,f;return(u=t.isFunction(u)?u(r.scope,i,r):t.isString(u)?t.element(n[0].querySelector(u)):t.element(u),!(u||{}).length)?(o[0]&&o[0].querySelector&&(f=o[0].querySelector(":not(svg) > body")),f||(f=o[0]),f.nodeName=="#comment"&&(f=n[0].body),t.element(f)):u}function rt(){var n,r=t.noop;a.hideDelay&&(n=e(y.hide,a.hideDelay),r=function(){e.cancel(n)});a.cancelAutoHide=function(){r();a.cancelAutoHide=i}}function ut(n,i,u){var f=i.onShowing||t.noop,e=i.onComplete||t.noop;return f(i.scope,n,i,u),r(function(t,f){try{r.when(i.onShow(i.scope,n,i,u)).then(function(){e(i.scope,n,i);rt();t(n)},f)}catch(o){f(o.message)}})}function b(n,i){var r=i.onRemoving||t.noop;return u(function(t,f){try{var e=u.when(i.onRemove(i.scope,n,i)||!0);r(n,e);i.$destroy==!0?t(n):e.then(function(){!i.preserveScope&&i.scope&&i.scope.$destroy();t(n)},f)}catch(o){f(o.message)}})}var v,p,w=r.when(!0);return a=g(a),v={options:a,deferred:r.defer(),show:k,remove:d}}var p=!1,y,v=[];return y={show:w,hide:b,cancel:k,destroy:d,$injector_:a}}}return n.$get=r,r.$inject=["$document","$q","$$q","$rootScope","$timeout","$rootElement","$animate","$mdUtil","$mdCompiler","$mdTheming","$injector"],n}t.module("material.core").provider("$$interimElement",n)}(),function(){(function(){function k(i){function u(n){return n.replace(f,"").replace(e,function(n,t,i,r){return r?i.toUpperCase():i})}var f=/^((?:x|data)[\:\-_])/i,e=/([\:\-\_]+(.))/g,o=["layout","flex","flex-order","flex-offset","layout-align"],s=["show","hide","layout-padding","layout-margin"];t.forEach(["","xs","gt-xs","sm","gt-sm","md","gt-md","lg","gt-lg","xl","print"],function(n){t.forEach(o,function(t){var r=n?t+"-"+n:t;i.directive(u(r),nt(r))});t.forEach(s,function(t){var f=n?t+"-"+n:t;i.directive(u(f),r(f))})});i.directive("mdLayoutCss",d).directive("ngCloak",g("ng-cloak")).directive("layoutWrap",r("layout-wrap")).directive("layoutNowrap",r("layout-nowrap")).directive("layoutNoWrap",r("layout-no-wrap")).directive("layoutFill",r("layout-fill")).directive("layoutLtMd",n("layout-lt-md",!0)).directive("layoutLtLg",n("layout-lt-lg",!0)).directive("flexLtMd",n("flex-lt-md",!0)).directive("flexLtLg",n("flex-lt-lg",!0)).directive("layoutAlignLtMd",n("layout-align-lt-md")).directive("layoutAlignLtLg",n("layout-align-lt-lg")).directive("flexOrderLtMd",n("flex-order-lt-md")).directive("flexOrderLtLg",n("flex-order-lt-lg")).directive("offsetLtMd",n("flex-offset-lt-md")).directive("offsetLtLg",n("flex-offset-lt-lg")).directive("hideLtMd",n("hide-lt-md")).directive("hideLtLg",n("hide-lt-lg")).directive("showLtMd",n("show-lt-md")).directive("showLtLg",n("show-lt-lg"))}function d(){return{restrict:"A",priority:"900",compile:function(){return f.enabled=!1,t.noop}}}function g(n){return["$timeout",function(i){return{restrict:"A",priority:-10,compile:function(r){return f.enabled?(r.addClass(n),function(t,r){i(function(){r.removeClass(n)},10,!1)}):t.noop}}}]}function nt(n){function i(t,i,r){var u=tt(i,n,r),f=r.$observe(r.$normalize(n),u);u(h(n,r,""));t.$on("$destroy",function(){f()})}return["$mdUtil","$interpolate","$log",function(r,c,l){return u=r,e=c,o=l,{restrict:"A",compile:function(r,u){var e;return f.enabled&&(it(n,u,r,o),s(n,h(n,u,""),a(r,n,u)),e=i),e||t.noop}}}]}function r(n){function i(t,i){i.addClass(n)}return["$mdUtil","$interpolate","$log",function(r,c,l){return u=r,e=c,o=l,{restrict:"A",compile:function(r,u){var e;return f.enabled&&(s(n,h(n,u,""),a(r,n,u)),i(null,r),e=i),e||t.noop}}}]}function tt(n,r){var u;return function(f){var e=s(r,f||"");t.isDefined(e)&&(u&&n.removeClass(u),u=e?r+"-"+e.replace(i,"-"):r,n.addClass(u))}}function n(n){var i=n.split("-");return["$log",function(r){return r.warn(n+"has been deprecated. Please use a `"+i[0]+"-gt-<xxx>` variant."),t.noop}]}function it(n,t,i,r){var e,o,s,f=i[0].nodeName.toLowerCase();switch(n.replace(c,"")){case"flex":(f=="md-button"||f=="fieldset")&&(o="<"+f+" "+n+"><\/"+f+">",s="https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers",e="Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.",r.warn(u.supplant(e,[o,s])))}}function s(n,i,r){var e=i,f;if(!v(i)){switch(n.replace(c,"")){case"layout":y(i,l)||(i=l[0]);break;case"flex":y(i,p)||isNaN(i)&&(i="");break;case"flex-offset":case"flex-order":(!i||isNaN(+i))&&(i="0");break;case"layout-align":f=rt(i);i=u.supplant("{main}-{cross}",f);break;case"layout-padding":case"layout-margin":case"layout-fill":case"layout-wrap":case"layout-nowrap":case"layout-nowrap":i=""}i!=e&&(r||t.noop)(i)}return i}function a(n,t,i){return function(n){v(n)||(i[i.$normalize(t)]=n)}}function v(n){return(n||"").indexOf(e.startSymbol())>-1}function h(n,t,r){var u=t.$normalize(n);return t[u]?t[u].replace(i,"-"):r||null}function y(n,t,r){n=r&&n?n.replace(i,r):n;var u=!1;return n&&t.forEach(function(t){t=r?t.replace(i,r):t;u=u||t===n}),u}function rt(n){var r={main:"start",cross:"stretch"},t;return n=n||"",(n.indexOf("-")==0||n.indexOf(" ")==0)&&(n="none"+n),t=n.toLowerCase().trim().replace(i,"-").split("-"),t.length&&t[0]==="space"&&(t=[t[0]+"-"+t[1],t[2]]),t.length>0&&(r.main=t[0]||r.main),t.length>1&&(r.cross=t[1]||r.cross),w.indexOf(r.main)<0&&(r.main="start"),b.indexOf(r.cross)<0&&(r.cross="stretch"),r}var u,e,o,c=/(-gt)?-(sm|md|lg|print)/g,i=/\s+/g,p=["grow","initial","auto","none","noshrink","nogrow"],l=["row","column"],w=["","start","center","end","stretch","space-around","space-between"],b=["","start","center","end","stretch"],f={enabled:!0,breakpoints:[]};k(t.module("material.core.layout",["ng"]))})()}(),function(){function n(n,i){function e(n){return n&&n!==""}var f,r=[],u={};return f={notFoundError:function(t){n.error("No instance found for handle",t)},getInstances:function(){return r},get:function(n){if(!e(n))return null;for(var i,t=0,u=r.length;t<u;t++)if(i=r[t],i.$$mdHandle===n)return i;return null},register:function(n,i){function f(){var t=r.indexOf(n);t!==-1&&r.splice(t,1)}function e(){var t=u[i];t&&(t.resolve(n),delete u[i])}return i?(n.$$mdHandle=i,r.push(n),e(),f):t.noop},when:function(n){if(e(n)){var t=i.defer(),r=f.get(n);return r?t.resolve(r):u[n]=t,t.promise}return i.reject("Invalid `md-component-id` value.")}}}t.module("material.core").factory("$mdComponentRegistry",n);n.$inject=["$log","$q"]}(),function(){(function(){function n(n){function i(n){return n.hasClass("md-icon-button")?{isMenuItem:n.hasClass("md-menu-item"),fitRipple:!0,center:!0}:{isMenuItem:n.hasClass("md-menu-item"),dimBackground:!0}}return{attach:function(r,u,f){return f=t.extend(i(u),f),n.attach(r,u,f)}}}t.module("material.core").factory("$mdButtonInkRipple",n);n.$inject=["$mdInkRipple"]})()}(),function(){(function(){function n(n){function i(i,r,u){return n.attach(i,r,t.extend({center:!0,dimBackground:!1,fitRipple:!0},u))}return{attach:i}}t.module("material.core").factory("$mdCheckboxInkRipple",n);n.$inject=["$mdInkRipple"]})()}(),function(){(function(){function n(n){function i(i,r,u){return n.attach(i,r,t.extend({center:!1,dimBackground:!0,outline:!1,rippleSize:"full"},u))}return{attach:i}}t.module("material.core").factory("$mdListInkRipple",n);n.$inject=["$mdInkRipple"]})()}(),function(){function u(n,i){return{controller:t.noop,link:function(t,r,u){u.hasOwnProperty("mdInkRippleCheckbox")?i.attach(t,r):n.attach(t,r)}}}function f(i){function r(r,u,f){return u.controller("mdNoInk")?t.noop:i.instantiate(n,{$scope:r,$element:u,rippleOptions:f})}return{attach:r}}function n(n,i,r,u,f,e){this.$window=u;this.$timeout=f;this.$mdUtil=e;this.$scope=n;this.$element=i;this.options=r;this.mousedown=!1;this.ripples=[];this.timeout=null;this.lastRipple=null;e.valueOnUse(this,"container",this.createContainer);this.$element.addClass("md-ink-ripple");(i.controller("mdInkRipple")||{}).createRipple=t.bind(this,this.createRipple);(i.controller("mdInkRipple")||{}).setColor=t.bind(this,this.color);this.bindEvents()}function e(n,i){(n.mousedown||n.lastRipple)&&(n.mousedown=!1,n.$mdUtil.nextTick(t.bind(n,i),!1))}function r(){return{controller:t.noop}}t.module("material.core").factory("$mdInkRipple",f).directive("mdInkRipple",u).directive("mdNoInk",r).directive("mdNoBar",r).directive("mdNoStretch",r);var i=450;u.$inject=["$mdButtonInkRipple","$mdCheckboxInkRipple"];f.$inject=["$injector"];n.$inject=["$scope","$element","rippleOptions","$window","$timeout","$mdUtil"];n.prototype.color=function(n){function r(){var n=i.options&&i.options.colorElement?i.options.colorElement:[],t=n.length?n[0]:i.$element[0];return t?i.$window.getComputedStyle(t).color:"rgb(0,0,0)"}var i=this;return t.isDefined(n)&&(i._color=i._parseColor(n)),i._color||i._parseColor(i.inkRipple())||i._parseColor(r())};n.prototype.calculateColor=function(){return this.color()};n.prototype._parseColor=function(n,t){function i(n){var i=n[0]==="#"?n.substr(1):n,t=i.length/3,r=i.substr(0,t),u=i.substr(t,t),f=i.substr(t*2);return t===1&&(r+=r,u+=u,f+=f),"rgba("+parseInt(r,16)+","+parseInt(u,16)+","+parseInt(f,16)+",0.1)"}function r(n){return n.replace(")",", 0.1)").replace("(","a(")}if(t=t||1,n)return n.indexOf("rgba")===0?n.replace(/\d?\.?\d*\s*\)\s*$/,(.1*t).toString()+")"):n.indexOf("rgb")===0?r(n):n.indexOf("#")===0?i(n):void 0};n.prototype.bindEvents=function(){this.$element.on("mousedown",t.bind(this,this.handleMousedown));this.$element.on("mouseup touchend",t.bind(this,this.handleMouseup));this.$element.on("mouseleave",t.bind(this,this.handleMouseup));this.$element.on("touchmove",t.bind(this,this.handleTouchmove))};n.prototype.handleMousedown=function(n){if(!this.mousedown)if(n.hasOwnProperty("originalEvent")&&(n=n.originalEvent),this.mousedown=!0,this.options.center)this.createRipple(this.container.prop("clientWidth")/2,this.container.prop("clientWidth")/2);else if(n.srcElement!==this.$element[0]){var t=this.$element[0].getBoundingClientRect(),i=n.clientX-t.left,r=n.clientY-t.top;this.createRipple(i,r)}else this.createRipple(n.offsetX,n.offsetY)};n.prototype.handleMouseup=function(){e(this,this.clearRipples)};n.prototype.handleTouchmove=function(){e(this,this.deleteRipples)};n.prototype.deleteRipples=function(){for(var n=0;n<this.ripples.length;n++)this.ripples[n].remove()};n.prototype.clearRipples=function(){for(var n=0;n<this.ripples.length;n++)this.fadeInComplete(this.ripples[n])};n.prototype.createContainer=function(){var n=t.element('<div class="md-ripple-container"><\/div>');return this.$element.append(n),n};n.prototype.clearTimeout=function(){this.timeout&&(this.$timeout.cancel(this.timeout),this.timeout=null)};n.prototype.isRippleAllowed=function(){var n=this.$element[0];do{if(!n.tagName||n.tagName==="BODY")break;if(n&&t.isFunction(n.hasAttribute)&&(n.hasAttribute("disabled")||this.inkRipple()==="false"||this.inkRipple()==="0"))return!1}while(n=n.parentNode);return!0};n.prototype.inkRipple=function(){return this.$element.attr("md-ink-ripple")};n.prototype.createRipple=function(n,r){function s(n){return n?n.replace("rgba","rgb").replace(/,[^\),]+\)/,")"):"rgb(0,0,0)"}function v(n,t,i){return n?Math.max(t,i):Math.sqrt(Math.pow(t,2)+Math.pow(i,2))}if(this.isRippleAllowed()){var f=this,u=t.element('<div class="md-ripple"><\/div>'),h=this.$element.prop("clientWidth"),c=this.$element.prop("clientHeight"),l=Math.max(Math.abs(h-n),n)*2,a=Math.max(Math.abs(c-r),r)*2,o=v(this.options.fitRipple,l,a),e=this.calculateColor();u.css({left:n+"px",top:r+"px",background:"black",width:o+"px",height:o+"px",backgroundColor:s(e),borderColor:s(e)});this.lastRipple=u;this.clearTimeout();this.timeout=this.$timeout(function(){f.clearTimeout();f.mousedown||f.fadeInComplete(u)},i*.35,!1);this.options.dimBackground&&this.container.css({backgroundColor:e});this.container.append(u);this.ripples.push(u);u.addClass("md-ripple-placed");this.$mdUtil.nextTick(function(){u.addClass("md-ripple-scaled md-ripple-active");f.$timeout(function(){f.clearRipples()},i,!1)},!1)}};n.prototype.fadeInComplete=function(n){this.lastRipple===n?this.timeout||this.mousedown||this.removeRipple(n):this.removeRipple(n)};n.prototype.removeRipple=function(n){var t=this,r=this.ripples.indexOf(n);r<0||(this.ripples.splice(this.ripples.indexOf(n),1),n.removeClass("md-ripple-active"),this.ripples.length===0&&this.container.css({backgroundColor:""}),this.$timeout(function(){t.fadeOutComplete(n)},i,!1))};n.prototype.fadeOutComplete=function(n){n.remove();this.lastRipple=null}}(),function(){(function(){function n(n){function i(i,r,u){return n.attach(i,r,t.extend({center:!1,dimBackground:!0,outline:!1,rippleSize:"full"},u))}return{attach:i}}t.module("material.core").factory("$mdTabInkRipple",n);n.$inject=["$mdInkRipple"]})()}(),function(){t.module("material.core.theming.palette",[]).constant("$mdColorPalette",{red:{"50":"#ffebee","100":"#ffcdd2","200":"#ef9a9a","300":"#e57373","400":"#ef5350","500":"#f44336","600":"#e53935","700":"#d32f2f","800":"#c62828","900":"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 300 A100",contrastStrongLightColors:"400 500 600 700 A200 A400 A700"},pink:{"50":"#fce4ec","100":"#f8bbd0","200":"#f48fb1","300":"#f06292","400":"#ec407a","500":"#e91e63","600":"#d81b60","700":"#c2185b","800":"#ad1457","900":"#880e4f",A100:"#ff80ab",A200:"#ff4081",A400:"#f50057",A700:"#c51162",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 A100",contrastStrongLightColors:"500 600 A200 A400 A700"},purple:{"50":"#f3e5f5","100":"#e1bee7","200":"#ce93d8","300":"#ba68c8","400":"#ab47bc","500":"#9c27b0","600":"#8e24aa","700":"#7b1fa2","800":"#6a1b9a","900":"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 A100",contrastStrongLightColors:"300 400 A200 A400 A700"},"deep-purple":{"50":"#ede7f6","100":"#d1c4e9","200":"#b39ddb","300":"#9575cd","400":"#7e57c2","500":"#673ab7","600":"#5e35b1","700":"#512da8","800":"#4527a0","900":"#311b92",A100:"#b388ff",A200:"#7c4dff",A400:"#651fff",A700:"#6200ea",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 A100",contrastStrongLightColors:"300 400 A200"},indigo:{"50":"#e8eaf6","100":"#c5cae9","200":"#9fa8da","300":"#7986cb","400":"#5c6bc0","500":"#3f51b5","600":"#3949ab","700":"#303f9f","800":"#283593","900":"#1a237e",A100:"#8c9eff",A200:"#536dfe",A400:"#3d5afe",A700:"#304ffe",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 A100",contrastStrongLightColors:"300 400 A200 A400"},blue:{"50":"#e3f2fd","100":"#bbdefb","200":"#90caf9","300":"#64b5f6","400":"#42a5f5","500":"#2196f3","600":"#1e88e5","700":"#1976d2","800":"#1565c0","900":"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 300 400 A100",contrastStrongLightColors:"500 600 700 A200 A400 A700"},"light-blue":{"50":"#e1f5fe","100":"#b3e5fc","200":"#81d4fa","300":"#4fc3f7","400":"#29b6f6","500":"#03a9f4","600":"#039be5","700":"#0288d1","800":"#0277bd","900":"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea",contrastDefaultColor:"dark",contrastLightColors:"600 700 800 900 A700",contrastStrongLightColors:"600 700 800 A700"},cyan:{"50":"#e0f7fa","100":"#b2ebf2","200":"#80deea","300":"#4dd0e1","400":"#26c6da","500":"#00bcd4","600":"#00acc1","700":"#0097a7","800":"#00838f","900":"#006064",A100:"#84ffff",A200:"#18ffff",A400:"#00e5ff",A700:"#00b8d4",contrastDefaultColor:"dark",contrastLightColors:"700 800 900",contrastStrongLightColors:"700 800 900"},teal:{"50":"#e0f2f1","100":"#b2dfdb","200":"#80cbc4","300":"#4db6ac","400":"#26a69a","500":"#009688","600":"#00897b","700":"#00796b","800":"#00695c","900":"#004d40",A100:"#a7ffeb",A200:"#64ffda",A400:"#1de9b6",A700:"#00bfa5",contrastDefaultColor:"dark",contrastLightColors:"500 600 700 800 900",contrastStrongLightColors:"500 600 700"},green:{"50":"#e8f5e9","100":"#c8e6c9","200":"#a5d6a7","300":"#81c784","400":"#66bb6a","500":"#4caf50","600":"#43a047","700":"#388e3c","800":"#2e7d32","900":"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853",contrastDefaultColor:"dark",contrastLightColors:"500 600 700 800 900",contrastStrongLightColors:"500 600 700"},"light-green":{"50":"#f1f8e9","100":"#dcedc8","200":"#c5e1a5","300":"#aed581","400":"#9ccc65","500":"#8bc34a","600":"#7cb342","700":"#689f38","800":"#558b2f","900":"#33691e",A100:"#ccff90",A200:"#b2ff59",A400:"#76ff03",A700:"#64dd17",contrastDefaultColor:"dark",contrastLightColors:"700 800 900",contrastStrongLightColors:"700 800 900"},lime:{"50":"#f9fbe7","100":"#f0f4c3","200":"#e6ee9c","300":"#dce775","400":"#d4e157","500":"#cddc39","600":"#c0ca33","700":"#afb42b","800":"#9e9d24","900":"#827717",A100:"#f4ff81",A200:"#eeff41",A400:"#c6ff00",A700:"#aeea00",contrastDefaultColor:"dark",contrastLightColors:"900",contrastStrongLightColors:"900"},yellow:{"50":"#fffde7","100":"#fff9c4","200":"#fff59d","300":"#fff176","400":"#ffee58","500":"#ffeb3b","600":"#fdd835","700":"#fbc02d","800":"#f9a825","900":"#f57f17",A100:"#ffff8d",A200:"#ffff00",A400:"#ffea00",A700:"#ffd600",contrastDefaultColor:"dark"},amber:{"50":"#fff8e1","100":"#ffecb3","200":"#ffe082","300":"#ffd54f","400":"#ffca28","500":"#ffc107","600":"#ffb300","700":"#ffa000","800":"#ff8f00","900":"#ff6f00",A100:"#ffe57f",A200:"#ffd740",A400:"#ffc400",A700:"#ffab00",contrastDefaultColor:"dark"},orange:{"50":"#fff3e0","100":"#ffe0b2","200":"#ffcc80","300":"#ffb74d","400":"#ffa726","500":"#ff9800","600":"#fb8c00","700":"#f57c00","800":"#ef6c00","900":"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00",contrastDefaultColor:"dark",contrastLightColors:"800 900",contrastStrongLightColors:"800 900"},"deep-orange":{"50":"#fbe9e7","100":"#ffccbc","200":"#ffab91","300":"#ff8a65","400":"#ff7043","500":"#ff5722","600":"#f4511e","700":"#e64a19","800":"#d84315","900":"#bf360c",A100:"#ff9e80",A200:"#ff6e40",A400:"#ff3d00",A700:"#dd2c00",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 300 400 A100 A200",contrastStrongLightColors:"500 600 700 800 900 A400 A700"},brown:{"50":"#efebe9","100":"#d7ccc8","200":"#bcaaa4","300":"#a1887f","400":"#8d6e63","500":"#795548","600":"#6d4c41","700":"#5d4037","800":"#4e342e","900":"#3e2723",A100:"#d7ccc8",A200:"#bcaaa4",A400:"#8d6e63",A700:"#5d4037",contrastDefaultColor:"light",contrastDarkColors:"50 100 200",contrastStrongLightColors:"300 400"},grey:{"50":"#fafafa","100":"#f5f5f5","200":"#eeeeee","300":"#e0e0e0","400":"#bdbdbd","500":"#9e9e9e","600":"#757575","700":"#616161","800":"#424242","900":"#212121",A100:"#ffffff",A200:"#000000",A400:"#303030",A700:"#616161",contrastDefaultColor:"dark",contrastLightColors:"600 700 800 900"},"blue-grey":{"50":"#eceff1","100":"#cfd8dc","200":"#b0bec5","300":"#90a4ae","400":"#78909c","500":"#607d8b","600":"#546e7a","700":"#455a64","800":"#37474f","900":"#263238",A100:"#cfd8dc",A200:"#b0bec5",A400:"#78909c",A700:"#455a64",contrastDefaultColor:"light",contrastDarkColors:"50 100 200 300 700",contrastStrongLightColors:"400 500 700"}})}(),function(){function b(o){function b(t,i){return i=i||{},n[t]=y(t,i),h}function k(i,r){return y(i,t.extend({},n[i]||{},r))}function y(n,t){var i=c.filter(function(n){return!t[n]});if(i.length)throw new Error("Missing colors %1 in palette %2!".replace("%1",i.join(", ")).replace("%2",n));return t}function d(n,i){if(r[n])return r[n];i=i||"default";var f=typeof i=="string"?r[i]:i,u=new nt(n);return f&&t.forEach(f.colors,function(n,i){u.colors[i]={name:n.name,hues:t.extend({},n.hues)}}),r[n]=u,u}function nt(n){function r(n){if(n=arguments.length===0?!0:!!n,n!==i.isDark){i.isDark=n;i.foregroundPalette=i.isDark?rt:it;i.foregroundShadow=i.isDark?ut:ft;var r=i.isDark?e:f,u=i.isDark?f:e;return t.forEach(r,function(n,t){var f=i.colors[t],e=u[t],r;if(f)for(r in f.hues)f.hues[r]===e[r]&&(f.hues[r]=n[r])}),i}}var i=this;i.name=n;i.colors={};i.dark=r;r(!1);u.forEach(function(n){var r=(i.isDark?e:f)[n];i[n+"Palette"]=function(u,f){var e=i.colors[n]={name:u,hues:t.extend({},r,f)};return Object.keys(e.hues).forEach(function(n){if(!r[n])throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1",n).replace("%2",i.name).replace("%3",u).replace("%4",Object.keys(r).join(", ")));}),Object.keys(e.hues).map(function(n){return e.hues[n]}).forEach(function(t){if(c.indexOf(t)==-1)throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1",t).replace("%2",i.name).replace("%3",n).replace("%4",u).replace("%5",c.join(", ")));}),i};i[n+"Color"]=function(){var t=Array.prototype.slice.call(arguments);return console.warn("$mdThemingProviderTheme."+n+"Color() has been deprecated. Use $mdThemingProviderTheme."+n+"Palette() instead."),i[n+"Palette"].apply(i,t)}})}function p(n,u){function e(n){return n===i||n===""?!0:f.THEMES[n]!==i}function o(i,r){function h(){return f=r.controller("mdTheme")||i.data("$mdThemeController"),f&&f.$mdTheme||(s=="default"?"":s)}function c(n){if(n){e(n)||u.warn("Attempted to use unregistered theme '"+n+"'. Register it with $mdThemingProvider.theme().");var t=i.data("$mdThemeName");t&&i.removeClass("md-"+t+"-theme");i.addClass("md-"+n+"-theme");i.data("$mdThemeName",n);f&&i.data("$mdThemeController",f)}}var f=r.controller("mdTheme"),o=i.attr("md-theme-watch"),l=(v||t.isDefined(o))&&o!="false";c(h());i.on("$destroy",l?n.$watch(h,c):t.noop)}var f=function(t,r){r===i&&(r=t,t=i);t===i&&(t=n);f.inherit(r,r)};return f.THEMES=t.extend({},r),f.inherit=o,f.registered=e,f.defaultTheme=function(){return s},f.generateTheme=function(n){tt(n,l)},f}n={};r={};var h,s="default",v=!1;return t.extend(n,o),p.$inject=["$rootScope","$log"],h={definePalette:b,extendPalette:k,theme:d,setNonce:function(n){l=n},setDefaultTheme:function(n){s=n},alwaysWatchTheme:function(n){v=n},generateThemesOnDemand:function(n){w=n},$get:p,_LIGHT_DEFAULT_HUES:f,_DARK_DEFAULT_HUES:e,_PALETTES:n,_THEMES:r,_parseRules:g,_rgba:a}}function k(n,t,i){return{priority:100,link:{pre:function(r,u,f){var e={$setTheme:function(t){n.registered(t)||i.warn("attempted to use unregistered theme '"+t+"'");e.$mdTheme=t}};u.data("$mdThemeController",e);e.$setTheme(t(f.mdTheme)(r));f.$observe("mdTheme",e.$setTheme)}}}}function d(n){return n}function g(i,r,u){ot(i,r);u=u.replace(/THEME_NAME/g,i.name);var f=[],e=i.colors[r],o=new RegExp(".md-"+i.name+"-theme","g"),s=new RegExp("('|\")?{{\\s*("+r+")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?","g"),h=n[e.name];return u=u.replace(/'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g,function(t,r,u,f,e){return r==="foreground"?u=="shadow"?i.foregroundShadow:i.foregroundPalette[u]||i.foregroundPalette["1"]:(u.indexOf("hue")===0&&(u=i.colors[r].hues[u]),a((n[i.colors[r].name][u]||"")[e?"contrast":"value"],f))}),t.forEach(e.hues,function(n,t){var r=u.replace(s,function(t,i,r,u,f){return a(h[n][u==="color"?"value":"contrast"],f)}),e;t!=="default"&&(r=r.replace(o,".md-"+i.name+"-theme.md-"+t));i.name=="default"&&(e=/((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g,r=r.replace(e,function(n,t,i,r){return n+", "+t+i+r}));f.push(r)}),f}function nt(i){function k(n){var f=n.contrastDefaultColor,r=n.contrastLightColors||[],i=n.contrastStrongLightColors||[],u=n.contrastDarkColors||[];typeof r=="string"&&(r=r.split(" "));typeof i=="string"&&(i=i.split(" "));typeof u=="string"&&(u=u.split(" "));delete n.contrastDefaultColor;delete n.contrastLightColors;delete n.contrastStrongLightColors;delete n.contrastDarkColors;t.forEach(n,function(e,o){function c(){return f==="light"?u.indexOf(o)>-1?v:i.indexOf(o)>-1?p:y:r.indexOf(o)>-1?i.indexOf(o)>-1?p:y:v}if(!t.isObject(e)){var h=s(e);if(!h)throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1",e).replace("%2",n.name).replace("%3",o));n[o]={value:h,contrast:c()}}})}var f=document.head,b=f?f.firstElementChild:null,e=i.has("$MD_THEME_CSS")?i.get("$MD_THEME_CSS"):"",c,a;b&&e.length!==0&&((t.forEach(n,k),c=e.split(/\}(?!(\}|'|"|;))/).filter(function(n){return n&&n.length}).map(function(n){return n.trim()+"}"}),a=new RegExp("md-("+u.join("|")+")","g"),u.forEach(function(n){o[n]=""}),c.forEach(function(n){for(var r=n.match(a),i=0,t;t=u[i];i++)if(n.indexOf(".md-"+t)>-1)return o[t]+=n;for(i=0;t=u[i];i++)if(n.indexOf(t)>-1)return o[t]+=n;return o[et]+=n}),w)||t.forEach(r,function(n){h[n.name]||tt(n.name,l)}))}function tt(n,t){var i=r[n],f=document.head,e=f?f.firstElementChild:null;h[n]||(u.forEach(function(n){for(var s=g(i,n,o[n]),u,r;s.length;)u=s.shift(),u&&(r=document.createElement("style"),r.setAttribute("md-theme-style",""),t&&r.setAttribute("nonce",t),r.appendChild(document.createTextNode(u)),f.insertBefore(r,e))}),i.colors.primary.name==i.colors.accent.name&&console.warn("$mdThemingProvider: Using the same palette for primary and accent. This violates the material design spec."),h[i.name]=!0)}function ot(t,i){if(!n[(t.colors[i]||{}).name])throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1",t.name).replace("%2",i).replace("%3",Object.keys(n).join(", ")));}function s(n){if(t.isArray(n)&&n.length==3)return n;if(/^rgb/.test(n))return n.replace(/(^\s*rgba?\(|\)\s*$)/g,"").split(",").map(function(n,t){return t==3?parseFloat(n,10):parseInt(n,10)});if(n.charAt(0)=="#"&&(n=n.substring(1)),/^([a-fA-F0-9]{3}){1,2}$/g.test(n)){var i=n.length/3,r=n.substr(0,i),u=n.substr(i,i),f=n.substr(i*2);return i===1&&(r+=r,u+=u,f+=f),[parseInt(r,16),parseInt(u,16),parseInt(f,16)]}}function a(n,i){return n?(n.length==4&&(n=t.copy(n),i?n.pop():i=n.pop()),i&&(typeof i=="number"||typeof i=="string"&&i.length)?"rgba("+n.join(",")+","+i+")":"rgb("+n.join(",")+")"):"rgb('0,0,0')"}var o;t.module("material.core.theming",["material.core.theming.palette"]).directive("mdTheme",k).directive("mdThemable",d).provider("$mdTheming",b).run(nt);var h={},n,r,it={name:"dark","1":"rgba(0,0,0,0.87)","2":"rgba(0,0,0,0.54)","3":"rgba(0,0,0,0.38)","4":"rgba(0,0,0,0.12)"},rt={name:"light","1":"rgba(255,255,255,1.0)","2":"rgba(255,255,255,0.7)","3":"rgba(255,255,255,0.5)","4":"rgba(255,255,255,0.12)"},ut="1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)",ft="",v=s("rgba(0,0,0,0.87)"),y=s("rgba(255,255,255,0.87)"),p=s("rgb(255,255,255)"),u=["primary","accent","warn","background"],et="primary",f={accent:{"default":"A200","hue-1":"A100","hue-2":"A400","hue-3":"A700"},background:{"default":"50","hue-1":"A100","hue-2":"100","hue-3":"300"}},e={background:{"default":"A400","hue-1":"800","hue-2":"900","hue-3":"A200"}};u.forEach(function(n){var t={"default":"500","hue-1":"300","hue-2":"800","hue-3":"A100"};f[n]||(f[n]=t);e[n]||(e[n]=t)});var c=["50","100","200","300","400","500","600","700","800","900","A100","A200","A400","A700"],w=!1,l=null;b.$inject=["$mdColorPalette"];k.$inject=["$mdTheming","$interpolate","$log"];d.$inject=["$mdTheming"];o={};nt.$inject=["$injector"]}(),function(){function n(n,i,r,u,f){var e;return e={translate3d:function(n,t,i,r){function u(i){return f(n,{to:i||t,addClass:r.transitionOutClass,removeClass:r.transitionInClass}).start()}return f(n,{from:t,to:i,addClass:r.transitionInClass}).start().then(function(){return u})},waitTransitionEnd:function(n,t){var f=3e3;return i(function(i){function e(t){t&&t.target!==n[0]||(t&&r.cancel(o),n.off(u.CSS.TRANSITIONEND,e),i())}t=t||{};var o=r(e,t.timeout||f);n.on(u.CSS.TRANSITIONEND,e)})},calculateZoomToOrigin:function(i,r){function v(){var n=i?i.parent():null,t=n?n.parent():null;return t?e.clientRect(t):null}var u=r.element,s=r.bounds,h=t.bind(null,n.supplant,"translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )"),c=h({centerX:0,centerY:0,scaleX:.5,scaleY:.5});if(u||s){var f=u?e.clientRect(u)||v():e.copyRect(s),o=e.copyRect(i[0].getBoundingClientRect()),l=e.centerPointFor(o),a=e.centerPointFor(f);c=h({centerX:a.x-l.x,centerY:a.y-l.y,scaleX:Math.round(100*Math.min(.5,f.width/o.width))/100,scaleY:Math.round(100*Math.min(.5,f.height/o.height))/100})}return c},toCss:function(n){function r(n,r,u){t.forEach(r.split(" "),function(n){i[n]=u})}var i={},f="left top right bottom width height x y min-width min-height max-width max-height";return t.forEach(n,function(n,e){if(!t.isUndefined(n))if(f.indexOf(e)>=0)i[e]=n+"px";else switch(e){case"transition":r(e,u.CSS.TRANSITION,n);break;case"transform":r(e,u.CSS.TRANSFORM,n);break;case"transformOrigin":r(e,u.CSS.TRANSFORM_ORIGIN,n)}}),i},toTransformCss:function(n,i,r){var f={};return t.forEach(u.CSS.TRANSFORM.split(" "),function(t){f[t]=n}),i&&(r=r||"all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important",f.transition=r),f},copyRect:function(n,i){return n?(i=i||{},t.forEach("left top right bottom width height".split(" "),function(t){i[t]=Math.round(n[t])}),i.width=i.width||i.right-i.left,i.height=i.height||i.bottom-i.top,i):null},clientRect:function(n){var i=t.element(n)[0].getBoundingClientRect(),r=function(n){return n&&n.width>0&&n.height>0};return r(i)?e.copyRect(i):null},centerPointFor:function(n){return n?{x:Math.round(n.left+n.width/2),y:Math.round(n.top+n.height/2)}:{x:0,y:0}}}}t.module("material.core").factory("$$mdAnimate",["$q","$timeout","$mdConstant","$animateCss",function(t,i,r,u){return function(f){return n(f,t,i,r,u)}}])}(),function(){t.version.minor>=4?t.module("material.core.animate",[]):function(){function u(n){return n.replace(/-[a-z]/g,function(n){return n.charAt(1).toUpperCase()})}var r=t.forEach,i=t.isDefined(document.documentElement.style.WebkitAppearance),c=i?"WebkitTransition":"transition",l=i?"WebkitAnimation":"animation",n=i?"-webkit-":"",f=(i?"webkitTransitionEnd ":"")+"transitionend",e=(i?"webkitAnimationEnd ":"")+"animationend",o=["$document",function(n){return function(){return n[0].body.clientWidth+1}}],s=["$$rAF",function(n){return function(){var t=!1;return n(function(){t=!0}),function(i){t?i():n(i)}}}],h=["$q","$$rAFMutex",function(n,i){function f(n){this.setHost(n);this._doneCallbacks=[];this._runInAnimationFrame=i();this._state=0}var e=0,o=1,u=2;return f.prototype={setHost:function(n){this.host=n||{}},done:function(n){this._state===u?n():this._doneCallbacks.push(n)},progress:t.noop,getPromise:function(){if(!this.promise){var t=this;this.promise=n(function(n,i){t.done(function(t){t===!1?i():n()})})}return this.promise},then:function(n,t){return this.getPromise().then(n,t)},"catch":function(n){return this.getPromise()["catch"](n)},"finally":function(n){return this.getPromise()["finally"](n)},pause:function(){this.host.pause&&this.host.pause()},resume:function(){this.host.resume&&this.host.resume()},end:function(){this.host.end&&this.host.end();this._resolve(!0)},cancel:function(){this.host.cancel&&this.host.cancel();this._resolve(!1)},complete:function(n){var t=this;t._state===e&&(t._state=o,t._runInAnimationFrame(function(){t._resolve(n)}))},_resolve:function(n){this._state!==u&&(r(this._doneCallbacks,function(t){t(n)}),this._doneCallbacks.length=0,this._state=u)}},f}];t.module("material.core.animate",[]).factory("$$forceReflow",o).factory("$$AnimateRunner",h).factory("$$rAFMutex",s).factory("$animateCss",["$window","$$rAF","$$AnimateRunner","$$forceReflow","$$jqLite","$timeout",function(t,o,s,h,c,l){function g(i,o){var c=[],v=p(i),y,h,a;o.transitionStyle&&c.push([n+"transition",o.transitionStyle]);o.keyframeStyle&&c.push([n+"animation",o.keyframeStyle]);o.delay&&c.push([n+"transition-delay",o.delay+"s"]);o.duration&&c.push([n+"transition-duration",o.duration+"s"]);var g=o.keyframeStyle||o.to&&(o.duration>0||o.transitionStyle),rt=!!o.addClass||!!o.removeClass,ut=g||rt;return d(i,!0),b(i,o),y=!1,{close:t.close,start:function(){function t(){if(!y)return y=!0,h&&a&&i.off(h,a),w(i,o),it(i,o),r(c,function(n){v.style[u(n[0])]=""}),p.complete(!0),p}var p=new s;return tt(function(){var s,y;if((d(i,!1),!ut)||(r(c,function(n){var t=n[0],i=n[1];v.style[u(t)]=i}),w(i,o),s=nt(i),s.duration===0))return t();y=[];o.easing&&(s.transitionDuration&&y.push([n+"transition-timing-function",o.easing]),s.animationDuration&&y.push([n+"animation-timing-function",o.easing]));o.delay&&s.animationDelay&&y.push([n+"animation-delay",o.delay+"s"]);o.duration&&s.animationDuration&&y.push([n+"animation-duration",o.duration+"s"]);r(y,function(n){var t=n[0],i=n[1];v.style[u(t)]=i;c.push(n)});var g=s.delay,p=g*1e3,b=s.duration,tt=b*1e3,it=Date.now();h=[];s.transitionDuration&&h.push(f);s.animationDuration&&h.push(e);h=h.join(" ");a=function(n){n.stopPropagation();var i=n.originalEvent||n,r=i.timeStamp||Date.now(),u=parseFloat(i.elapsedTime.toFixed(3));Math.max(r-it,0)>=p&&u>=b&&t()};i.on(h,a);k(i,o);l(t,p+tt*1.5,!1)}),p}}}function w(n,t){t.addClass&&(c.addClass(n,t.addClass),t.addClass=null);t.removeClass&&(c.removeClass(n,t.removeClass),t.removeClass=null)}function nt(n){function u(n){return i?"Webkit"+n.charAt(0).toUpperCase()+n.substr(1):n}var l=p(n),r=t.getComputedStyle(l),e=a(r[u("transitionDuration")]),f=a(r[u("animationDuration")]),o=a(r[u("transitionDelay")]),s=a(r[u("animationDelay")]),h,c;return f*=parseInt(r[u("animationIterationCount")],10)||1,h=Math.max(f,e),c=Math.max(s,o),{duration:h,delay:c,animationDuration:f,transitionDuration:e,animationDelay:s,transitionDelay:o}}function a(n){var t=0,i=(n||"").split(/\s*,\s*/);return r(i,function(n){n.charAt(n.length-1)=="s"&&(n=n.substring(0,n.length-1));n=parseFloat(n)||0;t=t?Math.max(n,t):n}),t}function tt(n){v&&v();y.push(n);v=o(function(){var t,n;for(v=null,t=h(),n=0;n<y.length;n++)y[n](t);y.length=0})}function it(n,t){b(n,t);k(n,t)}function b(n,t){t.from&&(n.css(t.from),t.from=null)}function k(n,t){t.to&&(n.css(t.to),t.to=null)}function p(n){for(var t=0;t<n.length;t++)if(n[t].nodeType===1)return n[t]}function d(t,i){var r=p(t),f=u(n+"transition-delay");r.style[f]=i?"-9999s":""}var v,y=[];return g}])}()}(),function(){t.module("material.components.autocomplete",["material.core","material.components.icon","material.components.virtualRepeat"])}(),function(){function n(n){return{restrict:"E",link:function(t){t.$on("$destroy",function(){n.destroy()})}}}function i(n){function r(n,r,f,e,o,s,h){function l(i,u,h){if(u=f.extractElementByName(u,"md-bottom-sheet"),u.attr("tabindex","-1"),!h.disableBackdrop){if(c=f.createBackdrop(i,"_md-bottom-sheet-backdrop md-opaque"),c[0].tabIndex=-1,h.clickOutsideToClose)c.on("click",function(){f.nextTick(o.cancel,!0)});e.inherit(c,h.parent);n.enter(c,h.parent,null)}var l=new v(u,h.parent);return h.bottomSheet=l,e.inherit(l.element,h.parent),h.disableParentScroll&&(h.restoreScroll=f.disableScrollAround(l.element,h.parent)),n.enter(l.element,h.parent,c).then(function(){var n=f.findFocusTarget(u)||t.element(u[0].querySelector("button")||u[0].querySelector("a")||u[0].querySelector("[ng-click]"))||c;if(h.escapeToClose){h.rootElementKeyupCallback=function(n){n.keyCode===r.KEY_CODE.ESCAPE&&f.nextTick(o.cancel,!0)};s.on("keyup",h.rootElementKeyupCallback);n&&n.focus()}})}function a(t,i,r){var u=r.bottomSheet;return r.disableBackdrop||n.leave(c),n.leave(u.element).then(function(){r.disableParentScroll&&(r.restoreScroll(),delete r.restoreScroll);u.cleanup()})}function v(n,t){function e(){n.css(r.CSS.TRANSITION_DURATION,"0ms")}function s(t){var u=t.pointer.distanceY;u<5&&(u=Math.max(-i,u/2));n.css(r.CSS.TRANSFORM,"translate3d(0,"+(i+u)+"px,0)")}function c(t){if(t.pointer.distanceY>0&&(t.pointer.distanceY>20||Math.abs(t.pointer.velocityY)>u)){var i=n.prop("offsetHeight")-t.pointer.distanceY,e=Math.min(i/t.pointer.velocityY*.75,500);n.css(r.CSS.TRANSITION_DURATION,e+"ms");f.nextTick(o.cancel,!0)}else n.css(r.CSS.TRANSITION_DURATION,""),n.css(r.CSS.TRANSFORM,"")}var l=h.register(t,"drag",{horizontal:!1});t.on("$md.dragstart",e).on("$md.drag",s).on("$md.dragend",c);return{element:n,cleanup:function(){l();t.off("$md.dragstart",e);t.off("$md.drag",s);t.off("$md.dragend",c)}}}var c;return{themable:!0,onShow:l,onRemove:a,disableBackdrop:!1,escapeToClose:!0,clickOutsideToClose:!0,disableParentScroll:!0}}var u=.5,i=80;return r.$inject=["$animate","$mdConstant","$mdUtil","$mdTheming","$mdBottomSheet","$rootElement","$mdGesture"],n("$mdBottomSheet").setDefaults({methods:["disableParentScroll","escapeToClose","clickOutsideToClose"],options:r})}t.module("material.components.bottomSheet",["material.core","material.components.backdrop"]).directive("mdBottomSheet",n).provider("$mdBottomSheet",i);n.$inject=["$mdBottomSheet"];i.$inject=["$$interimElementProvider"]}(),function(){t.module("material.components.backdrop",["material.core"]).directive("mdBackdrop",["$mdTheming","$animate","$rootElement","$window","$log","$$rAF","$document",function(n,t,i,r,u,f,e){function s(s,h){var c=r.getComputedStyle(e[0].body),l;c.position=="fixed"&&(l=parseInt(c.height,10)+Math.abs(parseInt(c.top,10)),h.css({height:l+"px"}));t.pin&&t.pin(h,i);f(function(){var t=h.parent()[0],i;t&&(t.nodeName=="BODY"&&h.css({position:"fixed"}),i=r.getComputedStyle(t),i.position=="static"&&u.warn(o));h.parent().length&&n.inherit(h,h.parent())})}var o="<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";return{restrict:"E",link:s}}])}(),function(){function n(n,i,r,u){function f(n){return t.isDefined(n.href)||t.isDefined(n.ngHref)||t.isDefined(n.ngLink)||t.isDefined(n.uiSref)}function e(n,t){if(f(t))return'<a class="md-button" ng-transclude><\/a>';var i=typeof t.type=="undefined"?"button":t.type;return'<button class="md-button" type="'+i+'" ng-transclude><\/button>'}function o(e,o,s){i(o);n.attach(e,o);r.expectWithText(o,"aria-label");f(s)&&t.isDefined(s.ngDisabled)&&e.$watch(s.ngDisabled,function(n){o.attr("tabindex",n?-1:0)});o.on("click",function(n){s.disabled===!0&&(n.preventDefault(),n.stopImmediatePropagation())});if(!t.isDefined(s.mdNoFocusStyle)){e.mouseActive=!1;o.on("mousedown",function(){e.mouseActive=!0;u(function(){e.mouseActive=!1},100)}).on("focus",function(){e.mouseActive===!1&&o.addClass("md-focused")}).on("blur",function(){o.removeClass("md-focused")})}}return{restrict:"EA",replace:!0,transclude:!0,template:e,link:o}}t.module("material.components.button",["material.core"]).directive("mdButton",n);n.$inject=["$mdButtonInkRipple","$mdTheming","$mdAria","$timeout"]}(),function(){function n(n){return{restrict:"E",link:function(t,i){n(i)}}}t.module("material.components.card",["material.core"]).directive("mdCard",n);n.$inject=["$mdTheming"]}(),function(){function n(n,i,r,u,f,e){function s(s,h){var c=s.children(),l=h.hasOwnProperty("mdIndeterminate");h.type="checkbox";h.tabindex=h.tabindex||"0";s.attr("role",h.type);s.on("click",function(n){this.hasAttribute("disabled")&&n.stopImmediatePropagation()});c.on("focus",function(){s.focus()});return function(s,h,c,a){function w(n,t,i){c[n]&&s.$watch(c[n],function(n){i[n]&&h.attr(t,i[n])})}function b(n){var t=n.which||n.keyCode;(t===r.KEY_CODE.SPACE||t===r.KEY_CODE.ENTER)&&(n.preventDefault(),h.hasClass("md-focused")||h.addClass("md-focused"),y(n))}function y(n){h[0].hasAttribute("disabled")||s.$apply(function(){var t=c.ngChecked?c.checked:!a.$viewValue;a.$setViewValue(t,n&&n.type);a.$render()})}function k(){a.$viewValue&&!v?h.addClass(o):h.removeClass(o)}function p(n){v=n!==!1;v&&h.attr("aria-checked","mixed");h.toggleClass("md-indeterminate",v)}var v;a=a||f.fakeNgModel();u(h);l&&(p(),s.$watch(c.mdIndeterminate,p));c.ngChecked&&s.$watch(s.$eval.bind(s,c.ngChecked),a.$setViewValue.bind(a));w("ngDisabled","tabindex",{"true":"-1","false":c.tabindex});i.expectWithText(h,"aria-label");n.link.pre(s,{on:t.noop,0:{}},c,[a]);s.mouseActive=!1;h.on("click",y).on("keypress",b).on("mousedown",function(){s.mouseActive=!0;e(function(){s.mouseActive=!1},100)}).on("focus",function(){s.mouseActive===!1&&h.addClass("md-focused")}).on("blur",function(){h.removeClass("md-focused")});a.$render=k}}n=n[0];var o="md-checked";return{restrict:"E",transclude:!0,require:"?ngModel",priority:210,template:'<div class="_md-container" md-ink-ripple md-ink-ripple-checkbox><div class="_md-icon"><\/div><\/div><div ng-transclude class="_md-label"><\/div>',compile:s}}t.module("material.components.checkbox",["material.core"]).directive("mdCheckbox",n);n.$inject=["inputDirective","$mdAria","$mdConstant","$mdTheming","$mdUtil","$timeout"]}(),function(){t.module("material.components.chips",["material.core","material.components.autocomplete"])}(),function(){function n(n){function t(n,t){this.$scope=n;this.$element=t}return{restrict:"E",controller:["$scope","$element",t],link:function(t,r){var u=r[0];n(r);t.$broadcast("$mdContentLoaded",r);i(r[0])}}}function i(n){t.element(n).on("$md.pressdown",function(t){t.pointer.type==="t"&&(t.$materialScrollFixed||(t.$materialScrollFixed=!0,n.scrollTop===0?n.scrollTop=1:n.scrollHeight===n.scrollTop+n.offsetHeight&&(n.scrollTop-=1)))})}t.module("material.components.content",["material.core"]).directive("mdContent",n);n.$inject=["$mdTheming"]}(),function(){(function(){function e(){return{template:'<table aria-hidden="true" class="md-calendar-day-header"><thead><\/thead><\/table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="'+(r-i)+'"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month md-month-offset="$index" class="md-calendar-month" md-start-index="ctrl.getSelectedMonthIndex()" md-item-size="'+i+'"><\/tbody><\/table><\/md-virtual-repeat-container><\/div>',scope:{minDate:"=mdMinDate",maxDate:"=mdMaxDate",dateFilter:"=mdDateFilter"},require:["ngModel","mdCalendar"],controller:n,controllerAs:"ctrl",bindToController:!0,link:function(n,t,i,r){var u=r[0],f=r[1];f.configureNgModel(u)}}}function n(n,t,i,r,u,f,e,s,h,c,l){var a,y,v;e(n);this.items={length:2e3};this.maxDate&&this.minDate&&(a=s.getMonthDistance(this.minDate,this.maxDate)+1,a=Math.max(a,1),a+=1,this.items.length=a);this.$animate=r;this.$q=u;this.$mdInkRipple=c;this.$mdUtil=l;this.keyCode=f.KEY_CODE;this.dateUtil=s;this.dateLocale=h;this.$element=n;this.$scope=i;this.calendarElement=n[0].querySelector(".md-calendar");this.calendarScroller=n[0].querySelector(".md-virtual-repeat-scroller");this.today=this.dateUtil.createDateAtMidnight();this.firstRenderableDate=this.dateUtil.incrementMonths(this.today,-this.items.length/2);this.minDate&&this.minDate>this.firstRenderableDate?this.firstRenderableDate=this.minDate:this.maxDate&&(y=this.items.length-2,this.firstRenderableDate=this.dateUtil.incrementMonths(this.maxDate,-(this.items.length-2)));this.id=o++;this.ngModelCtrl=null;this.selectedDate=null;this.displayDate=null;this.focusDate=null;this.isInitialized=!1;this.isMonthTransitionInProgress=!1;t.tabindex||n.attr("tabindex","-1");v=this;this.cellClickHandler=function(){var n=this;this.hasAttribute("data-timestamp")&&i.$apply(function(){var t=Number(n.getAttribute("data-timestamp"));v.setNgModelValue(v.dateUtil.createDateAtMidnight(t))})};this.attachCalendarEventListeners()}var i,r;t.module("material.components.datepicker",["material.core","material.components.icon","material.components.virtualRepeat"]).directive("mdCalendar",e);i=265;r=45;var u="md-calendar-selected-date",f="md-focus",o=0;n.$inject=["$element","$attrs","$scope","$animate","$q","$mdConstant","$mdTheming","$$mdDateUtil","$mdDateLocale","$mdInkRipple","$mdUtil"];n.prototype.configureNgModel=function(n){this.ngModelCtrl=n;var t=this;n.$render=function(){t.changeSelectedDate(t.ngModelCtrl.$viewValue)}};n.prototype.buildInitialCalendarDisplay=function(){this.buildWeekHeader();this.hideVerticalScrollbar();this.displayDate=this.selectedDate||this.today;this.isInitialized=!0};n.prototype.hideVerticalScrollbar=function(){var t=this.$element[0],u=t.querySelector(".md-calendar-scroll-mask"),n=this.calendarScroller,i=t.querySelector(".md-calendar-day-header").clientWidth,r=n.offsetWidth-n.clientWidth;u.style.width=i+"px";n.style.width=i+r+"px";n.style.paddingRight=r+"px"};n.prototype.attachCalendarEventListeners=function(){this.$element.on("keydown",t.bind(this,this.handleKeyEvent))};n.prototype.handleKeyEvent=function(n){var t=this;this.$scope.$apply(function(){if(n.which==t.keyCode.ESCAPE||n.which==t.keyCode.TAB){t.$scope.$emit("md-calendar-close");n.which==t.keyCode.TAB&&n.preventDefault();return}if(n.which===t.keyCode.ENTER){t.setNgModelValue(t.displayDate);n.preventDefault();return}var i=t.getFocusDateFromKeyEvent(n);i&&(i=t.boundDateByMinAndMax(i),n.preventDefault(),n.stopPropagation(),t.changeDisplayDate(i).then(function(){t.focus(i)}))})};n.prototype.getFocusDateFromKeyEvent=function(n){var t=this.dateUtil,i=this.keyCode;switch(n.which){case i.RIGHT_ARROW:return t.incrementDays(this.displayDate,1);case i.LEFT_ARROW:return t.incrementDays(this.displayDate,-1);case i.DOWN_ARROW:return n.metaKey?t.incrementMonths(this.displayDate,1):t.incrementDays(this.displayDate,7);case i.UP_ARROW:return n.metaKey?t.incrementMonths(this.displayDate,-1):t.incrementDays(this.displayDate,-7);case i.PAGE_DOWN:return t.incrementMonths(this.displayDate,1);case i.PAGE_UP:return t.incrementMonths(this.displayDate,-1);case i.HOME:return t.getFirstDateOfMonth(this.displayDate);case i.END:return t.getLastDateOfMonth(this.displayDate);default:return null}};n.prototype.getSelectedMonthIndex=function(){return this.dateUtil.getMonthDistance(this.firstRenderableDate,this.selectedDate||this.today)};n.prototype.scrollToMonth=function(n){if(this.dateUtil.isValidDate(n)){var t=this.dateUtil.getMonthDistance(this.firstRenderableDate,n);this.calendarScroller.scrollTop=t*i}};n.prototype.setNgModelValue=function(n){this.$scope.$emit("md-calendar-change",n);this.ngModelCtrl.$setViewValue(n);this.ngModelCtrl.$render()};n.prototype.focus=function(n){var i=n||this.selectedDate||this.today,r=this.calendarElement.querySelector(".md-focus"),u,t;r&&r.classList.remove(f);u=this.getDateId(i);t=document.getElementById(u);t?(t.classList.add(f),t.focus()):this.focusDate=i};n.prototype.boundDateByMinAndMax=function(n){var t=n;return this.minDate&&n<this.minDate&&(t=new Date(this.minDate.getTime())),this.maxDate&&n>this.maxDate&&(t=new Date(this.maxDate.getTime())),t};n.prototype.changeSelectedDate=function(n){var t=this,i=this.selectedDate;this.selectedDate=n;this.changeDisplayDate(n).then(function(){var r,f;i&&(r=document.getElementById(t.getDateId(i)),r&&(r.classList.remove(u),r.setAttribute("aria-selected","false")));n&&(f=document.getElementById(t.getDateId(n)),f&&(f.classList.add(u),f.setAttribute("aria-selected","true")))})};n.prototype.changeDisplayDate=function(n){var t,i;return this.isInitialized?!this.dateUtil.isValidDate(n)||this.isMonthTransitionInProgress?this.$q.when():(this.isMonthTransitionInProgress=!0,t=this.animateDateChange(n),this.displayDate=n,i=this,t.then(function(){i.isMonthTransitionInProgress=!1}),t):(this.buildInitialCalendarDisplay(),this.$q.when())};n.prototype.animateDateChange=function(n){return this.scrollToMonth(n),this.$q.when()};n.prototype.buildWeekHeader=function(){for(var t,r=this.dateLocale.firstDayOfWeek,u=this.dateLocale.shortDays,i=document.createElement("tr"),n=0;n<7;n++)t=document.createElement("th"),t.textContent=u[(n+r)%7],i.appendChild(t);this.$element.find("thead").append(i)};n.prototype.getDateId=function(n){return["md",this.id,n.getFullYear(),n.getMonth(),n.getDate()].join("-")}})()}(),function(){(function(){function i(){return{require:["^^mdCalendar","mdCalendarMonth"],scope:{offset:"=mdMonthOffset"},controller:n,controllerAs:"mdMonthCtrl",bindToController:!0,link:function(n,t,i,r){var f=r[0],u=r[1];u.calendarCtrl=f;u.generateContent();n.$watch(function(){return u.offset},function(n,t){n!=t&&u.generateContent()})}}}function n(n,t,i){this.dateUtil=t;this.dateLocale=i;this.$element=n;this.calendarCtrl=null;this.offset;this.focusAfterAppend=null}t.module("material.components.datepicker").directive("mdCalendarMonth",i);var r="md-calendar-date-today",u="md-calendar-selected-date",f="md-focus";n.$inject=["$element","$$mdDateUtil","$mdDateLocale"];n.prototype.generateContent=function(){var n=this.calendarCtrl,t=this.dateUtil.incrementMonths(n.firstRenderableDate,this.offset);this.$element.empty();this.$element.append(this.buildCalendarForMonth(t));this.focusAfterAppend&&(this.focusAfterAppend.classList.add(f),this.focusAfterAppend.focus(),this.focusAfterAppend=null)};n.prototype.buildDateCell=function(n){var i=this.calendarCtrl,t=document.createElement("td"),e,f;return t.tabIndex=-1,t.classList.add("md-calendar-date"),t.setAttribute("role","gridcell"),n&&(t.setAttribute("tabindex","-1"),t.setAttribute("aria-label",this.dateLocale.longDateFormatter(n)),t.id=i.getDateId(n),t.setAttribute("data-timestamp",n.getTime()),this.dateUtil.isSameDay(n,i.today)&&t.classList.add(r),this.dateUtil.isValidDate(i.selectedDate)&&this.dateUtil.isSameDay(n,i.selectedDate)&&(t.classList.add(u),t.setAttribute("aria-selected","true")),e=this.dateLocale.dates[n.getDate()],this.isDateEnabled(n)?(f=document.createElement("span"),t.appendChild(f),f.classList.add("md-calendar-date-selection-indicator"),f.textContent=e,t.addEventListener("click",i.cellClickHandler),i.focusDate&&this.dateUtil.isSameDay(n,i.focusDate)&&(this.focusAfterAppend=t)):(t.classList.add("md-calendar-date-disabled"),t.textContent=e)),t};n.prototype.isDateEnabled=function(n){return this.dateUtil.isDateWithinRange(n,this.calendarCtrl.minDate,this.calendarCtrl.maxDate)&&(!t.isFunction(this.calendarCtrl.dateFilter)||this.calendarCtrl.dateFilter(n))};n.prototype.buildDateRow=function(n){var t=document.createElement("tr");return t.setAttribute("role","row"),t.setAttribute("aria-label",this.dateLocale.weekNumberFormatter(n)),t};n.prototype.buildCalendarForMonth=function(n){var o=this.dateUtil.isValidDate(n)?n:new Date,s=this.dateUtil.getFirstDateOfMonth(o),h=this.getLocaleDay_(s),b=this.dateUtil.getNumberOfDaysInMonth(o),i=document.createDocumentFragment(),c=1,t=this.buildDateRow(c),l,f,a,e,w,v,u;i.appendChild(t);var y=this.offset===this.calendarCtrl.items.length-1,p=0,r=document.createElement("td");if(r.classList.add("md-calendar-month-label"),this.calendarCtrl.maxDate&&s>this.calendarCtrl.maxDate&&r.classList.add("md-calendar-month-label-disabled"),r.textContent=this.dateLocale.monthHeaderFormatter(o),h<=2){if(r.setAttribute("colspan","7"),l=this.buildDateRow(),l.appendChild(r),i.insertBefore(l,t),y)return i}else p=2,r.setAttribute("colspan","2"),t.appendChild(r);for(u=p;u<h;u++)t.appendChild(this.buildDateCell());for(f=h,a=s,e=1;e<=b;e++){if(f===7){if(y)return i;f=0;c++;t=this.buildDateRow(c);i.appendChild(t)}a.setDate(e);w=this.buildDateCell(a);t.appendChild(w);f++}while(t.childNodes.length<7)t.appendChild(this.buildDateCell());while(i.childNodes.length<6){for(v=this.buildDateRow(),u=0;u<7;u++)v.appendChild(this.buildDateCell());i.appendChild(v)}return i};n.prototype.getLocaleDay_=function(n){return(n.getDay()+(7-this.dateLocale.firstDayOfWeek))%7}})()}(),function(){(function(){t.module("material.components.datepicker").config(["$provide",function(n){function t(){this.months=null;this.shortMonths=null;this.days=null;this.shortDays=null;this.dates=null;this.firstDayOfWeek=0;this.formatDate=null;this.parseDate=null;this.monthHeaderFormatter=null;this.weekNumberFormatter=null;this.longDateFormatter=null;this.msgCalendar="";this.msgOpenCalendar=""}t.prototype.$get=function(n){function u(n){if(!n)return"";var t=n.toLocaleTimeString(),i=n;return n.getHours()==0&&(t.indexOf("11:")!==-1||t.indexOf("23:")!==-1)&&(i=new Date(n.getFullYear(),n.getMonth(),n.getDate(),1,0,0)),i.toLocaleDateString()}function f(n){return new Date(n)}function e(n){n=n.trim();return/^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/.test(n)}function o(n){return t.shortMonths[n.getMonth()]+" "+n.getFullYear()}function s(n){return"Week "+n}function h(n){return[t.days[n.getDay()],t.months[n.getMonth()],t.dates[n.getDate()],n.getFullYear()].join(" ")}for(var c=n.DATETIME_FORMATS.DAY.map(function(n){return n[0]}),r=Array(32),i=1;i<=31;i++)r[i]=i;var t={months:this.months||n.DATETIME_FORMATS.MONTH,shortMonths:this.shortMonths||n.DATETIME_FORMATS.SHORTMONTH,days:this.days||n.DATETIME_FORMATS.DAY,shortDays:this.shortDays||c,dates:this.dates||r,firstDayOfWeek:this.firstDayOfWeek||0,formatDate:this.formatDate||u,parseDate:this.parseDate||f,isDateComplete:this.isDateComplete||e,monthHeaderFormatter:this.monthHeaderFormatter||o,weekNumberFormatter:this.weekNumberFormatter||s,longDateFormatter:this.longDateFormatter||h,msgCalendar:this.msgCalendar||"Calendar",msgOpenCalendar:this.msgOpenCalendar||"Open calendar"};return t};t.prototype.$get.$inject=["$locale"];n.provider("$mdDateLocale",new t)}])})()}(),function(){(function(){function e(){return{template:'<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"><\/md-icon><\/md-button><div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input class="md-datepicker-input" aria-haspopup="true" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"><md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"><\/div><\/md-button><\/div><div class="md-datepicker-calendar-pane md-whiteframe-z1"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"><\/div><\/div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"md-date-filter="ctrl.dateFilter"ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"><\/md-calendar><\/div><\/div>',require:["ngModel","mdDatepicker","?^mdInputContainer"],scope:{minDate:"=mdMinDate",maxDate:"=mdMaxDate",placeholder:"@mdPlaceholder",dateFilter:"=mdDateFilter"},controller:i,controllerAs:"ctrl",bindToController:!0,link:function(n,t,i,r){var u=r[0],f=r[1],e=r[2];if(e)throw Error("md-datepicker should not be placed inside md-input-container.");f.configureNgModel(u)}}}function i(n,i,r,u,f,e,o,s,h,c,l,a){this.$compile=u;this.$timeout=f;this.$window=e;this.dateLocale=c;this.dateUtil=l;this.$mdConstant=o;this.$mdUtil=h;this.$$rAF=a;this.documentElement=t.element(document.documentElement);this.ngModelCtrl=null;this.inputElement=i[0].querySelector("input");this.ngInputElement=t.element(this.inputElement);this.inputContainer=i[0].querySelector(".md-datepicker-input-container");this.calendarPane=i[0].querySelector(".md-datepicker-calendar-pane");this.calendarButton=i[0].querySelector(".md-datepicker-button");this.inputMask=i[0].querySelector(".md-datepicker-input-mask-opaque");this.$element=i;this.$attrs=r;this.$scope=n;this.date=null;this.isFocused=!1;this.isDisabled;this.setDisabled(i[0].disabled||t.isString(r.disabled));this.isCalendarOpen=!1;this.calendarPaneOpenedFrom=null;this.calendarPane.id="md-date-pane"+h.nextUid();s(i);this.bodyClickHandler=t.bind(this,this.handleBodyClick);this.windowResizeHandler=h.debounce(t.bind(this,this.closeCalendarPane),100);r.tabindex||i.attr("tabindex","-1");this.installPropertyInterceptors();this.attachChangeListeners();this.attachInteractionListeners();var v=this;n.$on("$destroy",function(){v.detachCalendarPane()})}t.module("material.components.datepicker").directive("mdDatepicker",e);var o=3,f="md-datepicker-invalid",s=500,u=368,r=360;i.$inject=["$scope","$element","$attrs","$compile","$timeout","$window","$mdConstant","$mdTheming","$mdUtil","$mdDateLocale","$$mdDateUtil","$$rAF"];i.prototype.configureNgModel=function(n){this.ngModelCtrl=n;var t=this;n.$render=function(){var n=t.ngModelCtrl.$viewValue;if(n&&!(n instanceof Date))throw Error("The ng-model for md-datepicker must be a Date instance. Currently the model is a: "+typeof n);t.date=n;t.inputElement.value=t.dateLocale.formatDate(n);t.resizeInputElement();t.updateErrorState()}};i.prototype.attachChangeListeners=function(){var n=this;n.$scope.$on("md-calendar-change",function(t,i){n.ngModelCtrl.$setViewValue(i);n.date=i;n.inputElement.value=n.dateLocale.formatDate(i);n.closeCalendarPane();n.resizeInputElement();n.updateErrorState()});n.ngInputElement.on("input",t.bind(n,n.resizeInputElement));n.ngInputElement.on("input",n.$mdUtil.debounce(n.handleInputEvent,s,n))};i.prototype.attachInteractionListeners=function(){var n=this,t=this.$scope,i=this.$mdConstant.KEY_CODE;n.ngInputElement.on("keydown",function(r){r.altKey&&r.keyCode==i.DOWN_ARROW&&(n.openCalendarPane(r),t.$digest())});t.$on("md-calendar-close",function(){n.closeCalendarPane()})};i.prototype.installPropertyInterceptors=function(){var n=this,t;this.$attrs.ngDisabled&&(t=this.$scope.$parent,t&&t.$watch(this.$attrs.ngDisabled,function(t){n.setDisabled(t)}));Object.defineProperty(this,"placeholder",{get:function(){return n.inputElement.placeholder},set:function(t){n.inputElement.placeholder=t||""}})};i.prototype.setDisabled=function(n){this.isDisabled=n;this.inputElement.disabled=n;this.calendarButton.disabled=n};i.prototype.updateErrorState=function(n){var i=n||this.date,r,u;this.clearErrorState();this.dateUtil.isValidDate(i)?(i=this.dateUtil.createDateAtMidnight(i),this.dateUtil.isValidDate(this.minDate)&&(r=this.dateUtil.createDateAtMidnight(this.minDate),this.ngModelCtrl.$setValidity("mindate",i>=r)),this.dateUtil.isValidDate(this.maxDate)&&(u=this.dateUtil.createDateAtMidnight(this.maxDate),this.ngModelCtrl.$setValidity("maxdate",i<=u)),t.isFunction(this.dateFilter)&&this.ngModelCtrl.$setValidity("filtered",this.dateFilter(i))):this.ngModelCtrl.$setValidity("valid",i==null);this.ngModelCtrl.$valid||this.inputContainer.classList.add(f)};i.prototype.clearErrorState=function(){this.inputContainer.classList.remove(f);["mindate","maxdate","filtered","valid"].forEach(function(n){this.ngModelCtrl.$setValidity(n,!0)},this)};i.prototype.resizeInputElement=function(){this.inputElement.size=this.inputElement.value.length+o};i.prototype.handleInputEvent=function(){var t=this.inputElement.value,n=t?this.dateLocale.parseDate(t):null,i;this.dateUtil.setDateTimeToMidnight(n);i=t==""||this.dateUtil.isValidDate(n)&&this.dateLocale.isDateComplete(t)&&this.isDateEnabled(n);i&&(this.ngModelCtrl.$setViewValue(n),this.date=n);this.updateErrorState(n)};i.prototype.isDateEnabled=function(n){return this.dateUtil.isDateWithinRange(n,this.minDate,this.maxDate)&&(!t.isFunction(this.dateFilter)||this.dateFilter(n))};i.prototype.attachCalendarPane=function(){var n=this.calendarPane,l;n.style.transform="";this.$element.addClass("md-datepicker-open");var f=this.inputContainer.getBoundingClientRect(),t=document.body.getBoundingClientRect(),e=f.top-t.top,i=f.left-t.left,h=t.top<0&&document.body.scrollTop==0?-t.top:document.body.scrollTop,c=t.left<0&&document.body.scrollLeft==0?-t.left:document.body.scrollLeft,o=h+this.$window.innerHeight,s=c+this.$window.innerWidth;i+r>s&&(s-r>0?i=s-r:(i=c,l=this.$window.innerWidth/r,n.style.transform="scale("+l+")"),n.classList.add("md-datepicker-pos-adjusted"));e+u>o&&o-u>h&&(e=o-u,n.classList.add("md-datepicker-pos-adjusted"));n.style.left=i+"px";n.style.top=e+"px";document.body.appendChild(n);this.inputMask.style.left=f.width+"px";this.$$rAF(function(){n.classList.add("md-pane-open")})};i.prototype.detachCalendarPane=function(){this.$element.removeClass("md-datepicker-open");this.calendarPane.classList.remove("md-pane-open");this.calendarPane.classList.remove("md-datepicker-pos-adjusted");this.isCalendarOpen&&this.$mdUtil.enableScrolling();this.calendarPane.parentNode&&this.calendarPane.parentNode.removeChild(this.calendarPane)};i.prototype.openCalendarPane=function(t){if(!this.isCalendarOpen&&!this.isDisabled){this.isCalendarOpen=!0;this.calendarPaneOpenedFrom=t.target;this.$mdUtil.disableScrollAround(this.calendarPane);this.attachCalendarPane();this.focusCalendar();var i=this;this.$mdUtil.nextTick(function(){i.documentElement.on("click touchstart",i.bodyClickHandler)},!1);n.addEventListener("resize",this.windowResizeHandler)}};i.prototype.closeCalendarPane=function(){this.isCalendarOpen&&(this.detachCalendarPane(),this.isCalendarOpen=!1,this.calendarPaneOpenedFrom.focus(),this.calendarPaneOpenedFrom=null,this.ngModelCtrl.$setTouched(),this.documentElement.off("click touchstart",this.bodyClickHandler),n.removeEventListener("resize",this.windowResizeHandler))};i.prototype.getCalendarCtrl=function(){return t.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar")};i.prototype.focusCalendar=function(){var n=this;this.$mdUtil.nextTick(function(){n.getCalendarCtrl().focus()},!1)};i.prototype.setFocused=function(n){n||this.ngModelCtrl.$setTouched();this.isFocused=n};i.prototype.handleBodyClick=function(n){if(this.isCalendarOpen){var t=this.$mdUtil.getClosest(n.target,"md-calendar");t||this.closeCalendarPane();this.$scope.$digest()}}})()}(),function(){(function(){t.module("material.components.datepicker").factory("$$mdDateUtil",function(){function f(n){return new Date(n.getFullYear(),n.getMonth(),1)}function u(n){return new Date(n.getFullYear(),n.getMonth()+1,0).getDate()}function e(n){return new Date(n.getFullYear(),n.getMonth()+1,1)}function o(n){return new Date(n.getFullYear(),n.getMonth()-1,1)}function i(n,t){return n.getFullYear()===t.getFullYear()&&n.getMonth()===t.getMonth()}function h(n,t){return n.getDate()==t.getDate()&&i(n,t)}function c(n,t){var r=e(n);return i(r,t)}function l(n,t){var r=o(n);return i(t,r)}function a(t,i){return n((t.getTime()+i.getTime())/2)}function v(n){var t=f(n);return Math.floor((t.getDay()+n.getDate()-1)/7)}function y(n,t){return new Date(n.getFullYear(),n.getMonth(),n.getDate()+t)}function p(n,t){var i=new Date(n.getFullYear(),n.getMonth()+t,1),r=u(i);return r<n.getDate()?i.setDate(r):i.setDate(n.getDate()),i}function w(n,t){return 12*(t.getFullYear()-n.getFullYear())+(t.getMonth()-n.getMonth())}function b(n){return new Date(n.getFullYear(),n.getMonth(),u(n))}function r(n){return n!=null&&n.getTime&&!isNaN(n.getTime())}function s(n){r(n)&&n.setHours(0,0,0,0)}function n(n){var i;return i=t.isUndefined(n)?new Date:new Date(n),s(i),i}function k(t,i,u){var f=n(t),e=r(i)?n(i):null,o=r(u)?n(u):null;return(!e||e<=f)&&(!o||o>=f)}return{getFirstDateOfMonth:f,getNumberOfDaysInMonth:u,getDateInNextMonth:e,getDateInPreviousMonth:o,isInNextMonth:c,isInPreviousMonth:l,getDateMidpoint:a,isSameMonthAndYear:i,getWeekOfMonth:v,incrementDays:y,incrementMonths:p,getLastDateOfMonth:b,isSameDay:h,getMonthDistance:w,isValidDate:r,setDateTimeToMidnight:s,createDateAtMidnight:n,isDateWithinRange:k}})})()}(),function(){function n(n,i,r){return{restrict:"E",link:function(u,f){i(f);n(function(){function e(){f.toggleClass("md-content-overflow",n.scrollHeight>n.clientHeight)}var i,n=f[0].querySelector("md-dialog-content");if(n){i=n.getElementsByTagName("img");e();t.element(i).on("load",e)}u.$on("$destroy",function(){r.destroy(f)})})}}}function r(n){function f(n,t,i){return{template:'<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">    <h2 class="md-title">{{ dialog.title }}<\/h2>    <div ng-if="::dialog.mdHtmlContent" class="_md-dialog-content-body"         ng-bind-html="::dialog.mdHtmlContent"><\/div>    <div ng-if="::!dialog.mdHtmlContent" class="_md-dialog-content-body">      <p>{{::dialog.mdTextContent}}<\/p>    <\/div>    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" placeholder="{{::dialog.placeholder}}">    <\/md-input-container>  <\/md-dialog-content>  <md-dialog-actions>    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary">      {{ dialog.cancel }}    <\/md-button>    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type===\'alert\'">      {{ dialog.ok }}    <\/md-button>  <\/md-dialog-actions><\/md-dialog>'.replace(/\s\s+/g,""),controller:function(){this.hide=function(){n.hide(this.$type==="prompt"?this.result:!0)};this.abort=function(){n.cancel()};this.keypress=function(t){t.keyCode===i.KEY_CODE.ENTER&&n.hide(this.result)}},controllerAs:"dialog",bindToController:!0,theme:t.defaultTheme()}}function e(n,f,e,o,s,h,c,l,a,v){function p(n,t,i,r){if(r){if(r.mdHtmlContent=r.htmlContent||i.htmlContent||"",r.mdTextContent=r.textContent||i.textContent||r.content||i.content||"",r.mdHtmlContent&&!v.has("$sanitize"))throw Error("The ngSanitize module must be loaded in order to use htmlContent.");if(r.mdHtmlContent&&r.mdTextContent)throw Error("md-dialog cannot have both `htmlContent` and `textContent`");}}function w(n,i,r){function u(){var n=i[0].querySelectorAll(".md-actions");n.length>0&&a.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>.")}function f(){function u(){var n=i[0].querySelector(".dialog-close"),r;return n||(r=i[0].querySelectorAll(".md-actions button, md-dialog-actions button"),n=r[r.length-1]),t.element(n)}if(r.focusOnOpen){var n=e.findFocusTarget(i)||u();n.focus()}}return t.element(h[0].body).addClass("md-dialog-is-showing"),k(r),nt(i.find("md-dialog"),r),g(n,i,r),it(i,r).then(function(){d(i,r);tt(i,r);u();f()})}function b(n,i,f){function o(){return rt(i,f)}function e(){t.element(h[0].body).removeClass("md-dialog-is-showing");i.remove();f.$destroy||f.origin.focus()}return f.deactivateListeners(),f.unlockScreenReader(),f.hideBackdrop(f.$destroy),r&&r.parentNode&&r.parentNode.removeChild(r),u&&u.parentNode&&u.parentNode.removeChild(u),!f.$destroy?o().then(e):e()}function k(n){function r(n,r){var u=t.element(n||{}),e,f;if(u&&u.length)return e={top:0,left:0,height:0,width:0},f=t.isFunction(u[0].getBoundingClientRect),t.extend(r||{},{element:f?u:i,bounds:f?u[0].getBoundingClientRect():t.extend({},e,u[0]),focus:t.bind(u,u.focus)})}function u(n,i){if(t.isString(n)){var u=n,r=h[0].querySelectorAll(u);n=r.length?r[0]:null}return t.element(n||i)}n.origin=t.extend({element:null,bounds:null,focus:t.noop},n.origin||{});n.parent=u(n.parent,l);n.closeTo=r(u(n.closeTo));n.openFrom=r(u(n.openFrom));n.targetEvent&&(n.origin=r(n.targetEvent.target,n.origin))}function d(i,r){var l=t.element(c),a=e.debounce(function(){y(i,r)},60),s=[],v=function(){var t=r.$type=="alert"?n.hide:n.cancel;e.nextTick(t,!0)},h,f;if(r.escapeToClose){h=r.parent;f=function(n){n.keyCode===o.KEY_CODE.ESCAPE&&(n.stopPropagation(),n.preventDefault(),v())};i.on("keydown",f);h.on("keydown",f);s.push(function(){i.off("keydown",f);h.off("keydown",f)})}l.on("resize",a);if(s.push(function(){l.off("resize",a)}),r.clickOutsideToClose){var u=i,p,w=function(n){p=n.target},b=function(n){p===u[0]&&n.target===u[0]&&(n.stopPropagation(),n.preventDefault(),v())};u.on("mousedown",w);u.on("mouseup",b);s.push(function(){u.off("mousedown",w);u.off("mouseup",b)})}r.deactivateListeners=function(){s.forEach(function(n){n()});r.deactivateListeners=null}}function g(n,t,i){i.disableParentScroll&&(i.restoreScroll=e.disableScrollAround(t,i.parent));i.hasBackdrop&&(i.backdrop=e.createBackdrop(n,"_md-dialog-backdrop md-opaque"),s.enter(i.backdrop,i.parent));i.hideBackdrop=function(n){i.backdrop&&(n?i.backdrop.remove():s.leave(i.backdrop));i.disableParentScroll&&(i.restoreScroll(),delete i.restoreScroll);i.hideBackdrop=null}}function nt(n,t){var h=t.$type==="alert"?"alertdialog":"dialog",i=n.find("md-dialog-content"),s="dialogContent_"+(n.attr("id")||e.nextUid()),o;n.attr({role:h,tabIndex:"-1"});i.length===0&&(i=n);i.attr("id",s);n.attr("aria-describedby",s);t.ariaLabel?f.expect(n,"aria-label",t.ariaLabel):f.expectAsync(n,"aria-label",function(){var n=i.text().split(/\s+/);return n.length>3&&(n=n.slice(0,3).concat("...")),n.join(" ")});r=document.createElement("div");r.classList.add("_md-dialog-focus-trap");r.tabIndex=0;u=r.cloneNode(!1);o=function(){n.focus()};r.addEventListener("focus",o);u.addEventListener("focus",o);n[0].parentNode.insertBefore(r,n[0]);n.after(u)}function tt(n,t){function i(n){for(var u,t;n.parentNode;){if(n===document.body)return;for(u=n.parentNode.children,t=0;t<u.length;t++)n===u[t]||ut(u[t],["SCRIPT","STYLE"])||u[t].setAttribute("aria-hidden",r);i(n=n.parentNode)}}var r=!0;i(n[0]);t.unlockScreenReader=function(){r=!1;i(n[0]);t.unlockScreenReader=null}}function y(n,t){var u=c.getComputedStyle(h[0].body).position=="fixed",i=t.backdrop?c.getComputedStyle(t.backdrop[0]):null,r=i?Math.min(h[0].body.clientHeight,Math.ceil(Math.abs(parseInt(i.height,10)))):0;return n.css({top:(u?e.scrollTop(t.parent):0)+"px",height:r?r+"px":"100%"}),n}function it(n,t){t.parent.append(n);y(n,t);var r=n.find("md-dialog"),i=e.dom.animator,f=i.calculateZoomToOrigin,o={transitionInClass:"_md-transition-in",transitionOutClass:"_md-transition-out"},s=i.toTransformCss(f(r,t.openFrom||t.origin)),u=i.toTransformCss("");return t.fullscreen&&r.addClass("md-dialog-fullscreen"),i.translate3d(r,s,u,o).then(function(n){return t.reverseAnimate=function(){return(delete t.reverseAnimate,t.closeTo)?(o={transitionInClass:"_md-transition-out",transitionOutClass:"_md-transition-in"},s=u,u=i.toTransformCss(f(r,t.closeTo)),i.translate3d(r,s,u,o)):n(i.toTransformCss(f(r,t.origin)))},!0})}function rt(n,t){return t.reverseAnimate()}function ut(n,t){if(t.indexOf(n.nodeName)!==-1)return!0}return{hasBackdrop:!0,isolateScope:!0,onShow:w,onShowing:p,onRemove:b,clickOutsideToClose:!1,escapeToClose:!0,targetEvent:null,closeTo:null,openFrom:null,focusOnOpen:!0,disableParentScroll:!0,autoWrap:!0,fullscreen:!1,transformTemplate:function(n,t){function i(n){return t.autoWrap&&!/<\/md-dialog>/g.test(n)?"<md-dialog>"+(n||"")+"<\/md-dialog>":n||""}return'<div class="md-dialog-container" tabindex="-1">'+i(n)+"<\/div>"}}}var r,u;return f.$inject=["$mdDialog","$mdTheming","$mdConstant"],e.$inject=["$mdDialog","$mdAria","$mdUtil","$mdConstant","$animate","$document","$window","$rootElement","$log","$injector"],n("$mdDialog").setDefaults({methods:["disableParentScroll","hasBackdrop","clickOutsideToClose","escapeToClose","targetEvent","closeTo","openFrom","parent","fullscreen"],options:e}).addPreset("alert",{methods:["title","htmlContent","textContent","content","ariaLabel","ok","theme","css"],options:f}).addPreset("confirm",{methods:["title","htmlContent","textContent","content","ariaLabel","ok","cancel","theme","css"],options:f}).addPreset("prompt",{methods:["title","htmlContent","textContent","content","placeholder","ariaLabel","ok","cancel","theme","css"],options:f})}t.module("material.components.dialog",["material.core","material.components.backdrop"]).directive("mdDialog",n).provider("$mdDialog",r);n.$inject=["$$rAF","$mdTheming","$mdDialog"];r.$inject=["$$interimElementProvider"]}(),function(){function n(n){return{restrict:"E",link:n}}t.module("material.components.divider",["material.core"]).directive("mdDivider",n);n.$inject=["$mdTheming"]}(),function(){(function(){function n(){return{restrict:"E",require:["^?mdFabSpeedDial","^?mdFabToolbar"],compile:function(n){var i=n.children(),r=!1;t.forEach(["","data-","x-"],function(n){r=r||(i.attr(n+"ng-repeat")?!0:!1)});r?i.addClass("md-fab-action-item"):i.wrap('<div class="md-fab-action-item">')}}}t.module("material.components.fabActions",["material.core"]).directive("mdFabActions",n)})()}(),function(){(function(){function n(n,i,r,u,f,e){function g(){o.direction=o.direction||"down";o.isOpen=o.isOpen||!1;a();i.addClass("_md-animations-waiting")}function nt(){var r=["click","focusin","focusout"];t.forEach(r,function(n){i.on(n,v)});n.$on("$destroy",function(){t.forEach(r,function(n){i.off(n,v)});p()})}function v(n){n.type=="click"&&ct(n);n.type!="focusout"||s||(s=e(function(){o.close()},100,!1));n.type=="focusin"&&s&&(e.cancel(s),s=null)}function a(){o.currentActionIndex=-1}function tt(){n.$watch("vm.direction",function(n,t){r.removeClass(i,"md-"+t);r.addClass(i,"md-"+n);a()});var t,u;n.$watch("vm.isOpen",function(n){a();t&&u||(t=lt(),u=d());n?it():p();var f=n?"md-is-open":"",e=n?"":"md-is-open";t.attr("aria-haspopup",!0);t.attr("aria-expanded",n);u.attr("aria-hidden",!n);r.setClass(i,f,e)})}function y(){i[0].scrollHeight>0?r.addClass(i,"_md-animations-ready").then(function(){i.removeClass("_md-animations-waiting")}):h<10&&(e(y,100),h=h+1)}function it(){i.on("keydown",b);u.nextTick(function(){t.element(document).on("click touchend",w)})}function p(){i.off("keydown",b);t.element(document).off("click touchend",w)}function w(n){if(n.target){var t=u.getClosest(n.target,"md-fab-trigger"),i=u.getClosest(n.target,"md-fab-actions");t||i||o.close()}}function b(n){switch(n.which){case f.KEY_CODE.ESCAPE:return o.close(),n.preventDefault(),!1;case f.KEY_CODE.LEFT_ARROW:return ut(n),!1;case f.KEY_CODE.UP_ARROW:return ft(n),!1;case f.KEY_CODE.RIGHT_ARROW:return et(n),!1;case f.KEY_CODE.DOWN_ARROW:return ot(n),!1}}function c(n){k(n,-1)}function l(n){k(n,1)}function k(n,i){var u=rt(),r;o.currentActionIndex=o.currentActionIndex+i;o.currentActionIndex=Math.min(u.length-1,o.currentActionIndex);o.currentActionIndex=Math.max(0,o.currentActionIndex);r=t.element(u[o.currentActionIndex]).children()[0];t.element(r).attr("tabindex",0);r.focus();n.preventDefault();n.stopImmediatePropagation()}function rt(){var n=d()[0].querySelectorAll(".md-fab-action-item");return t.forEach(n,function(n){t.element(t.element(n).children()[0]).attr("tabindex",-1)}),n}function ut(n){o.direction==="left"?l(n):c(n)}function ft(n){o.direction==="down"?c(n):l(n)}function et(n){o.direction==="left"?c(n):l(n)}function ot(n){o.direction==="up"?c(n):l(n)}function st(n){return u.getClosest(n,"md-fab-trigger")}function ht(n){return u.getClosest(n,"md-fab-actions")}function ct(n){st(n.target)&&o.toggle();ht(n.target)&&o.close()}function lt(){return i.find("md-fab-trigger")}function d(){return i.find("md-fab-actions")}var o=this,h,s;o.open=function(){n.$evalAsync("vm.isOpen = true")};o.close=function(){n.$evalAsync("vm.isOpen = false");i.find("md-fab-trigger")[0].focus()};o.toggle=function(){n.$evalAsync("vm.isOpen = !vm.isOpen")};g();nt();tt();h=0;y()}t.module("material.components.fabShared",["material.core"]).controller("MdFabController",n);n.$inject=["$scope","$element","$animate","$mdUtil","$mdConstant","$timeout"]})()}(),function(){(function(){function f(){function n(n,t){t.prepend('<div class="_md-css-variables"><\/div>')}return{restrict:"E",scope:{direction:"@?mdDirection",isOpen:"=?mdOpen"},bindToController:!0,controller:"MdFabController",controllerAs:"vm",link:n}}function i(i){function r(n){i(n,u,!1)}function f(i){if(!i.hasClass("_md-animations-waiting")||i.hasClass("_md-animations-ready")){var u=i[0],e=i.controller("mdFabSpeedDial"),r=u.querySelectorAll(".md-fab-action-item"),f=u.querySelector("md-fab-trigger"),s=u.querySelector("._md-css-variables"),o=parseInt(n.getComputedStyle(s).zIndex);t.forEach(r,function(n,t){var i=n.style;i.transform=i.webkitTransform="";i.transitionDelay="";i.opacity=1;i.zIndex=r.length-t+o});f.style.zIndex=o+r.length+1;e.isOpen||t.forEach(r,function(n,t){var i,r,u=n.style,o=(f.clientHeight-n.clientHeight)/2,s=(f.clientWidth-n.clientWidth)/2,h;switch(e.direction){case"up":i=n.scrollHeight*(t+1)+o;r="Y";break;case"down":i=-(n.scrollHeight*(t+1)+o);r="Y";break;case"left":i=n.scrollWidth*(t+1)+s;r="X";break;case"right":i=-(n.scrollWidth*(t+1)+s);r="X"}h="translate"+r+"("+i+"px)";u.transform=u.webkitTransform=h})}}return{addClass:function(n,t,i){n.hasClass("md-fling")?(f(n),r(i)):i()},removeClass:function(n,t,i){f(n);r(i)}}}function r(i){function r(n){i(n,u,!1)}function f(i){var f=i[0],r=i.controller("mdFabSpeedDial"),u=f.querySelectorAll(".md-fab-action-item"),o=f.querySelector("._md-css-variables"),s=parseInt(n.getComputedStyle(o).zIndex);t.forEach(u,function(n,t){var i=n.style,f=t*e;i.opacity=r.isOpen?1:0;i.transform=i.webkitTransform=r.isOpen?"scale(1)":"scale(0)";i.transitionDelay=(r.isOpen?f:u.length-f)+"ms";i.zIndex=u.length-t+s})}var e=65;return{addClass:function(n,t,i){f(n);r(i)},removeClass:function(n,t,i){f(n);r(i)}}}var u=300;t.module("material.components.fabSpeedDial",["material.core","material.components.fabShared","material.components.fabTrigger","material.components.fabActions"]).directive("mdFabSpeedDial",f).animation(".md-fling",i).animation(".md-scale",r).service("mdFabSpeedDialFlingAnimation",i).service("mdFabSpeedDialScaleAnimation",r);i.$inject=["$timeout"];r.$inject=["$timeout"]})()}(),function(){(function(){function r(){function n(n,t){t.addClass("md-fab-toolbar");t.find("md-fab-trigger").find("button").prepend('<div class="_md-fab-toolbar-background"><\/div>')}return{restrict:"E",transclude:!0,template:'<div class="_md-fab-toolbar-wrapper">  <div class="_md-fab-toolbar-content" ng-transclude><\/div><\/div>',scope:{direction:"@?mdDirection",isOpen:"=?mdOpen"},bindToController:!0,controller:"MdFabController",controllerAs:"vm",link:n}}function i(){function i(i,r){if(r){var f=i[0],l=i.controller("mdFabToolbar"),u=f.querySelector("._md-fab-toolbar-background"),e=f.querySelector("md-fab-trigger button"),h=f.querySelector("md-toolbar"),o=f.querySelector("md-fab-trigger button md-icon"),s=i.find("md-fab-actions").children();if(e&&u){var a=n.getComputedStyle(e).getPropertyValue("background-color"),c=f.offsetWidth,y=f.offsetHeight,v=2*(c/e.offsetWidth);u.style.backgroundColor=a;u.style.borderRadius=c+"px";l.isOpen?(h.style.pointerEvents="auto",u.style.width=e.offsetWidth+"px",u.style.height=e.offsetHeight+"px",u.style.transform="scale("+v+")",u.style.transitionDelay="0ms",o&&(o.style.transitionDelay=".3s"),t.forEach(s,function(n,t){n.style.transitionDelay=(s.length-t)*25+"ms"})):(h.style.pointerEvents="none",u.style.transform="scale(1)",u.style.top="0",i.hasClass("md-right")&&(u.style.left="0",u.style.right=null),i.hasClass("md-left")&&(u.style.right="0",u.style.left=null),u.style.transitionDelay="200ms",o&&(o.style.transitionDelay="0ms"),t.forEach(s,function(n,t){n.style.transitionDelay=200+t*25+"ms"}))}}}return{addClass:function(n,t,r){i(n,t,r);r()},removeClass:function(n,t,r){i(n,t,r);r()}}}t.module("material.components.fabToolbar",["material.core","material.components.fabShared","material.components.fabTrigger","material.components.fabActions"]).directive("mdFabToolbar",r).animation(".md-fab-toolbar",i).service("mdFabToolbarAnimation",i)})()}(),function(){function i(i,r,u,f){function e(n,e,o,s){function g(){for(var n in r.MEDIA)f(n),f.getQuery(r.MEDIA[n]).addListener(v);return f.watchResponsiveAttributes(["md-cols","md-row-height","md-gutter"],o,tt)}function nt(){s.layoutDelegate=t.noop;y();for(var n in r.MEDIA)f.getQuery(r.MEDIA[n]).removeListener(v)}function tt(n){n==null?s.invalidateLayout():f(n)&&s.invalidateLayout()}function it(i){var f=ft(),r={tileSpans:et(f),colCount:ot(),rowMode:k(),rowHeight:ht(),gutter:st()},o;(i||!t.equals(r,p))&&(o=u(r.colCount,r.tileSpans,f).map(function(n,i){return{grid:{element:e,style:ut(r.colCount,i,r.gutter,r.rowMode,r.rowHeight)},tiles:n.map(function(n,u){return{element:t.element(f[u]),style:rt(n.position,n.spans,r.colCount,i,r.gutter,r.rowMode,r.rowHeight)}})}}).reflow().performance(),n.mdOnLayout({$event:{performance:o}}),p=r)}function h(n){return w+n+b}function rt(n,t,i,r,u,f,e){var v=100/i,y=(i-1)/i,p=l({share:v,gutterShare:y,gutter:u}),o={left:a({unit:p,offset:n.col,gutter:u}),width:c({unit:p,span:t.col,gutter:u}),paddingTop:"",marginTop:"",top:"",height:""},h,s;switch(f){case"fixed":o.top=a({unit:e,offset:n.row,gutter:u});o.height=c({unit:e,span:t.row,gutter:u});break;case"ratio":h=v/e;s=l({share:h,gutterShare:y,gutter:u});o.paddingTop=c({unit:s,span:t.row,gutter:u});o.marginTop=a({unit:s,offset:n.row,gutter:u});break;case"fit":var w=(r-1)/r,h=100/r,s=l({share:h,gutterShare:w,gutter:u});o.top=a({unit:s,offset:n.row,gutter:u});o.height=c({unit:s,span:t.row,gutter:u})}return o}function ut(n,t,i,r,u){var f={};switch(r){case"fixed":f.height=c({unit:u,span:t,gutter:i});f.paddingBottom="";break;case"ratio":var e=n===1?0:(n-1)/n,o=100/n,s=o*(1/u),h=l({share:s,gutterShare:e,gutter:i});f.height="";f.paddingBottom=c({unit:h,span:t,gutter:i})}return f}function ft(){return[].filter.call(e.children(),function(n){return n.tagName=="MD-GRID-TILE"&&!n.$$mdDestroyed})}function et(n){return[].map.call(n,function(n){var i=t.element(n).controller("mdGridTile");return{row:parseInt(f.getResponsiveAttribute(i.$attrs,"md-rowspan"),10)||1,col:parseInt(f.getResponsiveAttribute(i.$attrs,"md-colspan"),10)||1}})}function ot(){var n=parseInt(f.getResponsiveAttribute(o,"md-cols"),10);if(isNaN(n))throw"md-grid-list: md-cols attribute was not found, or contained a non-numeric value";return n}function st(){return d(f.getResponsiveAttribute(o,"md-gutter")||1)}function ht(){var n=f.getResponsiveAttribute(o,"md-row-height"),t;if(!n)throw"md-grid-list: md-row-height attribute was not found";switch(k()){case"fixed":return d(n);case"ratio":return t=n.split(":"),parseFloat(t[0])/parseFloat(t[1]);case"fit":return 0}}function k(){var n=f.getResponsiveAttribute(o,"md-row-height");if(!n)throw"md-grid-list: md-row-height attribute was not found";return n=="fit"?"fit":n.indexOf(":")!==-1?"ratio":"fixed"}function d(n){return/\D$/.test(n)?n:n+"px"}var v,y,p,w,b;e.attr("role","list");s.layoutDelegate=it;v=t.bind(s,s.invalidateLayout);y=g();n.$on("$destroy",nt);w=i.startSymbol();b=i.endSymbol();var l=i(h("share")+"% - ("+h("gutter")+" * "+h("gutterShare")+")"),a=i("calc(("+h("unit")+" + "+h("gutter")+") * "+h("offset")+")"),c=i("calc(("+h("unit")+") * "+h("span")+" + ("+h("span")+" - 1) * "+h("gutter")+")")}return{restrict:"E",controller:n,scope:{mdOnLayout:"&"},link:e}}function n(n){this.layoutInvalidated=!1;this.tilesInvalidated=!1;this.$timeout_=n.nextTick;this.layoutDelegate=t.noop}function r(n){function r(t,r){var u,c,e,o,s,h;return o=n.time(function(){c=f(t,r)}),u={layoutInfo:function(){return c},map:function(t){return s=n.time(function(){var n=u.layoutInfo();e=t(n.positioning,n.rowCount)}),u},reflow:function(t){return h=n.time(function(){var n=t||i;n(e.grid,e.tiles)}),u},performance:function(){return{tileCount:r.length,layoutTime:o,mapTime:s,reflowTime:h,totalTime:o+s+h}}}}function u(n,t){n.element.css(n.style);t.forEach(function(n){n.element.css(n.style)})}function f(n,t){function o(t,o){if(t.col>n)throw"md-grid-list: Tile at position "+o+" has a colspan ("+t.col+") that exceeds the column count ("+n+")";for(var h=0,c=0;c-h<t.col;){if(r>=n){f();continue}if(h=i.indexOf(0,r),h===-1||(c=s(h+1))===-1){h=c=0;f();continue}r=c+1}return e(h,t.col,t.row),r=h+t.col,{col:h,row:u}}function f(){r=0;u++;e(0,n,-1)}function e(n,t,r){for(var u=n;u<n+t;u++)i[u]=Math.max(i[u]+r,0)}function s(n){for(var t=n;t<i.length;t++)if(i[t]!==0)return t;if(t===i.length)return t}function h(){for(var t=[],i=0;i<n;i++)t.push(0);return t}var r=0,u=0,i=h();return{positioning:t.map(function(n,t){return{spans:n,position:o(n,t)}}),rowCount:u+Math.max.apply(Math,i)}}var i=u;return r.animateWith=function(n){i=t.isFunction(n)?n:u},r}function u(n){function i(i,r,u,f){r.attr("role","listitem");var e=n.watchResponsiveAttributes(["md-colspan","md-rowspan"],u,t.bind(f,f.invalidateLayout));f.invalidateTiles();i.$on("$destroy",function(){r[0].$$mdDestroyed=!0;e();f.invalidateLayout()});t.isDefined(i.$parent.$index)&&i.$watch(function(){return i.$parent.$index},function(n,t){n!==t&&f.invalidateTiles()})}return{restrict:"E",require:"^mdGridList",template:"<figure ng-transclude><\/figure>",transclude:!0,scope:{},controller:["$attrs",function(n){this.$attrs=n}],link:i}}function f(){return{template:"<figcaption ng-transclude><\/figcaption>",transclude:!0}}t.module("material.components.gridList",["material.core"]).directive("mdGridList",i).directive("mdGridTile",u).directive("mdGridTileFooter",f).directive("mdGridTileHeader",f).factory("$mdGridLayout",r);i.$inject=["$interpolate","$mdConstant","$mdGridLayout","$mdMedia"];n.$inject=["$mdUtil"];n.prototype={invalidateTiles:function(){this.tilesInvalidated=!0;this.invalidateLayout()},invalidateLayout:function(){this.layoutInvalidated||(this.layoutInvalidated=!0,this.$timeout_(t.bind(this,this.layout)))},layout:function(){try{this.layoutDelegate(this.tilesInvalidated)}finally{this.layoutInvalidated=!1;this.tilesInvalidated=!1}}};r.$inject=["$mdUtil"];u.$inject=["$mdMedia"]}(),function(){(function(){function n(){return{restrict:"E",require:["^?mdFabSpeedDial","^?mdFabToolbar"]}}t.module("material.components.fabTrigger",["material.core"]).directive("mdFabTrigger",n)})()}(),function(){t.module("material.components.icon",["material.core"])}(),function(){function e(n,t){function e(t,i){n(i);var r=i[0].querySelector(u),e=i[0].querySelector(f);r&&i.addClass("md-icon-left");e&&i.addClass("md-icon-right")}function r(n,i,r,u){var f=this;f.isErrorGetter=r.mdIsError&&t(r.mdIsError);f.delegateClick=function(){f.input.focus()};f.element=i;f.setFocused=function(n){i.toggleClass("md-input-focused",!!n)};f.setHasValue=function(n){i.toggleClass("md-input-has-value",!!n)};f.setHasPlaceholder=function(n){i.toggleClass("md-input-has-placeholder",!!n)};f.setInvalid=function(n){n?u.addClass(i,"md-input-invalid"):u.removeClass(i,"md-input-invalid")};n.$watch(function(){return f.label&&f.input},function(n){n&&!f.label.attr("for")&&f.label.attr("for",f.input.attr("id"))})}var i=["INPUT","TEXTAREA","SELECT","MD-SELECT"],u=i.reduce(function(n,t){return n.concat(["md-icon ~ "+t,".md-icon ~ "+t])},[]).join(","),f=i.reduce(function(n,t){return n.concat([t+" ~ md-icon",t+" ~ .md-icon"])},[]).join(",");return r.$inject=["$scope","$element","$attrs","$animate"],{restrict:"E",link:e,controller:r}}function w(){return{restrict:"E",require:"^?mdInputContainer",link:function(n,t,i,r){!r||i.mdNoFloat||t.hasClass("_md-container-ignore")||(r.label=t,n.$on("$destroy",function(){r.label=null}))}}}function r(n,i,r,u){function f(f,e,o,s){function w(n){return h.setHasValue(!c.$isEmpty(n)),n}function d(){h.label&&o.$observe("required",function(n){h.label.toggleClass("md-required",n&&!k)})}function l(){h.setHasValue(e.val().length>0||(e[0].validity||{}).badInput)}function g(){function s(){var n,t,i;e.addClass("md-no-flex").attr("rows",1);h?(l||(r.style.minHeight=0,l=e.prop("clientHeight"),r.style.minHeight=null),n=Math.round(Math.round(v()/l)),t=Math.min(n,h),e.css("height",l*t+"px").attr("rows",t).toggleClass("_md-textarea-scrollable",n>=h)):(e.css("height","auto"),r.scrollTop=0,i=v(),i&&e.css("height",i+"px"));e.removeClass("md-no-flex")}function v(){var n=r.offsetHeight,t=r.scrollHeight-n;return n+(t>0?t:0)}function w(){r.scrollTop=0;var n=r.scrollHeight-r.offsetHeight,t=r.offsetHeight+n;r.style.height=t+"px"}function y(n){return s(),n}var p;if(!o.hasOwnProperty("mdNoAutogrow")){var h=o.hasOwnProperty("rows")?parseInt(o.rows):NaN,l=null,r=e[0];if(u(function(){n.nextTick(s)},10,!1),a)c.$formatters.unshift(y),c.$parsers.unshift(y);else e.on("input",s);if(!h)e.attr("rows",1).on("scroll",w);t.element(i).on("resize",s);f.$on("$destroy",function(){t.element(i).off("resize",s)});o.hasOwnProperty("mdDetectHidden")&&(p=function(){var n=!1;return function(){var t=r.offsetHeight===0;t===!1&&n===!0&&s();n=t}}(),f.$watch(function(){return n.nextTick(p,!1),!0}))}}var h=s[0],a=!!s[1],c=s[1]||n.fakeNgModel(),b=t.isDefined(o.readonly),k=n.parseAttributeBoolean(o.mdNoAsterisk),v,y,p;if(h){if(o.type==="hidden"){e.attr("aria-hidden","true");return}if(h.input)throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");h.input=e;d();v=t.element('<div class="md-errors-spacer">');e.after(v);h.label||r.expect(e,"aria-label",e.attr("placeholder"));e.addClass("md-input");e.attr("id")||e.attr("id","input_"+n.nextUid());e[0].tagName.toLowerCase()==="textarea"&&g();a||l();y=h.isErrorGetter||function(){return c.$invalid&&(c.$touched||p())};p=function(){var i=n.getClosest(e,"form"),r=i?t.element(i).controller("form"):null;return r?r.$submitted:!1};f.$watch(y,h.setInvalid);c.$parsers.push(w);c.$formatters.push(w);e.on("input",l);if(!b)e.on("focus",function(){n.nextTick(function(){h.setFocused(!0)})}).on("blur",function(){n.nextTick(function(){h.setFocused(!1);l()})});f.$on("$destroy",function(){h.setFocused(!1);h.setHasValue(!1);h.input=null})}}return{restrict:"E",require:["^?mdInputContainer","?ngModel"],link:f}}function o(n,i){function r(r,u,f,e){function h(n){return o.parent?(o.text(String(u.val()||n||"").length+"/"+s),n):n}var s,c=e[0],a=e[1],o,l;i.nextTick(function(){l=t.element(a.element[0].querySelector(".md-errors-spacer"));o=t.element('<div class="md-char-counter">');l.append(o);f.$set("ngTrim","false");c.$formatters.push(h);c.$viewChangeListeners.push(h);u.on("input keydown keyup",function(){h()});r.$watch(f.mdMaxlength,function(i){s=i;t.isNumber(i)&&i>0?(o.parent().length||n.enter(o,l),h()):n.leave(o)});c.$validators["md-maxlength"]=function(n,i){return!t.isNumber(s)||s<0?!0:(n||u.val()||i||"").length<=s}})}return{restrict:"A",require:["ngModel","^mdInputContainer"],link:r}}function s(){function n(n,i,r,u){var f,e,o,s;if(u){if(f=u.element.find("label"),e=t.isDefined(u.element.attr("md-no-float")),f&&f.length||e){u.setHasPlaceholder(!0);return}o=r.placeholder;i.removeAttr("placeholder");u.input&&u.input[0].nodeName!="MD-SELECT"&&(s='<label ng-click="delegateClick()">'+o+"<\/label>",u.element.addClass("md-icon-float"),u.element.prepend(s))}}return{restrict:"A",require:"^^?mdInputContainer",priority:200,link:n}}function h(n){function t(t,i){function u(){r=!0;n(function(){i[0].select();r=!1},1,!1)}function f(n){r&&n.preventDefault()}if(i[0].nodeName==="INPUT"||i[0].nodeName==="TEXTAREA"){var r=!1;i.on("focus",u).on("mouseup",f);t.$on("$destroy",function(){i.off("focus",u).off("mouseup",f)})}}return{restrict:"A",link:t}}function k(){function n(n,i,r,u){u&&(i.toggleClass("md-input-messages-animation",!0),i.toggleClass("md-auto-hide",!0),(r.mdAutoHide=="false"||t(r))&&i.toggleClass("md-auto-hide",!1))}function t(n){return b.some(function(t){return n[t]})}return{restrict:"EA",link:n,require:"^^?mdInputContainer"}}function u(n){function t(t){var i=n.getClosest(t,"md-input-container");if(i)return t.toggleClass("md-input-message-animation",!0),{}}return{restrict:"EA",compile:t,priority:100}}function c(n,t){return{addClass:function(r,u,e){var o=i(r);u=="md-input-invalid"&&o.hasClass("md-auto-hide")?f(r,t,n).finally(e):e()}}}function l(n,t){return{enter:function(i,r){f(i,t,n).finally(r)},leave:function(i,r){v(i,t,n).finally(r)},addClass:function(i,r,u){r=="ng-hide"?v(i,t,n).finally(u):u()},removeClass:function(i,r,u){r=="ng-hide"?f(i,t,n).finally(u):u()}}}function a(n){return{enter:function(t,r){var u=i(t);if(u.hasClass("md-auto-hide")){r();return}return y(t,n)},leave:function(t){return p(t,n)}}}function f(n,r,u){var f=[],e,o=i(n);return t.forEach(o.children(),function(n){e=y(t.element(n),r);f.push(e.start())}),u.all(f)}function v(n,r,u){var f=[],e,o=i(n);return t.forEach(o.children(),function(n){e=p(t.element(n),r);f.push(e.start())}),u.all(f)}function y(n,t){var i=n[0].offsetHeight;return t(n,{event:"enter",structural:!0,from:{opacity:0,"margin-top":-i+"px"},to:{opacity:1,"margin-top":"0"},duration:.3})}function p(t,i){var r=t[0].offsetHeight,u=n.getComputedStyle(t[0]);return u.opacity==0?i(t,{}):i(t,{event:"leave",structural:!0,from:{opacity:1,"margin-top":0},to:{opacity:0,"margin-top":-r+"px"},duration:.3})}function d(n){var t=n.controller("mdInputContainer");return t.element}function i(n){var i=d(n);return t.element(i[0].querySelector(".md-input-messages-animation"))}t.module("material.components.input",["material.core"]).directive("mdInputContainer",e).directive("label",w).directive("input",r).directive("textarea",r).directive("mdMaxlength",o).directive("placeholder",s).directive("ngMessages",k).directive("ngMessage",u).directive("ngMessageExp",u).directive("mdSelectOnFocus",h).animation(".md-input-invalid",c).animation(".md-input-messages-animation",l).animation(".md-input-message-animation",a);e.$inject=["$mdTheming","$parse"];r.$inject=["$mdUtil","$window","$mdAria","$timeout"];o.$inject=["$animate","$mdUtil"];s.$inject=["$log"];h.$inject=["$timeout"];var b=["ngIf","ngShow","ngHide","ngSwitchWhen","ngSwitchDefault"];u.$inject=["$mdUtil"];c.$inject=["$q","$animateCss"];l.$inject=["$q","$animateCss"];a.$inject=["$animateCss"]}(),function(){function n(n){return{restrict:"E",compile:function(t){return t[0].setAttribute("role","list"),n}}}function i(n,i,r,u){var f=["md-checkbox","md-switch"];return{restrict:"E",controller:"MdListController",compile:function(e,o){function b(){for(var t,u=["md-switch","md-checkbox"],n,i=0,r;r=u[i];++i)if((n=e.find(r)[0])&&!n.hasAttribute("aria-label")){if(t=e.find("p")[0],!t)return;n.setAttribute("aria-label","Toggle "+t.textContent)}}function a(n){if(n=="div")s=t.element('<div class="_md-no-style _md-list-item-inner">'),s.append(e.contents()),e.addClass("_md-proxy-focus");else{s=t.element('<div class="md-button _md-no-style">   <div class="_md-list-item-inner"><\/div><\/div>');var i=t.element('<md-button class="_md-no-style" md-no-focus-style><\/md-button>');i[0].setAttribute("aria-label",e[0].textContent);v(e[0],i[0]);s.prepend(i);s.children().eq(1).append(e.contents());e.addClass("_md-button-wrap")}e[0].setAttribute("tabindex","-1");e.append(s)}function k(){var n=t.element('<div class="_md-secondary-container">'),i;t.forEach(p,function(t){d(t,n)});i=t.element('<div class="flex"><\/div>');s.append(i);s.append(n)}function d(i,r){if(i&&!nt(i)&&i.hasAttribute("ng-click")){n.expect(i,"aria-label");var u=t.element('<md-button class="md-secondary md-icon-button">');v(i,u[0]);i.setAttribute("tabindex","-1");u.append(i);i=u[0]}i&&(!y(i)||!o.ngClick&&g(i))&&t.element(i).removeClass("md-secondary");e.addClass("md-with-secondary");r.append(i)}function v(n,i){t.forEach(["ng-if","ng-click","aria-label","ng-disabled","ui-sref","href","ng-href","ng-attr-ui-sref","ui-sref-opts"],function(t){n.hasAttribute(t)&&(i.setAttribute(t,n.getAttribute(t)),n.removeAttribute(t))})}function g(n){return f.indexOf(n.nodeName.toLowerCase())!=-1}function nt(n){var t=n.nodeName.toUpperCase();return t=="MD-BUTTON"||t=="BUTTON"}function y(n){for(var i=n.attributes,t=0;t<i.length;t++)if(o.$normalize(i[t].name)==="ngClick")return!0;return!1}function tt(n,e,o,s){function w(){l&&l.children&&!a&&t.forEach(f,function(n){t.forEach(l.querySelectorAll(n+":not(.md-secondary)"),function(n){c.push(n)})})}function b(){(c.length==1||a)&&(e.addClass("md-clickable"),a||s.attachRipple(n,t.element(e[0].querySelector("._md-no-style"))))}var c=[],l=e[0].firstElementChild,p=e.hasClass("_md-button-wrap"),h=p?l.firstElementChild:l,a=h&&y(h),v;if(w(),b(),e.hasClass("_md-proxy-focus")&&c.length&&t.forEach(c,function(i){i=t.element(i);n.mouseActive=!1;i.on("mousedown",function(){n.mouseActive=!0;u(function(){n.mouseActive=!1},100)}).on("focus",function(){n.mouseActive===!1&&e.addClass("md-focused");i.on("blur",function t(){e.removeClass("md-focused");i.off("blur",t)})})}),v=function(n){if(n.target.nodeName!="INPUT"&&n.target.nodeName!="TEXTAREA"&&!n.target.isContentEditable){var t=n.which||n.keyCode;t==i.KEY_CODE.SPACE&&h&&(h.click(),n.preventDefault(),n.stopPropagation())}},a||c.length||h&&h.addEventListener("keypress",v),e.off("click"),e.off("keypress"),c.length==1&&h)e.children().eq(0).on("click",function(n){var i=r.getClosest(n.target,"BUTTON");!i&&h.contains(n.target)&&t.forEach(c,function(i){n.target===i||i.contains(n.target)||t.element(i).triggerHandler("click")})});n.$on("$destroy",function(){h&&h.removeEventListener("keypress",v)})}var p=e[0].querySelectorAll(".md-secondary"),c,w,s=e,h,l;if(e[0].setAttribute("role","listitem"),o.ngClick||o.ngHref||o.href||o.uiSref||o.ngAttrUiSref)a("button");else{for(h=0;l=f[h];++h)if(w=e[0].querySelector(l)){c=!0;break}c?a("div"):e[0].querySelector("md-button:not(.md-secondary):not(.md-exclude)")||e.addClass("_md-no-proxy")}return k(),b(),tt}}}function r(n,t,i){function u(n,t){i.attach(n,t,{})}var r=this;r.attachRipple=u}t.module("material.components.list",["material.core"]).controller("MdListController",r).directive("mdList",n).directive("mdListItem",i);n.$inject=["$mdTheming"];i.$inject=["$mdAria","$mdConstant","$mdUtil","$timeout"];r.$inject=["$scope","$element","$mdListInkRipple"]}(),function(){t.module("material.components.menuBar",["material.core","material.components.menu"])}(),function(){t.module("material.components.menu",["material.core","material.components.backdrop"])}(),function(){t.module("material.components.progressCircular",["material.core"])}(),function(){function n(n,i,r){function h(n){return n.attr("aria-valuemin",0),n.attr("aria-valuemax",100),n.attr("role","progressbar"),c}function c(h,c,l){function d(){l.$observe("value",function(n){var t=s(n);c.attr("aria-valuenow",t);y()!=e&&p(k,t)});l.$observe("mdBufferValue",function(n){p(b,s(n))});l.$observe("mdMode",function(n){a&&v.removeClass(a);switch(n){case e:case o:case f:case u:v.addClass(a="_md-mode-"+n);break;default:v.addClass(a="_md-mode-"+u)}})}function g(){if(t.isUndefined(l.mdMode)){var e=t.isDefined(l.value),n=e?f:u;r.debug(i.supplant("Auto-adding the missing md-mode='{0}' to the ProgressLinear element",[n]));c.attr("md-mode",n);l.mdMode=n}}function y(){var n=(l.mdMode||"").trim();if(n)switch(n){case f:case u:case o:case e:break;default:n=u}return n}function p(n,r){if(y()){var u=i.supplant("translateX({0}%) scale({1},1)",[(r-100)/2,r/100]),f=w({transform:u});t.element(n).css(f)}}n(c);var a,w=i.dom.animator.toCss,b=t.element(c[0].querySelector("._md-bar1")),k=t.element(c[0].querySelector("._md-bar2")),v=t.element(c[0].querySelector("._md-container"));c.attr("md-mode",y());g();d()}function s(n){return Math.max(0,Math.min(n||0,100))}var f="determinate",u="indeterminate",o="buffer",e="query";return{restrict:"E",template:'<div class="_md-container"><div class="_md-dashed"><\/div><div class="_md-bar _md-bar1"><\/div><div class="_md-bar _md-bar2"><\/div><\/div>',compile:h}}t.module("material.components.progressLinear",["material.core"]).directive("mdProgressLinear",n);n.$inject=["$mdTheming","$mdUtil","$log"]}(),function(){function n(n,i,r,u){function o(f,e,o,s){function c(){e.hasClass("md-focused")||e.addClass("md-focused")}function a(r){var f=r.which||r.keyCode,u;if(f==i.KEY_CODE.ENTER||r.currentTarget==r.target)switch(f){case i.KEY_CODE.LEFT_ARROW:case i.KEY_CODE.UP_ARROW:r.preventDefault();h.selectPrevious();c();break;case i.KEY_CODE.RIGHT_ARROW:case i.KEY_CODE.DOWN_ARROW:r.preventDefault();h.selectNext();c();break;case i.KEY_CODE.ENTER:u=t.element(n.getClosest(e[0],"form"));u.length>0&&u.triggerHandler("submit")}}r(e);var h=s[0],l=s[1]||n.fakeNgModel();h.init(l);f.mouseActive=!1;e.attr({role:"radiogroup",tabIndex:e.attr("tabindex")||"0"}).on("keydown",a).on("mousedown",function(){f.mouseActive=!0;u(function(){f.mouseActive=!1},100)}).on("focus",function(){f.mouseActive===!1&&h.$element.addClass("md-focused")}).on("blur",function(){h.$element.removeClass("md-focused")})}function f(n){this._radioButtonRenderFns=[];this.$element=n}function s(){return{init:function(n){this._ngModelCtrl=n;this._ngModelCtrl.$render=t.bind(this,this.render)},add:function(n){this._radioButtonRenderFns.push(n)},remove:function(n){var t=this._radioButtonRenderFns.indexOf(n);t!==-1&&this._radioButtonRenderFns.splice(t,1)},render:function(){this._radioButtonRenderFns.forEach(function(n){n()})},setViewValue:function(n,t){this._ngModelCtrl.$setViewValue(n,t);this.render()},getViewValue:function(){return this._ngModelCtrl.$viewValue},selectNext:function(){return e(this.$element,1)},selectPrevious:function(){return e(this.$element,-1)},setActiveDescendant:function(n){this.$element.attr("aria-activedescendant",n)}}}function e(i,r){var u=n.iterator(i[0].querySelectorAll("md-radio-button"),!0);if(u.count()){var f=function(n){return!t.element(n).attr("disabled")},e=i[0].querySelector("md-radio-button.md-checked"),o=u[r<0?"previous":"next"](e,f)||u.first();t.element(o).triggerHandler("click")}}return f.prototype=s(),{restrict:"E",controller:["$element",f],require:["mdRadioGroup","?ngModel"],link:{pre:o}}}function i(n,t,i){function u(u,f,e,o){function c(){if(!o)throw"RadioGroupController not found.";o.add(s);e.$observe("value",s);f.on("click",l).on("$destroy",function(){o.remove(s)})}function l(n){f[0].hasAttribute("disabled")||u.$apply(function(){o.setViewValue(e.value,n&&n.type)})}function s(){function t(n){f.parent()[0].nodeName!="MD-RADIO-GROUP"&&f.parent()[!n?"removeClass":"addClass"](r)}var n=o.getViewValue()==e.value;n!==h&&(h=n,f.attr("aria-checked",n),n?(t(!0),f.addClass(r),o.setActiveDescendant(f.attr("id"))):(t(!1),f.removeClass(r)))}function a(i,r){function u(){return e.id||"radio_"+t.nextUid()}r.ariaId=u();i.attr({id:r.ariaId,role:"radio","aria-checked":"false"});n.expectWithText(i,"aria-label")}var h;i(f);a(f,u);c()}var r="md-checked";return{restrict:"E",require:"^mdRadioGroup",transclude:!0,template:'<div class="_md-container" md-ink-ripple md-ink-ripple-checkbox><div class="_md-off"><\/div><div class="_md-on"><\/div><\/div><div ng-transclude class="_md-label"><\/div>',link:u}}t.module("material.components.radioButton",["material.core"]).directive("mdRadioGroup",n).directive("mdRadioButton",i);n.$inject=["$mdUtil","$mdConstant","$mdTheming","$timeout"];i.$inject=["$mdAria","$mdUtil","$mdTheming"]}(),function(){function r(n,r,u,f,e,o){function s(e,s){var h=t.element("<md-select-value><span><\/span><\/md-select-value>"),c,a;h.append('<span class="_md-select-icon" aria-hidden="true"><\/span>');h.addClass("_md-select-value");h[0].hasAttribute("id")||h.attr("id","select_value_label_"+r.nextUid());e.find("md-content").length||e.append(t.element("<md-content>").append(e.contents()));s.mdOnOpen&&(e.find("md-content").prepend(t.element('<div> <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone" md-diameter="25px"><\/md-progress-circular><\/div>')),e.find("md-option").attr("ng-show","$$loadingAsyncDone"));s.name&&(c=t.element('<select class="_md-visually-hidden">'),c.attr({name:"."+s.name,"ng-model":s.ngModel,"aria-hidden":"true",tabindex:"-1"}),a=e.find("md-option"),t.forEach(a,function(n){var i=t.element("<option>"+n.innerHTML+"<\/option>");n.hasAttribute("ng-value")?i.attr("ng-value",n.getAttribute("ng-value")):n.hasAttribute("value")&&i.attr("value",n.getAttribute("value"));c.append(i)}),e.parent().append(c));var v=r.parseAttributeBoolean(s.multiple),y=v?"multiple":"",l='<div class="_md-select-menu-container" aria-hidden="true"><md-select-menu {0}>{1}<\/md-select-menu><\/div>';return l=r.supplant(l,[y,e.html()]),e.empty().append(h),e.append(l),s.tabindex||s.$set("tabindex",0),function(e,s,h,c){function yt(){var n=s.attr("aria-label")||s.attr("placeholder");!n&&l&&l.label&&(n=l.label.text());k=n;f.expect(s,"aria-label",n)}function nt(){p&&(a=a||p.find("md-select-menu").controller("mdSelectMenu"),w.setLabelText(a.selectedLabels()))}function ft(){if(k){var n=a.selectedLabels({mode:"aria"});s.attr("aria-label",n.length?k+": "+n:k)}}function st(){l&&l.setHasValue(a.selectedLabels().length>0||(s[0].validity||{}).badInput)}function pt(){if(p=t.element(s[0].querySelector("._md-select-menu-container")),b=e,h.mdContainerClass){var n=p[0].getAttribute("class")+" "+h.mdContainerClass;p[0].setAttribute("class",n)}a=p.find("md-select-menu").controller("mdSelectMenu");a.init(y,h.ngModel);s.on("$destroy",function(){p.remove()})}function ht(n){var i,r;if([32,13,38,40].indexOf(n.keyCode)!=-1)n.preventDefault(),it(n);else if(n.keyCode<=90&&n.keyCode>=31){if(n.preventDefault(),i=a.optNodeForKeyboardSearch(n),!i)return;r=t.element(i).controller("mdOption");a.isMultiple||a.deselect(Object.keys(a.selected)[0]);a.select(r.hashKey,r.value);a.refreshViewValue()}}function it(){b.isOpen=!0;s.attr("aria-expanded","true");n.show({scope:b,preserveScope:!0,skipCompile:!0,element:p,target:s[0],selectCtrl:w,preserveElement:!0,hasBackdrop:!0,loadingAsync:h.mdOnOpen?e.$eval(h.mdOnOpen)||!0:!1}).finally(function(){b.isOpen=!1;s.focus();s.attr("aria-expanded","false");y.$setTouched()})}var ct=!0,rt,k,l=c[0],w=c[1],y=c[2],d=c[3],ut=s.find("md-select-value"),vt=t.isDefined(h.readonly),lt,p,b,a,at,g,et,tt,ot;if(l){if(lt=l.isErrorGetter||function(){return y.$invalid&&y.$touched},l.input)throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");l.input=s;l.label||f.expect(s,"aria-label",s.attr("placeholder"));e.$watch(lt,l.setInvalid)}if(pt(),u(s),h.name&&d&&(at=s.parent()[0].querySelector('select[name=".'+h.name+'"]'),r.nextTick(function(){var n=t.element(at).controller("ngModel");n&&d.$removeControl(n)})),d&&t.isDefined(h.multiple)&&r.nextTick(function(){var n=y.$modelValue||y.$viewValue;n&&d.$setPristine()}),g=y.$render,y.$render=function(){g();nt();ft();st()},h.$observe("placeholder",y.$render),w.setLabelText=function(n){var t,i;w.setIsPlaceholder(!n);h.mdSelectedText?n=o(h.mdSelectedText)(e):(t=h.placeholder||(l&&l.label?l.label.text():""),n=n||t||"");i=ut.children().eq(0);i.html(n)},w.setIsPlaceholder=function(n){n?(ut.addClass("_md-select-placeholder"),l&&l.label&&l.label.addClass("_md-placeholder")):(ut.removeClass("_md-select-placeholder"),l&&l.label&&l.label.removeClass("_md-placeholder"))},!vt){s.on("focus",function(){l&&l.element.hasClass("md-input-has-value")&&l.setFocused(!0)});s.on("blur",function(n){(ct&&(ct=!1,b.isOpen&&n.stopImmediatePropagation()),b.isOpen)||(l&&l.setFocused(!1),st())})}if(w.triggerClose=function(){o(h.mdOnClose)(e)},e.$$postDigest(function(){yt();nt();ft()}),e.$watch(a.selectedLabels,nt),h.$observe("ngMultiple",function(n){et&&et();var t=o(n);et=e.$watch(function(){return t(e)},function(n,t){(n!==i||t!==i)&&(n?s.attr("multiple","multiple"):s.removeAttr("multiple"),s.attr("aria-multiselectable",n?"true":"false"),p&&(a.setMultiple(n),g=y.$render,y.$render=function(){g();nt();ft();st()},y.$render()))})}),h.$observe("disabled",function(n){if(t.isString(n)&&(n=!0),rt===i||rt!==n)if(rt=n,n)s.attr({"aria-disabled":"true"}).removeAttr("tabindex").off("click",it).off("keydown",ht);else s.attr({tabindex:h.tabindex,"aria-disabled":"false"}).on("click",it).on("keydown",ht)}),!h.hasOwnProperty("disabled")&&!h.hasOwnProperty("ngDisabled")){s.attr({"aria-disabled":"false"});s.on("click",it);s.on("keydown",ht)}tt={role:"listbox","aria-expanded":"false","aria-multiselectable":v&&!h.ngMultiple?"true":"false"};s[0].hasAttribute("id")||(tt.id="select_"+r.nextUid());ot="select_container_"+r.nextUid();p.attr("id",ot);tt["aria-owns"]=ot;s.attr(tt);e.$on("$destroy",function(){n.destroy().finally(function(){l&&(l.setFocused(!1),l.setHasValue(!1),l.input=null);y.$setTouched()})})}}return{restrict:"E",require:["^?mdInputContainer","mdSelect","ngModel","?^form"],compile:s,controller:function(){}}}function u(n,r,u){function e(n,i,f,e){function h(n){(n.keyCode==13||n.keyCode==32)&&s(n)}function s(i){var f=r.getClosest(i.target,"md-option"),e=f&&t.element(f).data("$mdOptionController"),u,s;if(f&&e){if(f.hasAttribute("disabled"))return i.stopImmediatePropagation(),!1;u=o.hashGetter(e.value);s=t.isDefined(o.selected[u]);n.$apply(function(){o.isMultiple?s?o.deselect(u):o.select(u,e.value):s||(o.deselect(Object.keys(o.selected)[0]),o.select(u,e.value));o.refreshViewValue()})}}var o=e[0];u(i);i.on("click",s);i.on("keypress",h)}function f(u,f,e){function w(){var n=s.ngModel.$modelValue||s.ngModel.$viewValue||[];if(t.isArray(n)){var r=Object.keys(s.selected),i=n.map(s.hashGetter),u=r.filter(function(n){return i.indexOf(n)===-1});u.forEach(s.deselect);i.forEach(function(t,i){s.select(t,n[i])})}}function b(){var n=s.ngModel.$viewValue||s.ngModel.$modelValue;Object.keys(s.selected).forEach(s.deselect);s.select(s.hashGetter(n),n)}var s=this,v,y,l,a,h,c,p;s.isMultiple=t.isDefined(f.multiple);s.selected={};s.options={};u.$watchCollection(function(){return s.options},function(){s.ngModel.$render()});s.setMultiple=function(n){function r(n,i){return t.isArray(n||i||[])}var i=s.ngModel;y=y||i.$isEmpty;s.isMultiple=n;v&&v();s.isMultiple?(i.$validators["md-multiple"]=r,i.$render=w,u.$watchCollection(s.modelBinding,function(n){r(n)&&w(n);s.ngModel.$setPristine()}),i.$isEmpty=function(n){return!n||n.length===0}):(delete i.$validators["md-multiple"],i.$render=b)};l="";p=300;s.optNodeForKeyboardSearch=function(n){var u,r;for(a&&clearTimeout(a),a=setTimeout(function(){a=i;l="";c=i;h=i},p),l+=String.fromCharCode(n.keyCode),u=new RegExp("^"+l,"i"),h||(h=e.find("md-option"),c=new Array(h.length),t.forEach(h,function(n,t){c[t]=n.textContent.trim()})),r=0;r<c.length;++r)if(u.test(c[r]))return h[r]};s.init=function(i,r){if(s.ngModel=i,s.modelBinding=r,i.$options&&i.$options.trackBy){var f={},e=n(i.$options.trackBy);s.hashGetter=function(n,t){return f.$value=n,e(t||u,f)}}else s.hashGetter=function(n){return t.isObject(n)?"object_"+(n.$$mdSelectId||(n.$$mdSelectId=++o)):n};s.setMultiple(s.isMultiple)};s.selectedLabels=function(n){var t,i,u;return n=n||{},t=n.mode||"html",i=r.nodesToArray(e[0].querySelectorAll("md-option[selected]")),i.length?(t=="html"?u=function(n){var t=n.innerHTML,i=n.querySelector(".md-ripple-container");return i?t.replace(i.outerHTML,""):t}:t=="aria"&&(u=function(n){return n.hasAttribute("aria-label")?n.getAttribute("aria-label"):n.textContent}),i.map(u).join(", ")):""};s.select=function(n,t){var i=s.options[n];i&&i.setSelected(!0);s.selected[n]=t};s.deselect=function(n){var t=s.options[n];t&&t.setSelected(!1);delete s.selected[n]};s.addOption=function(n,i){if(t.isDefined(s.options[n]))throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "'+i.value+'" found.');s.options[n]=i;t.isDefined(s.selected[n])&&(s.select(n,i.value),s.refreshViewValue())};s.removeOption=function(n){delete s.options[n]};s.refreshViewValue=function(){var n=[],r;for(var u in s.selected)(r=s.options[u])?n.push(r.value):n.push(s.selected[u]);var e=s.ngModel.$options&&s.ngModel.$options.trackBy,i=s.isMultiple?n:n[0],f=s.ngModel.$modelValue;(e?t.equals(f,i):f==i)||(s.ngModel.$setViewValue(i),s.ngModel.$render())}}return f.$inject=["$scope","$attrs","$element"],{restrict:"E",require:["mdSelectMenu"],scope:!0,controller:f,link:{pre:e}}}function f(n,i){function u(n,i){return n.append(t.element('<div class="_md-text">').append(n.contents())),n.attr("tabindex",i.tabindex||"0"),f}function f(r,u,f,e){function c(n,t,i){if(!o.hashGetter){i||r.$$postDigest(function(){c(n,t,!0)});return}var f=o.hashGetter(t,r),u=o.hashGetter(n,r);h.hashKey=u;h.value=n;o.removeOption(f,h);o.addOption(u,h)}function l(){var n={role:"option","aria-selected":"false"};u[0].hasAttribute("id")||(n.id="select_option_"+i.nextUid());u.attr(n)}var h=e[0],o=e[1];o.isMultiple&&(u.attr("md-checkbox-enabled",""),u.prepend(s.clone()));t.isDefined(f.ngValue)?r.$watch(f.ngValue,c):t.isDefined(f.value)?c(f.value):r.$watch(function(){return u.text().trim()},c);f.$observe("disabled",function(n){n?u.attr("tabindex","-1"):u.attr("tabindex","0")});r.$$postDigest(function(){f.$observe("selected",function(n){t.isDefined(n)&&(typeof n=="string"&&(n=!0),n?(o.isMultiple||o.deselect(Object.keys(o.selected)[0]),o.select(h.hashKey,h.value)):o.deselect(h.hashKey),o.refreshViewValue())})});n.attach(r,u);l();r.$on("$destroy",function(){o.removeOption(h.hashKey,h)})}function r(n){this.selected=!1;this.setSelected=function(t){t&&!this.selected?n.attr({selected:"selected","aria-selected":"true"}):!t&&this.selected&&(n.removeAttr("selected"),n.attr("aria-selected","false"));this.selected=t}}return r.$inject=["$element"],{restrict:"E",require:["mdOption","^^mdSelectMenu"],controller:r,compile:u}}function h(){function n(n,i){var r=n.find("label");r.length||(r=t.element("<label>"),n.prepend(r));r.addClass("_md-container-ignore");i.label&&r.text(i.label)}return{restrict:"E",compile:n}}function e(r){function u(r,u,h,c,l,a,v,y,p){function d(n,t,i){function u(){return v(t,{addClass:"_md-leave"}).start()}function r(){t.removeClass("_md-active");t.attr("aria-hidden","true");t[0].style.display="none";nt(i);!i.$destroy&&i.restoreFocus&&i.target.focus()}return i=i||{},i.cleanupInteraction(),i.cleanupResizing(),i.hideBackdrop(),i.$destroy===!0?r():u().then(r)}function g(n,f,e){function s(n,t,i){return i.parent.append(t),l(function(n,i){try{v(t,{removeClass:"_md-leave",duration:0}).start().then(o).then(n)}catch(r){i(r)}})}function o(){return l(function(t){if(e.isRemoved)return l.reject(!1);var i=b(n,f,e);i.container.element.css(w.toCss(i.container.styles));i.dropDown.element.css(w.toCss(i.dropDown.styles));a(function(){f.addClass("_md-active");i.dropDown.element.css(w.toCss({transform:""}));g(e.focusedNode);t()})})}function d(n,t,i){return i.disableParentScroll&&!h.getClosest(i.target,"MD-DIALOG")?i.restoreScroll=h.disableScrollAround(i.element,i.parent):i.disableParentScroll=!1,i.hasBackdrop&&(i.backdrop=h.createBackdrop(n,"_md-select-backdrop _md-click-catcher"),y.enter(i.backdrop,p[0].body,null,{duration:0})),function(){i.backdrop&&i.backdrop.remove();i.disableParentScroll&&i.restoreScroll();delete i.restoreScroll}}function g(n){n&&!n.hasAttribute("disabled")&&n.focus()}function nt(n,i){var r=f.find("md-select-menu");if(!i.target)throw new Error(h.supplant(k,[i.target]));t.extend(i,{isRemoved:!1,target:t.element(i.target),parent:t.element(i.parent),selectEl:r,contentEl:f.find("md-content"),optionNodes:r[0].getElementsByTagName("md-option")})}function tt(){var i=function(n,t,i){return function(){if(!i.isRemoved){var r=b(n,t,i),u=r.container,f=r.dropDown;u.element.css(w.toCss(u.styles));f.element.css(w.toCss(f.styles))}}}(n,f,e),r=t.element(c);r.on("resize",i);r.on("orientationchange",i);return function(){r.off("resize",i);r.off("orientationchange",i)}}function it(){e.loadingAsync&&!e.isRemoved&&(n.$$loadingAsyncDone=!1,n.progressMode="indeterminate",l.when(e.loadingAsync).then(function(){n.$$loadingAsyncDone=!0;n.progressMode="";delete e.loadingAsync}).then(function(){a(o)}))}function rt(){function s(n){n.preventDefault();n.stopPropagation();e.restoreFocus=!1;h.nextTick(r.hide,!0)}function c(i){var f=u.KEY_CODE,s,o;i.preventDefault();i.stopPropagation();switch(i.keyCode){case f.UP_ARROW:return v();case f.DOWN_ARROW:return a();case f.SPACE:case f.ENTER:s=h.getClosest(i.target,"md-option");s&&(n.triggerHandler({type:"click",target:s}),i.preventDefault());t(i);break;case f.TAB:case f.ESCAPE:i.stopPropagation();i.preventDefault();e.restoreFocus=!0;h.nextTick(r.hide,!0);break;default:i.keyCode>=31&&i.keyCode<=90&&(o=n.controller("mdSelectMenu").optNodeForKeyboardSearch(i),e.focusedNode=o||e.focusedNode,o&&o.focus())}}function l(n){var u=h.nodesToArray(e.optionNodes),t=u.indexOf(e.focusedNode),r;do t===-1?t=0:n==="next"&&t<u.length-1?t++:n==="prev"&&t>0&&t--,r=u[t],r.hasAttribute("disabled")&&(r=i);while(!r&&t<u.length-1&&t>0);r&&r.focus();e.focusedNode=r}function a(){l("next")}function v(){l("prev")}function t(t){function u(){var i=!1,n,r,u;return t&&t.currentTarget.children.length>0&&(n=t.currentTarget.children[0],r=n.scrollHeight>n.clientHeight,r&&n.children.length>0&&(u=t.pageX-t.currentTarget.getBoundingClientRect().left,u>n.querySelector("md-option").offsetWidth&&(i=!0))),i}if((!t||t.type!="click"||t.currentTarget==n[0])&&!u()){var i=h.getClosest(t.target,"md-option");i&&i.hasAttribute&&!i.hasAttribute("disabled")&&(t.preventDefault(),t.stopPropagation(),o.isMultiple||(e.restoreFocus=!0,h.nextTick(function(){r.hide(o.ngModel.$viewValue)},!0)))}}if(!e.isRemoved){var n=e.selectEl,o=n.controller("mdSelectMenu")||{};f.addClass("_md-clickable");e.backdrop&&e.backdrop.on("click",s);n.on("keydown",c);n.on("click",t);return function(){e.backdrop&&e.backdrop.off("click",s);n.off("keydown",c);n.off("click",t);f.removeClass("_md-clickable");e.isRemoved=!0}}}return it(),nt(n,e),e.hideBackdrop=d(n,f,e),s(n,f,e).then(function(n){return f.attr("aria-hidden","false"),e.alreadyOpen=!0,e.cleanupInteraction=rt(),e.cleanupResizing=tt(),n},e.hideBackdrop)}function nt(n){var t=n.selectCtrl,i;t&&(i=n.selectEl.controller("mdSelectMenu"),t.setLabelText(i?i.selectedLabels():""),t.triggerClose())}function b(i,r,u){var ut=r[0],pt=u.target[0].children[0],wt=p[0].body,w=u.selectEl[0],l=u.contentEl[0],tt=wt.getBoundingClientRect(),a=pt.getBoundingClientRect(),ht=!1,y={left:tt.left+n,top:n,bottom:tt.height-n,right:tt.width-n-(h.floatingScrollbars()?16:0)},it={top:a.top-y.top,left:a.left-y.left,right:y.right-(a.left+a.width),bottom:y.bottom-(a.top+a.height)},ft=tt.width-n*2,ct=w.querySelector("md-option[selected]"),et=w.getElementsByTagName("md-option"),lt=w.getElementsByTagName("md-optgroup"),at=s(r,l),b,bt=e(u.loadingAsync),g,k,v,ot,d,st,nt,rt,vt;b=bt?l.firstElementChild||l:ct?ct:lt.length?lt[0]:et.length?et[0]:l.firstElementChild||l;l.offsetWidth>ft?l.style["max-width"]=ft+"px":l.style.maxWidth=null;ht&&(l.style["min-width"]=a.width+"px");at&&w.classList.add("_md-overflow");g=b;(g.tagName||"").toUpperCase()==="MD-OPTGROUP"&&(g=et[0]||l.firstElementChild||l,b=g);u.focusedNode=g;ut.style.display="block";k=w.getBoundingClientRect();v=o(b);b&&(ot=c.getComputedStyle(b),v.paddingLeft=parseInt(ot.paddingLeft,10)||0,v.paddingRight=parseInt(ot.paddingRight,10)||0);at&&(d=l.offsetHeight/2,l.scrollTop=v.top+v.height/2-d,it.top<d?l.scrollTop=Math.min(v.top,l.scrollTop+d-it.top):it.bottom<d&&(l.scrollTop=Math.max(v.top+v.height-k.height,l.scrollTop-d+it.bottom)));ht?(st=a.left,nt=a.top+a.height,rt="50% 0",nt+k.height>y.bottom&&(nt=a.top-k.height,rt="50% 100%")):(st=a.left+v.left-v.paddingLeft+2,nt=Math.floor(a.top+a.height/2-v.height/2-v.top+l.scrollTop)+2,rt=v.left+a.width/2+"px "+(v.top+v.height/2-l.scrollTop)+"px 0px",vt=Math.min(a.width+v.paddingLeft+v.paddingRight,ft));var yt=ut.getBoundingClientRect(),kt=Math.round(100*Math.min(a.width/k.width,1))/100,dt=Math.round(100*Math.min(a.height/k.height,1))/100;return{container:{element:t.element(ut),styles:{left:Math.floor(f(y.left,st,y.right-yt.width)),top:Math.floor(f(y.top,nt,y.bottom-yt.height)),"min-width":vt}},dropDown:{element:t.element(w),styles:{transformOrigin:rt,transform:u.alreadyOpen?"":h.supplant("scale({0},{1})",[kt,dt])}}}}var k="$mdSelect.show() expected a target element in options.target but got '{0}'!",w=h.dom.animator;return{parent:"body",themable:!0,onShow:g,onRemove:d,hasBackdrop:!0,disableParentScroll:!0}}function e(n){return n&&t.isFunction(n.then)}function f(n,t,i){return Math.max(n,Math.min(t,i))}function o(n){return n?{left:n.offsetLeft,top:n.offsetTop,width:n.offsetWidth,height:n.offsetHeight}:{left:0,top:0,width:0,height:0}}function s(n,t){var i=!1,r;try{r=n[0].style.display;n[0].style.display="block";i=t.scrollHeight>t.offsetHeight;n[0].style.display=r}finally{}return i}return u.$inject=["$mdSelect","$mdConstant","$mdUtil","$window","$q","$$rAF","$animateCss","$animate","$document"],r("$mdSelect").setDefaults({methods:["target"],options:u})}var n=8,o=0,s=t.element('<div class="_md-container"><div class="_md-icon"><\/div><\/div>');t.module("material.components.select",["material.core","material.components.backdrop"]).directive("mdSelect",r).directive("mdSelectMenu",u).directive("mdOption",f).directive("mdOptgroup",h).provider("$mdSelect",e);r.$inject=["$mdSelect","$mdUtil","$mdTheming","$mdAria","$compile","$parse"];u.$inject=["$parse","$mdUtil","$mdTheming"];f.$inject=["$mdButtonInkRipple","$mdUtil"];e.$inject=["$$interimElementProvider"]}(),function(){function n(n,t){return["$mdUtil",function(i){return{restrict:"A",multiElement:!0,link:function(r,u,f){var e=r.$on("$md-resize-enable",function(){e();r.$watch(f[n],function(n){!!n===t&&(i.nextTick(function(){r.$broadcast("$md-resize")}),i.dom.animator.waitTransitionEnd(u).then(function(){r.$broadcast("$md-resize")}))})})}}}]}t.module("material.components.showHide",["material.core"]).directive("ngShow",n("ngShow",!0)).directive("ngHide",n("ngHide",!1))}(),function(){function n(n,i){return function(r){function e(){return n.when(r).then(function(n){return u=n,n})}var f="SideNav '"+r+"' is not available!",u=n.get(r);return u||n.notFoundError(r),{isOpen:function(){return u&&u.isOpen()},isLockedOpen:function(){return u&&u.isLockedOpen()},toggle:function(){return u?u.toggle():i.reject(f)},open:function(){return u?u.open():i.reject(f)},close:function(){return u?u.close():i.reject(f)},then:function(n){var r=u?i.when(u):e();return r.then(n||t.noop)}}}}function f(){return{restrict:"A",require:"^mdSidenav",link:function(){}}}function r(n,r,u,f,e,o,s,h,c,l){function a(o,a,v,y){function tt(n,t){o.isLockedOpen=n;n===t?a.toggleClass("_md-locked-open",!!n):e[n?"addClass":"removeClass"](a,"_md-locked-open");p&&p.toggleClass("_md-locked-open",!!n)}function it(n){var t=r.findFocusTarget(a)||r.findFocusTarget(a,"[md-sidenav-focus]")||a,i=a.parent();return i[n?"on":"off"]("keydown",ft),p&&p[n?"on":"off"]("click",d),n&&(b=l[0].activeElement),rt(n),k=c.all([n&&p?e.enter(p,i):p?e.leave(p):c.when(!0),e[n?"removeClass":"addClass"](a,"_md-closed")]).then(function(){o.isOpen&&t&&t.focus()})}function rt(n){var r=a.parent();n&&!w?(w=r.css("overflow"),r.css("overflow","hidden")):t.isDefined(w)&&(r.css("overflow",w),w=i)}function ut(n){return o.isOpen==n?c.when(!0):c(function(t){o.isOpen=n;r.nextTick(function(){k.then(function(n){o.isOpen||(b&&b.focus(),b=null);t(n)})})})}function ft(n){var t=n.keyCode===u.KEY_CODE.ESCAPE;return t?d(n):c.when(!0)}function d(n){return n.preventDefault(),y.close()}var w,p,b=null,k=c.when(!0),g=s(v.mdIsLockedOpen),nt=function(){return g(o.$parent,{$media:function(t){return h.warn("$media is deprecated for is-locked-open. Use $mdMedia instead."),n(t)},$mdMedia:n})};t.isDefined(v.mdDisableBackdrop)||(p=r.createBackdrop(o,"_md-sidenav-backdrop md-opaque ng-enter"));f(a);p&&f.inherit(p,a);a.on("$destroy",function(){p&&p.remove();y.destroy()});o.$on("$destroy",function(){p&&p.remove()});o.$watch(nt,tt);o.$watch("isOpen",it);y.$toggleOpen=ut}return{restrict:"E",scope:{isOpen:"=?mdIsOpen"},controller:"$mdSidenavController",compile:function(n){return n.addClass("_md-closed"),n.attr("tabIndex","-1"),a}}}function u(n,t,i,r,u){var f=this;f.isOpen=function(){return!!n.isOpen};f.isLockedOpen=function(){return!!n.isLockedOpen};f.open=function(){return f.$toggleOpen(!0)};f.close=function(){return f.$toggleOpen(!1)};f.toggle=function(){return f.$toggleOpen(!n.isOpen)};f.$toggleOpen=function(t){return u.when(n.isOpen=t)};f.destroy=r.register(f,i.mdComponentId)}t.module("material.components.sidenav",["material.core","material.components.backdrop"]).factory("$mdSidenav",n).directive("mdSidenav",r).directive("mdSidenavFocus",f).controller("$mdSidenavController",u);n.$inject=["$mdComponentRegistry","$q"];r.$inject=["$mdMedia","$mdUtil","$mdConstant","$mdTheming","$animate","$compile","$parse","$log","$q","$document"];u.$inject=["$scope","$element","$attrs","$mdComponentRegistry","$q"]}(),function(){function n(n,r,u,f,e){function s(n){function y(n,i){i.addClass("_md-sticky-clone");var r={element:n,clone:i};return t.items.push(r),f.nextTick(function(){e.prepend(r.clone)}),l(),function(){t.items.forEach(function(i,r){i.element[0]===n[0]&&(t.items.splice(r,1),i.clone.remove())});l()}}function v(){var i,r,n;for(t.items.forEach(p),t.items=t.items.sort(function(n,t){return n.top<t.top?-1:1}),r=e.prop("scrollTop"),n=t.items.length-1;n>=0;n--)if(r>t.items[n].top){i=t.items[n];break}o(i)}function p(n){var t=n.element[0],r;for(n.top=0,n.left=0,n.right=0;t&&t!==e[0];)n.top+=t.offsetTop,n.left+=t.offsetLeft,t.offsetParent&&(n.right+=t.offsetParent.offsetWidth-t.offsetWidth-t.offsetLeft),t=t.offsetParent;n.height=n.element.prop("offsetHeight");r=f.floatingScrollbars()?"0":i;f.bidi(n.clone,"margin-left",n.left,r);f.bidi(n.clone,"margin-right",r,n.right)}function a(){var n=e.prop("scrollTop"),i=n>(a.prevScrollTop||0);if(a.prevScrollTop=n,n===0){o(null);return}if(i){if(t.next&&t.next.top<=n){o(t.next);return}if(t.current&&t.next&&t.next.top-n<=t.next.height){h(t.current,n+(t.next.top-t.next.height-n));return}}if(!i){if(t.current&&t.prev&&n<t.current.top){o(t.prev);return}if(t.next&&t.current&&n>=t.next.top-t.current.height){h(t.current,n+(t.next.top-n-t.current.height));return}}t.current&&h(t.current,n)}function o(n){if(t.current!==n){t.current&&(h(t.current,null),s(t.current,null));n&&s(n,"active");t.current=n;var i=t.items.indexOf(n);t.next=t.items[i+1];t.prev=t.items[i-1];s(t.next,"next");s(t.prev,"prev")}}function s(n,t){n&&n.state!==t&&(n.state&&(n.clone.attr("sticky-prev-state",n.state),n.element.attr("sticky-prev-state",n.state)),n.clone.attr("sticky-state",t),n.element.attr("sticky-state",t),n.state=t)}function h(n,t){n&&(t===null||t===i?n.translateY&&(n.translateY=null,n.clone.css(r.CSS.TRANSFORM,"")):(n.translateY=t,f.bidi(n.clone,r.CSS.TRANSFORM,"translate3d("+n.left+"px,"+t+"px,0)","translateY("+t+"px)")))}var e=n.$element,l=u.throttle(v),t;c(e);e.on("$scrollstart",l);e.on("$scroll",a);return t={prev:null,current:null,next:null,items:[],add:y,refreshElements:v}}function h(){var f,u=t.element("<div>"),r,i;for(n[0].body.appendChild(u[0]),r=["sticky","-webkit-sticky"],i=0;i<r.length;++i)if(u.css({position:r[i],top:0,"z-index":2}),u.css("position")==r[i]){f=r[i];break}return u.remove(),f}function c(n){function r(){+f.now()-i>e?(t=!1,n.triggerHandler("$scrollend")):(n.triggerHandler("$scroll"),u.throttle(r))}var e=200,t,i;n.on("scroll touchmove",function(){t||(t=!0,u.throttle(r),n.triggerHandler("$scrollstart"));n.triggerHandler("$scroll");i=+f.now()})}var o=h();return function(n,t,i){var u=t.controller("mdContent"),r,f,h;u&&(o?t.css({position:o,top:0,"z-index":2}):(r=u.$element.data("$$sticky"),r||(r=s(u),u.$element.data("$$sticky",r)),f=i||e(t.clone())(n),h=r.add(t,f),n.$on("$destroy",h)))}}t.module("material.components.sticky",["material.core","material.components.content"]).factory("$mdSticky",n);n.$inject=["$document","$mdConstant","$$rAF","$mdUtil","$compile"]}(),function(){function r(){return{controller:function(){},compile:function(n){var r=n.find("md-slider"),u;if(r)return u=r.attr("md-vertical"),u!==i&&n.attr("md-vertical",""),r.attr("flex")||r.attr("flex",""),function(n,i,r,u){function e(n){i.children().attr("disabled",n);i.find("input").attr("disabled",n)}var o=t.noop,f;r.disabled?e(!0):r.ngDisabled&&(o=n.$watch(r.ngDisabled,function(n){e(n)}));n.$on("$destroy",function(){o()});u.fitInputWidthToTextLength=function(n){var r=i.find("md-input-container"),t=getComputedStyle(r[0]),u=parseInt(t["min-width"]),o=parseInt(t.padding)*2,e;f=f||parseInt(t["max-width"]);e=Math.max(f,u+o+u/2*n);r.css("max-width",e+"px")}}}}}function n(n,i,r,u,f,e,o,s,h,c){function l(n,i){var u=t.element(n[0].getElementsByClassName("_md-slider-wrapper")),f=i.tabindex||0;return u.attr("tabindex",f),(i.disabled||i.ngDisabled)&&u.attr("tabindex",-1),u.attr("role","slider"),r.expect(n,"aria-label"),a}function a(r,l,a,v){function st(){ut();ct()}function gt(n){w=parseFloat(n);l.attr("aria-valuemin",n);st()}function ni(n){tt=parseFloat(n);l.attr("aria-valuemax",n);st()}function ti(n){b=parseFloat(n)}function ii(n){yt=g(parseInt(n),0,6)}function ci(){l.attr("aria-disabled",!!nt())}function li(){var u,f,n,e,r,o;if(kt&&!nt()&&!t.isUndefined(b)){if(b<=0){u="Slider step value must be greater than zero when in discrete mode";h.error(u);throw new Error(u);}for(f=Math.floor((tt-w)/b),d||(d=t.element("<canvas>").css("position","absolute"),bt.append(d),rt=d[0].getContext("2d")),n=ri(),!n||n.height||n.width||(ut(),n=k),d[0].width=n.width,d[0].height=n.height,r=0;r<=f;r++)o=i.getComputedStyle(bt[0]),rt.fillStyle=o.color||"black",e=Math.floor((y?n.height:n.width)*(r/f)),rt.fillRect(y?0:e-1,y?e-1:0,y?n.width:2,y?2:n.height)}}function ai(){if(d&&rt){var n=ri();rt.clearRect(0,0,n.width,n.height)}}function ut(){k=oi[0].getBoundingClientRect()}function ri(){return hi(),k}function vi(n){if(!nt()){var t;(y?n.keyCode===f.KEY_CODE.DOWN_ARROW:n.keyCode===f.KEY_CODE.LEFT_ARROW)?t=-b:(y?n.keyCode===f.KEY_CODE.UP_ARROW:n.keyCode===f.KEY_CODE.RIGHT_ARROW)&&(t=b);t&&((n.metaKey||n.ctrlKey||n.altKey)&&(t*=4),n.preventDefault(),n.stopPropagation(),r.$evalAsync(function(){ht(p.$viewValue+t)}))}}function yi(){li();r.mouseActive=!0;it.removeClass("md-focused");c(function(){r.mouseActive=!1},100)}function pi(){r.mouseActive===!1&&it.addClass("md-focused")}function wi(){it.removeClass("md-focused");l.removeClass("_md-active");ai()}function ht(n){p.$setViewValue(g(ft(n)))}function ct(){isNaN(p.$viewValue)&&(p.$viewValue=p.$modelValue);p.$viewValue=g(p.$viewValue);var n=(p.$viewValue-w)/(tt-w);r.modelValue=p.$viewValue;l.attr("aria-valuenow",p.$viewValue);pt(n);wt.text(p.$viewValue)}function g(n,i,r){if(t.isNumber(n))return i=t.isNumber(i)?i:w,r=t.isNumber(r)?r:tt,Math.max(i,Math.min(r,n))}function ft(n){if(t.isNumber(n)){var i=Math.round((n-w)/b)*b+w;return i=Math.round(i*Math.pow(10,yt))/Math.pow(10,yt),at&&at.fitInputWidthToTextLength&&u.debounce(function(){at.fitInputWidthToTextLength(i.toString().length)},100)(),i}}function pt(n){n=rr(n);var t=n*100+"%";ei.css(y?"bottom":"left",t);si.css(y?"height":"width",t);l.toggleClass("_md-min",n===0);l.toggleClass("_md-max",n===1)}function bi(n){if(!nt()){l.addClass("_md-active");l[0].focus();ut();var i=lt(ot(y?n.pointer.y:n.pointer.x)),t=g(ft(i));r.$apply(function(){ht(t);pt(ur(t))})}}function ki(n){if(!nt()){l.removeClass("_md-dragging");var t=lt(ot(y?n.pointer.y:n.pointer.x)),i=g(ft(t));r.$apply(function(){ht(i);ct()})}}function di(n){nt()||(et=!0,n.stopPropagation(),l.addClass("_md-dragging"),ui(n))}function gi(n){et&&(n.stopPropagation(),ui(n))}function nr(n){et&&(n.stopPropagation(),et=!1)}function ui(n){kt?ir(y?n.pointer.y:n.pointer.x):tr(y?n.pointer.y:n.pointer.x)}function tr(n){r.$evalAsync(function(){ht(lt(ot(n)))})}function ir(n){var t=lt(ot(n)),i=g(ft(t));pt(ot(n));wt.text(i)}function rr(n){return Math.max(0,Math.min(n||0,1))}function ot(n){var i=y?k.top:k.left,r=y?k.height:k.width,t=(n-i)/r;return Math.max(0,Math.min(1,y?1-t:t))}function lt(n){return w+n*(tt-w)}function ur(n){return(n-w)/(tt-w)}var dt,vt,w,tt,b,yt,d,rt,k,et;e(l);var p=v[0]||{$setViewValue:function(n){this.$viewValue=n;this.$viewChangeListeners.forEach(function(n){n()})},$parsers:[],$formatters:[],$viewChangeListeners:[]},at=v[1],fr=t.element(u.getClosest(l,"_md-slider-container",!0)),nt=a.ngDisabled?t.bind(null,s(a.ngDisabled),r.$parent):function(){return l[0].hasAttribute("disabled")},fi=t.element(l[0].querySelector("._md-thumb")),wt=t.element(l[0].querySelector("._md-thumb-text")),ei=fi.parent(),oi=t.element(l[0].querySelector("._md-track-container")),si=t.element(l[0].querySelector("._md-track-fill")),bt=t.element(l[0].querySelector("._md-track-ticks")),it=t.element(l[0].getElementsByClassName("_md-slider-wrapper")),er=t.element(l[0].getElementsByClassName("_md-slider-content")),hi=u.throttle(ut,5e3),y=t.isDefined(a.mdVertical),kt=t.isDefined(a.mdDiscrete);t.isDefined(a.min)?a.$observe("min",gt):gt(0);t.isDefined(a.max)?a.$observe("max",ni):ni(100);t.isDefined(a.step)?a.$observe("step",ti):ti(1);t.isDefined(a.round)?a.$observe("round",ii):ii(3);dt=t.noop;a.ngDisabled&&(dt=r.$parent.$watch(a.ngDisabled,ci));o.register(it,"drag",{horizontal:!y});r.mouseActive=!1;it.on("keydown",vi).on("mousedown",yi).on("focus",pi).on("blur",wi).on("$md.pressdown",bi).on("$md.pressup",ki).on("$md.dragstart",di).on("$md.drag",gi).on("$md.dragend",nr);setTimeout(st,0);vt=n.throttle(st);t.element(i).on("resize",vt);r.$on("$destroy",function(){t.element(i).off("resize",vt)});p.$render=ct;p.$viewChangeListeners.push(ct);p.$formatters.push(g);p.$formatters.push(ft);k={};ut();et=!1}return{scope:{},require:["?ngModel","?^mdSliderContainer"],template:'<div class="_md-slider-wrapper"><div class="_md-slider-content"><div class="_md-track-container"><div class="_md-track"><\/div><div class="_md-track _md-track-fill"><\/div><div class="_md-track-ticks"><\/div><\/div><div class="_md-thumb-container"><div class="_md-thumb"><\/div><div class="_md-focus-thumb"><\/div><div class="_md-focus-ring"><\/div><div class="_md-sign"><span class="_md-thumb-text"><\/span><\/div><div class="_md-disabled-thumb"><\/div><\/div><\/div><\/div>',compile:l}}t.module("material.components.slider",["material.core"]).directive("mdSlider",n).directive("mdSliderContainer",r);n.$inject=["$$rAF","$window","$mdAria","$mdUtil","$mdConstant","$mdTheming","$mdGesture","$parse","$log","$timeout"]}(),function(){function n(n,i,r,u){return{restrict:"E",replace:!0,transclude:!0,template:'<div class="md-subheader">  <div class="_md-subheader-inner">    <span class="_md-subheader-content"><\/span>  <\/div><\/div>',link:function(f,e,o,s,h){function c(n){return t.element(n[0].querySelector("._md-subheader-content"))}r(e);var l=e[0].outerHTML;h(f,function(n){c(e).append(n)});e.hasClass("md-no-sticky")||h(f,function(t){var o='<div class="_md-subheader-wrapper">'+l+"<\/div>",r=i(o)(f);n(f,e,r);u.nextTick(function(){c(r).append(t)})})}}}t.module("material.components.subheader",["material.core","material.components.sticky"]).directive("mdSubheader",n);n.$inject=["$mdSticky","$compile","$mdTheming","$mdUtil"]}(),function(){function n(n){function t(n){function t(t,u,f){var e=n(f[i]);u.on(r,function(n){t.$apply(function(){e(t,{$event:n})})})}return{restrict:"A",link:t}}var i="md"+n,r="$md."+n.toLowerCase();return t.$inject=["$parse"],t}t.module("material.components.swipe",["material.core"]).directive("mdSwipeLeft",n("SwipeLeft")).directive("mdSwipeRight",n("SwipeRight")).directive("mdSwipeUp",n("SwipeUp")).directive("mdSwipeDown",n("SwipeDown"))}(),function(){function n(n,i,r,u,f,e){function s(n,s){var h=o.compile(n,s);return n.addClass("_md-dragging"),function(n,o,s,c){function p(t){a&&a(n)||(t.stopPropagation(),o.addClass("_md-dragging"),l={width:v.prop("offsetWidth")})}function w(n){if(l){n.stopPropagation();n.srcEvent&&n.srcEvent.preventDefault();var i=n.pointer.distanceX/l.width,t=c.$viewValue?1+i:i;t=Math.max(0,Math.min(1,t));v.css(r.CSS.TRANSFORM,"translate3d("+100*t+"%,0,0)");l.translate=t}}function b(n){if(l){n.stopPropagation();o.removeClass("_md-dragging");v.css(r.CSS.TRANSFORM,"");var t=c.$viewValue?l.translate>.5:l.translate<.5;t&&k(!c.$viewValue);l=null}}function k(t){n.$apply(function(){c.$setViewValue(t);c.$render()})}var a,v,y,l;c=c||i.fakeNgModel();a=null;s.disabled!=null?a=function(){return!0}:s.ngDisabled&&(a=u(s.ngDisabled));v=t.element(o[0].querySelector("._md-thumb-container"));y=t.element(o[0].querySelector("._md-container"));f(function(){o.removeClass("_md-dragging")});h(n,o,s,c);a&&n.$watch(a,function(n){o.attr("tabindex",n?-1:0)});e.register(y,"drag");y.on("$md.dragstart",p).on("$md.drag",w).on("$md.dragend",b)}}var o=n[0];return{restrict:"E",priority:210,transclude:!0,template:'<div class="_md-container"><div class="_md-bar"><\/div><div class="_md-thumb-container"><div class="_md-thumb" md-ink-ripple md-ink-ripple-checkbox><\/div><\/div><\/div><div ng-transclude class="_md-label"><\/div>',require:"?ngModel",compile:s}}t.module("material.components.switch",["material.core","material.components.checkbox"]).directive("mdSwitch",n);n.$inject=["mdCheckboxDirective","$mdUtil","$mdConstant","$parse","$$rAF","$mdGesture"]}(),function(){t.module("material.components.tabs",["material.core","material.components.icon"])}(),function(){function n(n){return{restrict:"E",link:function(t){t.$on("$destroy",function(){n.destroy()})}}}function i(n){function r(n){i=n}function u(n,r,u,f){function o(t,o,s){i=s.textContent||s.content;var c=!f("gt-sm");o=u.extractElementByName(o,"md-toast",!0);s.element=o;s.onSwipe=function(n){var i=n.type.replace("$md.",""),t=i.replace("swipe","");(t!=="down"||s.position.indexOf("top")==-1||c)&&(t!=="up"||s.position.indexOf("bottom")==-1&&!c)&&((t==="left"||t==="right")&&c||(o.addClass("_md-"+i),u.nextTick(r.cancel)))};s.openClass=h(s.position);s.parent.addClass(s.openClass);u.hasComputedStyle(s.parent,"position","static")&&s.parent.css("position","relative");o.on(e,s.onSwipe);return o.addClass(c?"_md-bottom":s.position.split(" ").map(function(n){return"_md-"+n}).join(" ")),s.parent&&s.parent.addClass("_md-toast-animating"),n.enter(o,s.parent).then(function(){s.parent&&s.parent.removeClass("_md-toast-animating")})}function s(t,i,r){return i.off(e,r.onSwipe),r.parent&&r.parent.addClass("_md-toast-animating"),r.openClass&&r.parent.removeClass(r.openClass),(r.$destroy==!0?i.remove():n.leave(i)).then(function(){r.parent&&r.parent.removeClass("_md-toast-animating");u.hasComputedStyle(r.parent,"position","static")&&r.parent.css("position","")})}function h(n){return f("gt-xs")?"_md-toast-open-"+(n.indexOf("top")>-1?"top":"bottom"):"_md-toast-open-bottom"}var e="$md.swipeleft $md.swiperight $md.swipeup $md.swipedown";return{onShow:o,onRemove:s,position:"bottom left",themable:!0,hideDelay:3e3,autoWrap:!0,transformTemplate:function(n,i){var e=i.autoWrap&&n&&!/md-toast-content/g.test(n),r,u,f;if(e){for(r=document.createElement("md-template"),r.innerHTML=n,u=0;u<r.children.length;u++)r.children[u].nodeName==="MD-TOAST"&&(f=t.element('<div class="md-toast-content">'),f.append(r.children[u].children),r.children[u].appendChild(f[0]));return r.outerHTML}return n||""}}}var f="ok",i,e=n("$mdToast").setDefaults({methods:["position","hideDelay","capsule","parent","position"],options:u}).addPreset("simple",{argOption:"textContent",methods:["textContent","content","action","highlightAction","highlightClass","theme","parent"],options:["$mdToast","$mdTheming",function(n,t){return{template:'<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content">    <span flex class="md-toast-text" role="alert" aria-relevant="all" aria-atomic="true">      {{ toast.content }}    <\/span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()"         ng-class="highlightClasses">      {{ toast.action }}    <\/md-button>  <\/div><\/md-toast>',controller:["$scope",function(t){var r=this;r.highlightAction&&(t.highlightClasses=["md-highlight",r.highlightClass]);t.$watch(function(){return i},function(){r.content=i});this.resolve=function(){n.hide(f)}}],theme:t.defaultTheme(),controllerAs:"toast",bindToController:!0}}]}).addMethod("updateTextContent",r).addMethod("updateContent",r);return u.$inject=["$animate","$mdToast","$mdUtil","$mdMedia"],e}t.module("material.components.toast",["material.core","material.components.button"]).directive("mdToast",n).provider("$mdToast",i);n.$inject=["$mdToast"];i.$inject=["$$interimElementProvider"]}(),function(){function n(n,i,r,u,f){var e=t.bind(null,r.supplant,"translate3d(0,{0}px,0)");return{template:"",restrict:"E",link:function(o,s,h){function c(){function nt(n){var t=s.parent().find("md-content");!u&&t.length&&b(null,t);n=o.$eval(n);n===!1?v():v=d()}function b(n,t){t&&s.parent()[0]===t.parent()[0]&&(u&&u.off("scroll",w),u=t,v=d())}function k(n){var t=n?n.target.scrollTop:p;g();c=Math.min(a/y,Math.max(0,c+t-p));s.css(i.CSS.TRANSFORM,e([-c*y]));u.css(i.CSS.TRANSFORM,e([(a-c)*y]));p=t;r.nextTick(function(){var n=s.hasClass("md-whiteframe-z1");n&&!c?f.removeClass(s,"md-whiteframe-z1"):!n&&c&&f.addClass(s,"md-whiteframe-z1")})}function d(){if(!u)return t.noop;u.on("scroll",w);return u.attr("scroll-shrink","true"),n(l),function(){u.off("scroll",w);u.attr("scroll-shrink","false");n(l)}}function l(){a=s.prop("offsetHeight");var n=-a*y+"px";u.css({"margin-top":n,"margin-bottom":n});k()}var a,u,v=t.noop,c=0,p=0,y=h.mdShrinkSpeedFactor||.5,w=n.throttle(k),g=r.debounce(l,5e3);o.$on("$mdContentLoaded",b);h.$observe("mdScrollShrink",nt);h.ngShow&&o.$watch(h.ngShow,l);h.ngHide&&o.$watch(h.ngHide,l);o.$on("$destroy",v)}u(s);t.isDefined(h.mdScrollShrink)&&c()}}}t.module("material.components.toolbar",["material.core","material.components.content"]).directive("mdToolbar",n);n.$inject=["$$rAF","$mdConstant","$mdUtil","$mdTheming","$animate"]}(),function(){function o(){return{controller:n,template:s,compile:function(n,t){n.addClass("md-virtual-repeat-container").addClass(t.hasOwnProperty("mdOrientHorizontal")?"md-orient-horizontal":"md-orient-vertical")}}}function s(n){return'<div class="md-virtual-repeat-scroller"><div class="md-virtual-repeat-sizer"><\/div><div class="md-virtual-repeat-offsetter">'+n[0].innerHTML+"<\/div><\/div>"}function n(n,i,r,u,f,e,o,s){this.$rootScope=u;this.$scope=e;this.$element=o;this.$attrs=s;this.size=0;this.scrollSize=0;this.scrollOffset=0;this.horizontal=this.$attrs.hasOwnProperty("mdOrientHorizontal");this.repeater=null;this.autoShrink=this.$attrs.hasOwnProperty("mdAutoShrink");this.autoShrinkMin=parseInt(this.$attrs.mdAutoShrinkMin,10)||0;this.originalSize=null;this.offsetSize=parseInt(this.$attrs.mdOffsetSize,10)||0;this.oldElementSize=null;this.$attrs.mdTopIndex?(this.bindTopIndex=r(this.$attrs.mdTopIndex),this.topIndex=this.bindTopIndex(this.$scope),t.isDefined(this.topIndex)||(this.topIndex=0,this.bindTopIndex.assign(this.$scope,0)),this.$scope.$watch(this.bindTopIndex,t.bind(this,function(n){n!==this.topIndex&&this.scrollToIndex(n)}))):this.topIndex=0;this.scroller=o[0].getElementsByClassName("md-virtual-repeat-scroller")[0];this.sizer=this.scroller.getElementsByClassName("md-virtual-repeat-sizer")[0];this.offsetter=this.scroller.getElementsByClassName("md-virtual-repeat-offsetter")[0];var h=t.bind(this,this.updateSize);n(t.bind(this,function(){h();var n=i.debounce(h,10,null,!1),r=t.element(f);this.size||n();r.on("resize",n);e.$on("$destroy",function(){r.off("resize",n)});e.$emit("$md-resize-enable");e.$on("$md-resize",h)}))}function e(n){return{controller:i,priority:1e3,require:["mdVirtualRepeat","^^mdVirtualRepeatContainer"],restrict:"A",terminal:!0,transclude:"element",compile:function(t,i){var u=i.mdVirtualRepeat,r=u.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/),f=r[1],e=n(r[2]),o=i.mdExtraName&&n(i.mdExtraName);return function(n,t,i,r,u){r[0].link_(r[1],u,f,e,o)}}}}function i(n,i,r,u,f,e,o,s){this.$scope=n;this.$element=i;this.$attrs=r;this.$browser=u;this.$document=f;this.$rootScope=e;this.$$rAF=o;this.onDemand=s.parseAttributeBoolean(r.mdOnDemand);this.browserCheckUrlChange=u.$$checkUrlChange;this.newStartIndex=0;this.newEndIndex=0;this.newVisibleEnd=0;this.startIndex=0;this.endIndex=0;this.itemSize=n.$eval(r.mdItemSize)||null;this.isFirstRender=!0;this.isVirtualRepeatUpdating_=!1;this.itemsLength=0;this.unwatchItemSize_=t.noop;this.blocks={};this.pooledBlocks=[]}function f(n){if(!t.isFunction(n.getItemAtIndex)||!t.isFunction(n.getLength))throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() ");this.model=n}t.module("material.components.virtualRepeat",["material.core","material.components.showHide"]).directive("mdVirtualRepeatContainer",o).directive("mdVirtualRepeat",e);var r=1533917,u=3;n.$inject=["$$rAF","$mdUtil","$parse","$rootScope","$window","$scope","$element","$attrs"];n.prototype.register=function(n){this.repeater=n;t.element(this.scroller).on("scroll wheel touchmove touchend",t.bind(this,this.handleScroll_))};n.prototype.isHorizontal=function(){return this.horizontal};n.prototype.getSize=function(){return this.size};n.prototype.setSize_=function(n){var t=this.getDimensionName_();this.size=n;this.$element[0].style[t]=n+"px"};n.prototype.unsetSize_=function(){this.$element[0].style[this.getDimensionName_()]=this.oldElementSize;this.oldElementSize=null};n.prototype.updateSize=function(){this.originalSize||(this.size=this.isHorizontal()?this.$element[0].clientWidth:this.$element[0].clientHeight,this.handleScroll_(),this.repeater&&this.repeater.containerUpdated())};n.prototype.getScrollSize=function(){return this.scrollSize};n.prototype.getDimensionName_=function(){return this.isHorizontal()?"width":"height"};n.prototype.sizeScroller_=function(n){var i=this.getDimensionName_(),e=this.isHorizontal()?"height":"width",u,t,f;if(this.sizer.innerHTML="",n<r)this.sizer.style[i]=n+"px";else{for(this.sizer.style[i]="auto",this.sizer.style[e]="auto",u=Math.floor(n/r),t=document.createElement("div"),t.style[i]=r+"px",t.style[e]="1px",f=0;f<u;f++)this.sizer.appendChild(t.cloneNode(!1));t.style[i]=n-u*r+"px";this.sizer.appendChild(t)}};n.prototype.autoShrink_=function(n){var t=Math.max(n,this.autoShrinkMin*this.repeater.getItemSize()),i;this.autoShrink&&t!==this.size&&(this.oldElementSize===null&&(this.oldElementSize=this.$element[0].style[this.getDimensionName_()]),i=this.originalSize||this.size,!i||t<i?(this.originalSize||(this.originalSize=this.size),this.setSize_(t)):this.originalSize!==null&&(this.unsetSize_(),this.originalSize=null,this.updateSize()),this.repeater.containerUpdated())};n.prototype.setScrollSize=function(n){var t=n+this.offsetSize;this.scrollSize!==t&&(this.sizeScroller_(t),this.autoShrink_(t),this.scrollSize=t)};n.prototype.getScrollOffset=function(){return this.scrollOffset};n.prototype.scrollTo=function(n){this.scroller[this.isHorizontal()?"scrollLeft":"scrollTop"]=n;this.handleScroll_()};n.prototype.scrollToIndex=function(n){var i=this.repeater.getItemSize(),t=this.repeater.itemsLength;n>t&&(n=t-1);this.scrollTo(i*n)};n.prototype.resetScroll=function(){this.scrollTo(0)};n.prototype.handleScroll_=function(){var s=t.element(document)[0],f=s.dir!="rtl"&&s.body.dir!="rtl",n,i,e,o,r;(f||this.maxSize||(this.scroller.scrollLeft=this.scrollSize,this.maxSize=this.scroller.scrollLeft),n=this.isHorizontal()?f?this.scroller.scrollLeft:this.maxSize-this.scroller.scrollLeft:this.scroller.scrollTop,n===this.scrollOffset||n>this.scrollSize-this.size)||(i=this.repeater.getItemSize(),i)&&(e=Math.max(0,Math.floor(n/i)-u),o=(this.isHorizontal()?"translateX(":"translateY(")+(!this.isHorizontal()||f?e*i:-(e*i))+"px)",this.scrollOffset=n,this.offsetter.style.webkitTransform=o,this.offsetter.style.transform=o,this.bindTopIndex&&(r=Math.floor(n/i),r!==this.topIndex&&r<this.repeater.getItemCount()&&(this.topIndex=r,this.bindTopIndex.assign(this.$scope,r),this.$rootScope.$$phase||this.$scope.$digest())),this.repeater.containerUpdated())};e.$inject=["$parse"];i.$inject=["$scope","$element","$attrs","$browser","$document","$rootScope","$$rAF","$mdUtil"];i.Block;i.prototype.link_=function(n,i,r,u,f){this.container=n;this.transclude=i;this.repeatName=r;this.rawRepeatListExpression=u;this.extraName=f;this.sized=!1;this.repeatListExpression=t.bind(this,this.repeatListExpression_);this.container.register(this)};i.prototype.readItemSize_=function(){if(!this.itemSize){this.items=this.repeatListExpression(this.$scope);this.parentNode=this.$element[0].parentNode;var n=this.getBlock_(0);n.element[0].parentNode||this.parentNode.appendChild(n.element[0]);this.itemSize=n.element[0][this.container.isHorizontal()?"offsetWidth":"offsetHeight"]||null;this.blocks[0]=n;this.poolBlock_(0);this.itemSize&&this.containerUpdated()}};i.prototype.repeatListExpression_=function(n){var t=this.rawRepeatListExpression(n),i;return this.onDemand&&t?(i=new f(t),i.$$includeIndexes(this.newStartIndex,this.newVisibleEnd),i):t};i.prototype.containerUpdated=function(){if(this.itemSize)this.sized||(this.items=this.repeatListExpression(this.$scope));else{this.unwatchItemSize_=this.$scope.$watchCollection(this.repeatListExpression,t.bind(this,function(n){n&&n.length&&this.$$rAF(t.bind(this,this.readItemSize_))}));this.$rootScope.$$phase||this.$scope.$digest();return}this.sized||(this.unwatchItemSize_(),this.sized=!0,this.$scope.$watchCollection(this.repeatListExpression,t.bind(this,function(n,t){this.isVirtualRepeatUpdating_||this.virtualRepeatUpdate_(n,t)})));this.updateIndexes_();(this.newStartIndex!==this.startIndex||this.newEndIndex!==this.endIndex||this.container.getScrollOffset()>this.container.getScrollSize())&&(this.items instanceof f&&this.items.$$includeIndexes(this.newStartIndex,this.newEndIndex),this.virtualRepeatUpdate_(this.items,this.items))};i.prototype.getItemSize=function(){return this.itemSize};i.prototype.getItemCount=function(){return this.itemsLength};i.prototype.virtualRepeatUpdate_=function(n,i){var f,e,c,r,u,o,s,h;if(this.isVirtualRepeatUpdating_=!0,f=n&&n.length||0,e=!1,this.items&&f<this.items.length&&this.container.getScrollOffset()!==0){this.items=n;this.container.resetScroll();return}for(f!==this.itemsLength&&(e=!0,this.itemsLength=f),this.items=n,(n!==i||e)&&this.updateIndexes_(),this.parentNode=this.$element[0].parentNode,e&&this.container.setScrollSize(f*this.itemSize),this.isFirstRender&&(this.isFirstRender=!1,c=this.$attrs.mdStartIndex?this.$scope.$eval(this.$attrs.mdStartIndex):this.container.topIndex,this.container.scrollToIndex(c)),Object.keys(this.blocks).forEach(function(n){var t=parseInt(n,10);(t<this.newStartIndex||t>=this.newEndIndex)&&this.poolBlock_(t)},this),this.$browser.$$checkUrlChange=t.noop,o=[],s=[],r=this.newStartIndex;r<this.newEndIndex&&this.blocks[r]==null;r++)u=this.getBlock_(r),this.updateBlock_(u,r),o.push(u);for(;this.blocks[r]!=null;r++)this.updateBlock_(this.blocks[r],r);for(h=r-1;r<this.newEndIndex;r++)u=this.getBlock_(r),this.updateBlock_(u,r),s.push(u);o.length&&this.parentNode.insertBefore(this.domFragmentFromBlocks_(o),this.$element[0].nextSibling);s.length&&this.parentNode.insertBefore(this.domFragmentFromBlocks_(s),this.blocks[h]&&this.blocks[h].element[0].nextSibling);this.$browser.$$checkUrlChange=this.browserCheckUrlChange;this.startIndex=this.newStartIndex;this.endIndex=this.newEndIndex;this.isVirtualRepeatUpdating_=!1};i.prototype.getBlock_=function(n){if(this.pooledBlocks.length)return this.pooledBlocks.pop();var i;return this.transclude(t.bind(this,function(t,r){i={element:t,"new":!0,scope:r};this.updateScope_(r,n);this.parentNode.appendChild(t[0])})),i};i.prototype.updateBlock_=function(n,t){(this.blocks[t]=n,n.new||n.scope.$index!==t||n.scope[this.repeatName]!==this.items[t])&&(n.new=!1,this.updateScope_(n.scope,t),this.$rootScope.$$phase||n.scope.$digest())};i.prototype.updateScope_=function(n,t){n.$index=t;n[this.repeatName]=this.items&&this.items[t];this.extraName&&(n[this.extraName(this.$scope)]=this.items[t])};i.prototype.poolBlock_=function(n){this.pooledBlocks.push(this.blocks[n]);this.parentNode.removeChild(this.blocks[n].element[0]);delete this.blocks[n]};i.prototype.domFragmentFromBlocks_=function(n){var t=this.$document[0].createDocumentFragment();return n.forEach(function(n){t.appendChild(n.element[0])}),t};i.prototype.updateIndexes_=function(){var n=this.items?this.items.length:0,t=Math.ceil(this.container.getSize()/this.itemSize);this.newStartIndex=Math.max(0,Math.min(n-t,Math.floor(this.container.getScrollOffset()/this.itemSize)));this.newVisibleEnd=this.newStartIndex+t+u;this.newEndIndex=Math.min(n,this.newVisibleEnd);this.newStartIndex=Math.max(0,this.newStartIndex-u)};f.prototype.$$includeIndexes=function(n,t){for(var i=n;i<t;i++)this.hasOwnProperty(i)||(this[i]=this.model.getItemAtIndex(i));this.length=this.model.getLength()}}(),function(){function n(n,i,r,u,f,e,o,s,h){function a(o,a,v){function nt(){o.delay=o.delay||l}function g(){var n="center top";switch(o.direction){case"left":n="right center";break;case"right":n="left center";break;case"top":n="center bottom";break;case"bottom":n="center top"}b.css("transform-origin",n)}function tt(){o.$on("$destroy",function(){o.visible=!1;a.remove();t.element(i).off("resize",k)});o.$watch("visible",function(n){n?ft():et()});o.$watch("direction",d)}function it(){y.attr("aria-label")||y.text().trim()||y.attr("aria-label",a.text().trim())}function rt(){a.detach();a.attr("role","tooltip")}function ut(){function c(){p(!1)}var e=!1,n=t.element(i),r,s,f,l,h;y[0]&&"MutationObserver"in i&&(r=new MutationObserver(function(n){n.forEach(function(n){n.attributeName==="disabled"&&y[0].disabled&&(p(!1),o.$digest())})}),r.observe(y[0],{attributes:!0}));s=function(){f=document.activeElement===y[0]};f=!1;n.on("blur",s);n.on("resize",k);document.addEventListener("scroll",c,!0);o.$on("$destroy",function(){n.off("blur",s);n.off("resize",k);document.removeEventListener("scroll",c,!0);r&&r.disconnect()});l=function(n){if(n.type==="focus"&&f){f=!1;return}y.on("blur mouseleave touchend touchcancel",h);p(!0)};h=function(){var n=o.hasOwnProperty("autohide")?o.autohide:v.hasOwnProperty("mdAutohide");(n||e||u[0].activeElement!==y[0])&&(y.off("blur mouseleave touchend touchcancel",h),y.triggerHandler("blur"),p(!1));e=!1};y.on("mousedown",function(){e=!0});y.on("focus mouseenter touchstart",l)}function p(t){p.value=!!t;p.queued||(t?(p.queued=!0,n(function(){o.visible=p.value;p.queued=!1},o.delay)):f.nextTick(function(){o.visible=!1}))}function ft(){if(w.append(a),f.hasComputedStyle(a,"display","none")){o.visible=!1;a.detach();return}d();t.forEach([a,b],function(n){s.addClass(n,"_md-show")})}function et(){var n=[];t.forEach([a,b],function(t){t.parent()&&t.hasClass("_md-show")&&n.push(s.removeClass(t,"_md-show"))});h.all(n).then(function(){o.visible||a.detach()})}function d(){o.visible&&(g(),ot())}function ot(){function u(n){var i={left:n.left,top:n.top};return i.left=Math.min(i.left,w.prop("scrollWidth")-t.width-c),i.left=Math.max(i.left,c),i.top=Math.min(i.top,w.prop("scrollHeight")-t.height-c),i.top=Math.max(i.top,c),i}function e(i){return i==="left"?{left:n.left-t.width-c,top:n.top+n.height/2-t.height/2}:i==="right"?{left:n.left+n.width+c,top:n.top+n.height/2-t.height/2}:i==="top"?{left:n.left+n.width/2-t.width/2,top:n.top-t.height-c}:{left:n.left+n.width/2-t.width/2,top:n.top+n.height+c}}var t=f.offsetRect(a,w),n=f.offsetRect(y,w),i=e(o.direction),r=a.prop("offsetParent");o.direction?i=u(i):r&&i.top>r.scrollHeight-t.height-c&&(i=u(e("top")));a.css({left:i.left+"px",top:i.top+"px"})}e(a);var y=f.getParentWithPointerEvents(a),b=t.element(a[0].getElementsByClassName("_md-content")[0]),w=t.element(document.body),k=r.throttle(function(){d()});s.pin&&s.pin(a,y);nt();rt();ut();g();tt();it()}var l=0,c=8;return{restrict:"E",transclude:!0,priority:210,template:'<div class="_md-content" ng-transclude><\/div>',scope:{delay:"=?mdDelay",visible:"=?mdVisible",autohide:"=?mdAutohide",direction:"@?mdDirection"},link:a}}t.module("material.components.tooltip",["material.core"]).directive("mdTooltip",n);n.$inject=["$timeout","$window","$$rAF","$document","$mdUtil","$mdTheming","$rootElement","$animate","$q"]}(),function(){function n(n){function u(u,f,e){var o=parseInt(e.mdWhiteframe,10)||r;(o>i||o<t)&&(n.warn("md-whiteframe attribute value is invalid. It should be a number between "+t+" and "+i,f[0]),o=r);f.addClass("md-whiteframe-"+o+"dp")}var t=1,i=24,r=4;return{restrict:"A",link:u}}t.module("material.components.whiteframe",["material.core"]).directive("mdWhiteframe",n);n.$inject=["$log"]}(),function(){function f(f,e,o,s,h,c,l,a,v,y){function ri(){o.initOptionalProperties(f,v,{searchText:null,selectedItem:null});h(e);fi();o.nextTick(function(){oi();ui();lt();e.on("focus",lt)})}function tt(){function b(){var n=0,t=e.find("md-input-container"),i;return t.length&&(i=t.find("input"),n=t.prop("offsetHeight"),n-=i.prop("offsetTop"),n-=i.prop("offsetHeight"),n+=t.prop("offsetTop")),n}function k(){var r=w.scrollContainer.getBoundingClientRect(),u={};r.right>t.right-n&&(u.left=i.right-r.width+"px");w.$.scrollContainer.css(u)}if(!w)return o.nextTick(tt,!1,f);var i=w.wrap.getBoundingClientRect(),h=w.snap.getBoundingClientRect(),t=w.root.getBoundingClientRect(),c=h.bottom-t.top,l=t.bottom-h.top,a=i.left-t.left,y=i.width,p=b(),s;v.mdFloatingLabel&&(a+=u,y-=u*2);s={left:a+"px",minWidth:y+"px",maxWidth:Math.max(i.right-t.left,t.right-i.left)-n+"px"};c>l&&t.height-i.bottom-n<r?(s.top="auto",s.bottom=l+"px",s.maxHeight=Math.min(r,i.top-t.top-n)+"px"):(s.top=c-p+"px",s.bottom="auto",s.maxHeight=Math.min(r,t.bottom+o.scrollTop()-i.bottom-n)+"px");w.$.scrollContainer.css(s);o.nextTick(k,!1)}function ui(){w.$.root.length&&(h(w.$.scrollContainer),w.$.scrollContainer.detach(),w.$.root.append(w.$.scrollContainer),l.pin&&l.pin(w.$.scrollContainer,a))}function lt(){f.autofocus&&w.input.focus()}function fi(){var n=parseInt(f.delay,10)||0;v.$observe("disabled",function(n){p.isDisabled=o.parseAttributeBoolean(n,!1)});v.$observe("required",function(n){p.isRequired=o.parseAttributeBoolean(n,!1)});v.$observe("readonly",function(n){p.isReadonly=o.parseAttributeBoolean(n,!1)});f.$watch("searchText",n?o.debounce(vt,n):vt);f.$watch("selectedItem",vi);t.element(c).on("resize",tt);f.$on("$destroy",ei)}function ei(){if(p.hidden||o.enableScrolling(),t.element(c).off("resize",tt),w){var n="ul scroller scrollContainer input".split(" ");t.forEach(n,function(n){w.$[n].remove()})}}function oi(){w={main:e[0],scrollContainer:e[0].getElementsByClassName("md-virtual-repeat-container")[0],scroller:e[0].getElementsByClassName("md-virtual-repeat-scroller")[0],ul:e.find("ul")[0],input:e.find("input")[0],wrap:e.find("md-autocomplete-wrap")[0],root:document.body};w.li=w.ul.getElementsByTagName("li");w.snap=si();w.$=hi(w)}function si(){for(var n=e;n.length;n=n.parent())if(t.isDefined(n.attr("md-autocomplete-snap")))return n[0];return w.wrap}function hi(n){var r={};for(var i in n)n.hasOwnProperty(i)&&(r[i]=t.element(n[i]));return r}function ci(n,t){!n&&t?(tt(),w&&o.nextTick(function(){o.disableScrollAround(w.ul)},!1,f)):n&&!t&&o.nextTick(function(){o.enableScrolling()},!1,f)}function li(){g=!0}function at(){b||w.input.focus();g=!1;p.hidden=d()}function ai(){w.input.focus()}function vi(n,t){n&&it(n).then(function(i){f.searchText=i;wi(n,t)});n!==t&&yi()}function yi(){t.isFunction(f.itemChange)&&f.itemChange(pt(f.selectedItem))}function pi(){t.isFunction(f.textChange)&&f.textChange()}function wi(n,t){nt.forEach(function(i){i(n,t)})}function bi(n){nt.indexOf(n)==-1&&nt.push(n)}function ki(n){var t=nt.indexOf(n);t!=-1&&nt.splice(t,1)}function vt(n,t){(p.index=ir(),n!==t)&&it(f.selectedItem).then(function(i){n!==i&&(f.selectedItem=null,n!==t&&pi(),bt()?ti():(p.matches=[],k(!1),rt()))})}function di(){b=!1;g||(p.hidden=d())}function gi(n){n&&(g=!1,b=!1);w.input.blur()}function nr(){b=!0;t.isString(f.searchText)||(f.searchText="");p.hidden=d();p.hidden||ti()}function tr(n){switch(n.keyCode){case s.KEY_CODE.DOWN_ARROW:if(p.loading)return;n.stopPropagation();n.preventDefault();p.index=Math.min(p.index+1,p.matches.length-1);dt();rt();break;case s.KEY_CODE.UP_ARROW:if(p.loading)return;n.stopPropagation();n.preventDefault();p.index=p.index<0?p.matches.length-1:Math.max(0,p.index-1);dt();rt();break;case s.KEY_CODE.TAB:if(at(),p.hidden||p.loading||p.index<0||p.matches.length<1)return;ft(p.index);break;case s.KEY_CODE.ENTER:if(p.hidden||p.loading||p.index<0||p.matches.length<1)return;if(ut())return;n.stopPropagation();n.preventDefault();ft(p.index);break;case s.KEY_CODE.ESCAPE:n.stopPropagation();n.preventDefault();kt();gi(!0)}}function yt(){return t.isNumber(f.minLength)?f.minLength:1}function it(n){function t(n){return n&&f.itemText?f.itemText(pt(n)):null}return y.when(t(n)||n)}function pt(n){if(!n)return i;var t={};return p.itemName&&(t[p.itemName]=n),t}function ir(){return f.autoselect?0:-1}function k(n){p.loading!=n&&(p.loading=n);p.hidden=d()}function d(){return p.loading&&!st()?!0:ut()?!0:b?!rr():!0}function rr(){return bt()&&st()||ni()}function st(){return p.matches.length?!0:!1}function ut(){return p.scope.selectedItem?!0:!1}function ur(){return p.loading&&!ut()}function wt(){return it(p.matches[p.index])}function bt(){return(f.searchText||"").length>=yt()}function fr(n,t,i){Object.defineProperty(p,n,{get:function(){return i},set:function(n){var r=i;i=n;t(n,r)}})}function ft(n){o.nextTick(function(){it(p.matches[n]).then(function(n){var t=w.$.input.controller("ngModel");t.$setViewValue(n);t.$render()}).finally(function(){f.selectedItem=p.matches[n];k(!1)})},!1)}function kt(){k(!0);p.index=0;p.matches=[];f.searchText="";var n=document.createEvent("CustomEvent");n.initCustomEvent("input",!0,!0,{value:f.searchText});w.input.dispatchEvent(n);w.input.focus()}function er(n){function h(n){n&&(n=y.when(n),ot++,k(!0),o.nextTick(function(){n.then(r).finally(function(){--ot==0&&k(!1)})},!0,f))}function r(t){(et[u]=t,(n||"")===(f.searchText||""))&&(p.matches=t,p.hidden=d(),p.loading&&k(!1),f.selectOnMatch&&hr(),rt(),tt())}var i=f.$parent.$eval(ii),u=n.toLowerCase(),e=t.isArray(i),s=!!i.then;e?r(i):s&&h(i)}function rt(){wt().then(function(n){p.messages=[or(),n]})}function or(){if(ct===p.matches.length)return"";ct=p.matches.length;switch(p.matches.length){case 0:return"There are no matches available.";case 1:return"There is 1 match available.";default:return"There are "+p.matches.length+" matches available."}}function dt(){if(w.li[0]){var t=w.li[0].offsetHeight,n=t*p.index,i=n+t,r=w.scroller.clientHeight,u=w.scroller.scrollTop;n<u?gt(n):i>u+r&&gt(i-r)}}function sr(){return ot!==0}function gt(n){w.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(n)}function ni(){var n=(p.scope.searchText||"").length;return p.hasNotFound&&!st()&&(!p.loading||sr())&&n>=yt()&&(b||g)&&!ut()}function ti(){var n=f.searchText||"",t=n.toLowerCase();!f.noCache&&et[t]?(p.matches=et[t],rt()):er(n);p.hidden=d()}function hr(){var n=f.searchText,t=p.matches,i=t[0];t.length===1&&it(i).then(function(t){var i=n==t;f.matchInsensitive&&!i&&(i=n.toLowerCase()==t.toLowerCase());i&&ft(0)})}var p=this,ht=f.itemsExpr.split(/ in /i),ii=ht[1],w=null,et={},g=!1,nt=[],b=!1,ct=0,ot=0;return fr("hidden",ci,!0),p.scope=f,p.parent=f.$parent,p.itemName=ht[0],p.matches=[],p.loading=!1,p.hidden=!0,p.index=null,p.messages=[],p.id=o.nextUid(),p.isDisabled=null,p.isRequired=null,p.isReadonly=null,p.hasNotFound=!1,p.keydown=tr,p.blur=di,p.focus=nr,p.clear=kt,p.select=ft,p.listEnter=li,p.listLeave=at,p.mouseUp=ai,p.getCurrentDisplayValue=wt,p.registerSelectedItemWatcher=bi,p.unregisterSelectedItemWatcher=ki,p.notFoundVisible=ni,p.loadingIsVisible=ur,ri()}t.module("material.components.autocomplete").controller("MdAutocompleteCtrl",f);var r=5.5*41,n=8,u=2;f.$inject=["$scope","$element","$mdUtil","$mdConstant","$mdTheming","$window","$animate","$rootElement","$attrs","$q"]}(),function(){function n(){return{controller:"MdAutocompleteCtrl",controllerAs:"$mdAutocompleteCtrl",scope:{inputName:"@mdInputName",inputMinlength:"@mdInputMinlength",inputMaxlength:"@mdInputMaxlength",searchText:"=?mdSearchText",selectedItem:"=?mdSelectedItem",itemsExpr:"@mdItems",itemText:"&mdItemText",placeholder:"@placeholder",noCache:"=?mdNoCache",selectOnMatch:"=?mdSelectOnMatch",matchInsensitive:"=?mdMatchCaseInsensitive",itemChange:"&?mdSelectedItemChange",textChange:"&?mdSearchTextChange",minLength:"=?mdMinLength",delay:"=?mdDelay",autofocus:"=?mdAutofocus",floatingLabel:"@?mdFloatingLabel",autoselect:"=?mdAutoselect",menuClass:"@?mdMenuClass",inputId:"@?mdInputId"},link:function(n,t,i,r){r.hasNotFound=!!t.attr("md-has-not-found")},template:function(n,t){function e(){var t=n.find("md-item-template").detach(),i=t.length?t.html():n.html();return t.length||n.empty(),"<md-autocomplete-parent-scope md-autocomplete-replace>"+i+"<\/md-autocomplete-parent-scope>"}function o(){var t=n.find("md-not-found").detach(),i=t.length?t.html():"";return i?'<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>'+i+"<\/li>":""}function s(){return t.mdFloatingLabel?'            <md-input-container flex ng-if="floatingLabel">              <label>{{floatingLabel}}<\/label>              <input type="search"                  '+(i!=null?'tabindex="'+i+'"':"")+'                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-readonly="$mdAutocompleteCtrl.isReadonly"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur()"                  '+(t.mdNoAsterisk!=null?'md-no-asterisk="'+t.mdNoAsterisk+'"':"")+'                  ng-focus="$mdAutocompleteCtrl.focus()"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  '+(t.mdSelectOnFocus!=null?'md-select-on-focus=""':"")+'                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>'+f+"<\/div>            <\/md-input-container>":'            <input flex type="search"                '+(i!=null?'tabindex="'+i+'"':"")+'                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur()"                ng-focus="$mdAutocompleteCtrl.focus()"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                '+(t.mdSelectOnFocus!=null?'md-select-on-focus=""':"")+'                aria-label="{{placeholder}}"                aria-autocomplete="list"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>            <button                type="button"                tabindex="-1"                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"                ng-click="$mdAutocompleteCtrl.clear()">              <md-icon md-svg-icon="md-close"><\/md-icon>              <span class="_md-visually-hidden">Clear<\/span>            <\/button>                '}var r=o(),u=e(),f=n.html(),i=t.tabindex;return r&&n.attr("md-has-not-found",!0),n.attr("tabindex","-1"),'        <md-autocomplete-wrap            layout="row"            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"            role="listbox">          '+s()+'          <md-progress-linear              class="'+(t.mdFloatingLabel?"md-inline":"")+'"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"><\/md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  '+u+"                  <\/li>"+r+'            <\/ul>          <\/md-virtual-repeat-container>        <\/md-autocomplete-wrap>        <aria-status            class="_md-visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}<\/p>        <\/aria-status>'}}}t.module("material.components.autocomplete").directive("mdAutocomplete",n)}(),function(){function n(n,t){function i(n,i,r){return function(n,i){function e(i,r){u[r]=n[i];n.$watch(i,function(n){t.nextTick(function(){u[r]=n})})}function s(){var i=!1,t=!1;n.$watch(function(){t||i||(i=!0,n.$$postDigest(function(){t||u.$digest();i=t=!1}))});u.$watch(function(){t=!0})}var f=n.$mdAutocompleteCtrl,u=f.parent.$new(),o=f.itemName;e("$index","$index");e("item",o);s();r(u,function(n){i.after(n)})}}return{restrict:"AE",compile:i,terminal:!0,transclude:"element"}}t.module("material.components.autocomplete").directive("mdAutocompleteParentScope",n);n.$inject=["$compile","$mdUtil"]}(),function(){function n(n,i,r){function u(u,f){var o=null,s=null,h=r.mdHighlightFlags||"",c=n.$watch(function(n){return{term:u(n),unsafeText:f(n)}},function(n,r){(o===null||n.unsafeText!==r.unsafeText)&&(o=t.element("<div>").text(n.unsafeText).html());(s===null||n.term!==r.term)&&(s=e(n.term,h));i.html(o.replace(s,'<span class="highlight">$&<\/span>'))},!0);i.on("$destroy",c)}function f(n){return n&&n.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g,"\\$&")}function e(n,t){var i="";return t.indexOf("^")>=1&&(i+="^"),i+=n,t.indexOf("$")>=1&&(i+="$"),new RegExp(f(i),t.replace(/[\$\^]/g,""))}this.init=u}t.module("material.components.autocomplete").controller("MdHighlightCtrl",n);n.$inject=["$scope","$element","$attrs"]}(),function(){function n(n,t){return{terminal:!0,controller:"MdHighlightCtrl",compile:function(i,r){var u=t(r.mdHighlightText),f=n(i.html());return function(n,t,i,r){r.init(u,f)}}}}t.module("material.components.autocomplete").directive("mdHighlightText",n);n.$inject=["$interpolate","$parse"]}(),function(){function r(n,t,r,u,f){this.$scope=n;this.$element=t;this.$mdConstant=r;this.$timeout=u;this.$mdUtil=f;this.isEditting=!1;this.parentController=i;this.enableChipEdit=!1}t.module("material.components.chips").controller("MdChipCtrl",r);r.$inject=["$scope","$element","$mdConstant","$timeout","$mdUtil"];r.prototype.init=function(n){if(this.parentController=n,this.enableChipEdit=this.parentController.enableChipEdit,this.enableChipEdit){this.$element.on("keydown",this.chipKeyDown.bind(this));this.$element.on("mousedown",this.chipMouseDown.bind(this));this.getChipContent().addClass("_md-chip-content-edit-is-enabled")}};r.prototype.getChipContent=function(){var n=this.$element[0].getElementsByClassName("_md-chip-content");return t.element(n[0])};r.prototype.getContentElement=function(){return t.element(this.getChipContent().children()[0])};r.prototype.getChipIndex=function(){return parseInt(this.$element.attr("index"))};r.prototype.goOutOfEditMode=function(){if(this.isEditting){this.isEditting=!1;this.$element.removeClass("_md-chip-editing");this.getChipContent()[0].contentEditable="false";var n=this.getChipIndex(),t=this.getContentElement().text();t?(this.parentController.updateChipContents(n,this.getContentElement().text()),this.$mdUtil.nextTick(function(){this.parentController.selectedChip===n&&this.parentController.focusChip(n)}.bind(this))):this.parentController.removeChipAndFocusInput(n)}};r.prototype.selectNodeContents=function(t){var i,r;document.body.createTextRange?(i=document.body.createTextRange(),i.moveToElementText(t),i.select()):n.getSelection&&(r=n.getSelection(),i=document.createRange(),i.selectNodeContents(t),r.removeAllRanges(),r.addRange(i))};r.prototype.goInEditMode=function(){this.isEditting=!0;this.$element.addClass("_md-chip-editing");this.getChipContent()[0].contentEditable="true";this.getChipContent().on("blur",function(){this.goOutOfEditMode()}.bind(this));this.selectNodeContents(this.getChipContent()[0])};r.prototype.chipKeyDown=function(n){this.isEditting||n.keyCode!==this.$mdConstant.KEY_CODE.ENTER&&n.keyCode!==this.$mdConstant.KEY_CODE.SPACE?this.isEditting&&n.keyCode===this.$mdConstant.KEY_CODE.ENTER&&(n.preventDefault(),this.goOutOfEditMode()):(n.preventDefault(),this.goInEditMode())};r.prototype.chipMouseDown=function(){this.getChipIndex()==this.parentController.selectedChip&&this.enableChipEdit&&!this.isEditting&&this.goInEditMode()}}(),function(){function n(n,r){function f(i){return i.append(r.processTemplate(u)),function(i,r,u,f){var e=f.shift(),o=f.shift();if(n(r),e){o.init(e);t.element(r[0].querySelector("._md-chip-content")).on("blur",function(){e.selectedChip=-1;e.$scope.$applyAsync()})}}}var u=r.processTemplate(i);return{restrict:"E",require:["^?mdChips","mdChip"],compile:f,controller:"MdChipCtrl"}}t.module("material.components.chips").directive("mdChip",n);var i='    <span ng-if="!$mdChipsCtrl.readonly" class="_md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    <\/span>';n.$inject=["$mdTheming","$mdUtil"]}(),function(){function n(n){function t(t,i,r,u){i.on("click",function(){t.$apply(function(){u.removeChip(t.$$replacedScope.$index)})});n(function(){i.attr({tabindex:-1,"aria-hidden":!0});i.find("button").attr("tabindex","-1")})}return{restrict:"A",require:"^mdChips",scope:!1,link:t}}t.module("material.components.chips").directive("mdChipRemove",n);n.$inject=["$timeout"]}(),function(){function n(n){function t(t,i,r){var f=t.$parent.$mdChipsCtrl,u=f.parent.$new(!1,f.parent),e;u.$$replacedScope=t;u.$chip=t.$chip;u.$index=t.$index;u.$mdChipsCtrl=f;e=f.$scope.$eval(r.mdChipTransclude);i.html(e);n(i.contents())(u)}return{restrict:"EA",terminal:!0,link:t,scope:!1}}t.module("material.components.chips").directive("mdChipTransclude",n);n.$inject=["$compile"]}(),function(){function n(n,t,i,r,u,f){this.$timeout=u;this.$mdConstant=t;this.$scope=n;this.parent=n.$parent;this.$log=i;this.$element=r;this.ngModelCtrl=null;this.userInputNgModelCtrl=null;this.userInputElement=null;this.items=[];this.selectedChip=-1;this.hasAutocomplete=!1;this.enableChipEdit=f.parseAttributeBoolean(this.mdEnableChipEdit);this.deleteHint="Press delete to remove this chip.";this.deleteButtonLabel="Remove";this.chipBuffer="";this.useOnAppend=!1;this.useTransformChip=!1;this.useOnAdd=!1;this.useOnRemove=!1;this.useOnSelect=!1}t.module("material.components.chips").controller("MdChipsCtrl",n);n.$inject=["$scope","$mdConstant","$log","$element","$timeout","$mdUtil"];n.prototype.inputKeydown=function(n){var t=this.getChipBuffer();if(!this.hasAutocomplete||!n.isDefaultPrevented||!n.isDefaultPrevented()){if(n.keyCode===this.$mdConstant.KEY_CODE.BACKSPACE){if(t)return;n.preventDefault();n.stopPropagation();this.items.length&&this.selectAndFocusChipSafe(this.items.length-1);return}if((!this.separatorKeys||this.separatorKeys.length<1)&&(this.separatorKeys=[this.$mdConstant.KEY_CODE.ENTER]),this.separatorKeys.indexOf(n.keyCode)!==-1){if(this.hasAutocomplete&&this.requireMatch||!t)return;if(n.preventDefault(),this.hasMaxChipsReached())return;this.appendChip(t.trim());this.resetChipBuffer()}}};n.prototype.updateChipContents=function(n,t){n>=0&&n<this.items.length&&(this.items[n]=t,this.ngModelCtrl.$setDirty())};n.prototype.isEditingChip=function(){return!!this.$element[0].getElementsByClassName("_md-chip-editing").length};n.prototype.chipKeydown=function(n){if(!this.getChipBuffer()&&!this.isEditingChip())switch(n.keyCode){case this.$mdConstant.KEY_CODE.BACKSPACE:case this.$mdConstant.KEY_CODE.DELETE:if(this.selectedChip<0)return;n.preventDefault();this.removeAndSelectAdjacentChip(this.selectedChip);break;case this.$mdConstant.KEY_CODE.LEFT_ARROW:n.preventDefault();this.selectedChip<0&&(this.selectedChip=this.items.length);this.items.length&&this.selectAndFocusChipSafe(this.selectedChip-1);break;case this.$mdConstant.KEY_CODE.RIGHT_ARROW:n.preventDefault();this.selectAndFocusChipSafe(this.selectedChip+1);break;case this.$mdConstant.KEY_CODE.ESCAPE:case this.$mdConstant.KEY_CODE.TAB:if(this.selectedChip<0)return;n.preventDefault();this.onFocus()}};n.prototype.getPlaceholder=function(){var n=this.items.length&&(this.secondaryPlaceholder==""||this.secondaryPlaceholder);return n?this.secondaryPlaceholder:this.placeholder};n.prototype.removeAndSelectAdjacentChip=function(n){var i=this.getAdjacentChipIndex(n);this.removeChip(n);this.$timeout(t.bind(this,function(){this.selectAndFocusChipSafe(i)}))};n.prototype.resetSelectedChip=function(){this.selectedChip=-1};n.prototype.getAdjacentChipIndex=function(n){var t=this.items.length-1;return t==0?-1:n==t?n-1:n};n.prototype.appendChip=function(n){var i,r,u;if((this.useTransformChip&&this.transformChip&&(i=this.transformChip({$chip:n}),t.isDefined(i)&&(n=i)),!t.isObject(n)||(r=this.items.some(function(i){return t.equals(n,i)}),!r))&&n!=null&&!(this.items.indexOf(n)+1)&&(u=this.items.push(n),this.ngModelCtrl.$setDirty(),this.validateModel(),this.useOnAdd&&this.onAdd))this.onAdd({$chip:n,$index:u})};n.prototype.useOnAppendExpression=function(){this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");this.useTransformChip&&this.transformChip||(this.useTransformChip=!0,this.transformChip=this.onAppend)};n.prototype.useTransformChipExpression=function(){this.useTransformChip=!0};n.prototype.useOnAddExpression=function(){this.useOnAdd=!0};n.prototype.useOnRemoveExpression=function(){this.useOnRemove=!0};n.prototype.useOnSelectExpression=function(){this.useOnSelect=!0};n.prototype.getChipBuffer=function(){return this.userInputElement?this.userInputNgModelCtrl?this.userInputNgModelCtrl.$viewValue:this.userInputElement[0].value:this.chipBuffer};n.prototype.resetChipBuffer=function(){this.userInputElement?this.userInputNgModelCtrl?(this.userInputNgModelCtrl.$setViewValue(""),this.userInputNgModelCtrl.$render()):this.userInputElement[0].value="":this.chipBuffer=""};n.prototype.hasMaxChipsReached=function(){return t.isString(this.maxChips)&&(this.maxChips=parseInt(this.maxChips,10)||0),this.maxChips>0&&this.items.length>=this.maxChips};n.prototype.validateModel=function(){this.ngModelCtrl.$setValidity("md-max-chips",!this.hasMaxChipsReached())};n.prototype.removeChip=function(n){var t=this.items.splice(n,1);if(this.ngModelCtrl.$setDirty(),this.validateModel(),t&&t.length&&this.useOnRemove&&this.onRemove)this.onRemove({$chip:t[0],$index:n})};n.prototype.removeChipAndFocusInput=function(n){this.removeChip(n);this.onFocus()};n.prototype.selectAndFocusChipSafe=function(n){if(!this.items.length){this.selectChip(-1);this.onFocus();return}if(n===this.items.length)return this.onFocus();n=Math.max(n,0);n=Math.min(n,this.items.length-1);this.selectChip(n);this.focusChip(n)};n.prototype.selectChip=function(n){if(n>=-1&&n<=this.items.length){if(this.selectedChip=n,this.useOnSelect&&this.onSelect)this.onSelect({$chip:this.items[this.selectedChip]})}else this.$log.warn("Selected Chip index out of bounds; ignoring.")};n.prototype.selectAndFocusChip=function(n){this.selectChip(n);n!=-1&&this.focusChip(n)};n.prototype.focusChip=function(n){this.$element[0].querySelector('md-chip[index="'+n+'"] ._md-chip-content').focus()};n.prototype.configureNgModel=function(n){this.ngModelCtrl=n;var t=this;n.$render=function(){t.items=t.ngModelCtrl.$viewValue}};n.prototype.onFocus=function(){var n=this.$element[0].querySelector("input");n&&n.focus();this.resetSelectedChip()};n.prototype.onInputFocus=function(){this.inputHasFocus=!0;this.resetSelectedChip()};n.prototype.onInputBlur=function(){this.inputHasFocus=!1};n.prototype.configureUserInput=function(n){var r;this.userInputElement=n;r=n.controller("ngModel");r!=this.ngModelCtrl&&(this.userInputNgModelCtrl=r);var f=this.$scope,i=this,u=function(n,r){f.$evalAsync(t.bind(i,r,n))};n.attr({tabindex:0}).on("keydown",function(n){u(n,i.inputKeydown)}).on("focus",function(n){u(n,i.onInputFocus)}).on("blur",function(n){u(n,i.onInputBlur)})};n.prototype.configureAutocomplete=function(n){if(n){this.hasAutocomplete=!0;n.registerSelectedItemWatcher(t.bind(this,function(n){if(n){if(this.hasMaxChipsReached())return;this.appendChip(n);this.resetChipBuffer()}}));this.$element.find("input").on("focus",t.bind(this,this.onInputFocus)).on("blur",t.bind(this,this.onInputBlur))}};n.prototype.hasFocus=function(){return this.inputHasFocus||this.selectedChip>=0}}(),function(){function n(n,t,e,o,s){function c(i,r){function u(n){if(r.ngModel){var t=f[0].querySelector(n);return t&&t.outerHTML}}var f=r.$mdUserTemplate;r.$mdUserTemplate=null;var l=u("md-chips>md-chip-template"),v=u("md-chips>*[md-chip-remove]")||h.remove,y=l||h.default,c=u("md-chips>md-autocomplete")||u("md-chips>input")||h.input,a=f.find("md-chip");return f[0].querySelector("md-chip-template>*[md-chip-remove]")&&o.warn("invalid placement of md-chip-remove within md-chip-template."),function(i,u,f,o){var p,w;t.initOptionalProperties(i,r);n(u);p=o[0];l&&(p.enableChipEdit=!1);p.chipContentsTemplate=y;p.chipRemoveTemplate=v;p.chipInputTemplate=c;u.attr({"aria-hidden":!0,tabindex:-1}).on("focus",function(){p.onFocus()});r.ngModel&&(p.configureNgModel(u.controller("ngModel")),f.mdTransformChip&&p.useTransformChipExpression(),f.mdOnAppend&&p.useOnAppendExpression(),f.mdOnAdd&&p.useOnAddExpression(),f.mdOnRemove&&p.useOnRemoveExpression(),f.mdOnSelect&&p.useOnSelectExpression(),c!=h.input&&i.$watch("$mdChipsCtrl.readonly",function(n){n||t.nextTick(function(){c.indexOf("<md-autocomplete")===0&&p.configureAutocomplete(u.find("md-autocomplete").controller("mdAutocomplete"));p.configureUserInput(u.find("input"))})}),t.nextTick(function(){var n=u.find("input");n&&n.toggleClass("md-input",!0)}));a.length>0&&(w=e(a.clone())(i.$parent),s(function(){u.find("md-chips-wrap").prepend(w)}))}}function l(){return{chips:t.processTemplate(i),input:t.processTemplate(r),"default":t.processTemplate(u),remove:t.processTemplate(f)}}var h=l();return{template:function(n,t){return t.$mdUserTemplate=n.clone(),h.chips},require:["mdChips"],restrict:"E",controller:"MdChipsCtrl",controllerAs:"$mdChipsCtrl",bindToController:!0,compile:c,scope:{readonly:"=readonly",placeholder:"@",mdEnableChipEdit:"@",secondaryPlaceholder:"@",maxChips:"@mdMaxChips",transformChip:"&mdTransformChip",onAppend:"&mdOnAppend",onAdd:"&mdOnAdd",onRemove:"&mdOnRemove",onSelect:"&mdOnSelect",deleteHint:"@",deleteButtonLabel:"@",separatorKeys:"=?mdSeparatorKeys",requireMatch:"=?mdRequireMatch"}}}t.module("material.components.chips").directive("mdChips",n);var i='      <md-chips-wrap          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">          <div class="_md-chip-content"              tabindex="-1"              aria-hidden="true"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"><\/div>          <div ng-if="!$mdChipsCtrl.readonly"               class="_md-chip-remove-container"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"><\/div>        <\/md-chip>        <div class="_md-chip-input-container">          <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"               md-chip-transclude="$mdChipsCtrl.chipInputTemplate"><\/div>        <\/div>      <\/md-chips-wrap>',r='        <input            class="md-input"            tabindex="0"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-trim="false"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">',u="      <span>{{$chip}}<\/span>",f='      <button          class="_md-chip-remove"          ng-if="!$mdChipsCtrl.readonly"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          aria-hidden="true"          tabindex="-1">        <md-icon md-svg-icon="md-close"><\/md-icon>        <span class="_md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        <\/span>      <\/button>';n.$inject=["$mdTheming","$mdUtil","$compile","$log","$timeout"]}(),function(){function n(){this.selectedItem=null;this.searchText=""}t.module("material.components.chips").controller("MdContactChipsCtrl",n);n.prototype.queryContact=function(n){var i=this.contactQuery({$query:n});return this.filterSelected?i.filter(t.bind(this,this.filterSelectedContacts)):i};n.prototype.itemName=function(n){return n[this.contactName]};n.prototype.filterSelectedContacts=function(n){return this.contacts.indexOf(n)==-1}}(),function(){function n(n,t){function r(i,r){return function(i,u){t.initOptionalProperties(i,r);n(u);u.attr("tabindex","-1")}}return{template:function(){return i},restrict:"E",controller:"MdContactChipsCtrl",controllerAs:"$mdContactChipsCtrl",bindToController:!0,compile:r,scope:{contactQuery:"&mdContacts",placeholder:"@",secondaryPlaceholder:"@",contactName:"@mdContactName",contactImage:"@mdContactImage",contactEmail:"@mdContactEmail",contacts:"=ngModel",requireMatch:"=?mdRequireMatch",highlightFlags:"@?mdHighlightFlags"}}}t.module("material.components.chips").directive("mdContactChips",n);var i='      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              <\/span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}<\/span>            <\/div>          <\/md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            <\/div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            <\/div>          <\/md-chip-template>      <\/md-chips>';n.$inject=["$mdTheming","$mdUtil"]}(),function(){function n(n,t,i){function r(r,u,f){function s(){var n=u.parent();return n.attr("aria-label")||n.text()?!0:n.parent().attr("aria-label")||n.parent().text()?!0:!1}function h(){f.mdSvgIcon||f.mdSvgSrc||(f.mdFontIcon&&u.addClass("md-font "+f.mdFontIcon),u.addClass(n.fontSet(f.mdFontSet)))}t(u);h();var e=f.alt||f.mdFontIcon||f.mdSvgIcon||u.text(),o=f.$normalize(f.$attr.mdSvgIcon||f.$attr.mdSvgSrc||"");f["aria-label"]||(e===""||s()?u.text()||i.expect(u,"aria-hidden","true"):(i.expect(u,"aria-label",e),i.expect(u,"role","img")));o&&f.$observe(o,function(t){u.empty();t&&n(t).then(function(n){u.empty();u.append(n)})})}return{restrict:"E",link:r}}t.module("material.components.icon").directive("mdIcon",["$mdIcon","$mdTheming","$mdAria",n])}(),function(){function u(){}function r(n,t){this.url=n;this.viewBoxSize=t||i.defaultViewBoxSize}function f(i,r,u,f,e,o){function a(n){if(n=n||"",s[n])return u.when(w(s[n]));if(y.test(n)||c.test(n))return l(n).then(v(n));n.indexOf(":")==-1&&(n="$default:"+n);var t=i[n]?b:k;return t(n).then(v(n))}function p(n){var u=t.isUndefined(n)||!(n&&n.length),r;return u?i.defaultFontSet:(r=n,t.forEach(i.fontSets,function(t){t.alias==n&&(r=t.fontSet||r)}),r)}function w(n){var i=n.clone(),r="_cache"+o.nextUid();return i.id&&(i.id+=r),t.forEach(i.querySelectorAll("[id]"),function(n){n.id+=r}),i}function v(n){return function(t){return s[n]=g(t)?t:new h(t,i[n]),s[n].clone()}}function b(n){var t=i[n];return l(t.url).then(function(n){return new h(n,t)})}function k(n){function o(i){var f=n.slice(n.lastIndexOf(":")+1),u=i.querySelector("#"+f);return u?new h(u,t):r(n)}function r(n){var t="icon "+n+" not found";return f.warn(t),u.reject(t||n)}var e=n.substring(0,n.lastIndexOf(":"))||"$default",t=i[e];return t?l(t.url).then(o):r(n)}function l(i){function f(i){var r=c.exec(i),f=/base64/i.test(i),e=f?n.atob(r[2]):r[2];return u.when(t.element(e)[0])}function o(n){return r.get(n,{cache:e}).then(function(n){return t.element("<div>").append(n.data).find("svg")[0]}).catch(d)}return c.test(i)?f(i):o(i)}function d(n){var i=t.isString(n)?n:n.message||n.data||n.statusText;return f.warn(i),u.reject(i)}function g(n){return t.isDefined(n.element)&&t.isDefined(n.config)}function h(n,i){n&&n.tagName!="svg"&&(n=t.element('<svg xmlns="http://www.w3.org/2000/svg">').append(n)[0]);n.getAttribute("xmlns")||n.setAttribute("xmlns","http://www.w3.org/2000/svg");this.element=n;this.config=i;this.prepare()}function nt(){var n=this.config?this.config.viewBoxSize:i.defaultViewBoxSize;t.forEach({fit:"",height:"100%",width:"100%",preserveAspectRatio:"xMidYMid meet",viewBox:this.element.getAttribute("viewBox")||"0 0 "+n+" "+n,focusable:!1},function(n,t){this.element.setAttribute(t,n)},this)}function tt(){return this.element.cloneNode(!0)}var s={},y=/[-\w@:%\+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%\+.~#?&//=]*)?/i,c=/^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i;return h.prototype={clone:tt,prepare:nt},a.fontSet=p,a}t.module("material.components.icon").provider("$mdIcon",u);var i={defaultViewBoxSize:24,defaultFontSet:"material-icons",fontSets:[]};u.prototype={icon:function(n,t,u){return n.indexOf(":")==-1&&(n="$default:"+n),i[n]=new r(t,u),this},iconSet:function(n,t,u){return i[n]=new r(t,u),this},defaultIconSet:function(n,t){var u="$default";return i[u]||(i[u]=new r(n,t)),i[u].viewBoxSize=t||i.defaultViewBoxSize,this},defaultViewBoxSize:function(n){return i.defaultViewBoxSize=n,this},fontSet:function(n,t){return i.fontSets.push({alias:n,fontSet:t||n}),this},defaultFontSet:function(n){return i.defaultFontSet=n?n:"",this},defaultIconSize:function(n){return i.defaultIconSize=n,this},preloadIcons:function(n){var t=this;[{id:"md-tabs-arrow",url:"md-tabs-arrow.svg",svg:'<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/><\/g><\/svg>'},{id:"md-close",url:"md-close.svg",svg:'<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/><\/g><\/svg>'},{id:"md-cancel",url:"md-cancel.svg",svg:'<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/><\/g><\/svg>'},{id:"md-menu",url:"md-menu.svg",svg:'<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /><\/svg>'},{id:"md-toggle-arrow",url:"md-toggle-arrow-svg",svg:'<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/><\/svg>'},{id:"md-calendar",url:"md-calendar.svg",svg:'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/><\/svg>'}].forEach(function(i){t.icon(i.id,i.url);n.put(i.url,i.svg)})},$get:["$http","$q","$log","$templateCache","$mdUtil",function(n,t,r,u,e){return this.preloadIcons(u),f(i,n,t,r,u,e)}]};f.$inject=["config","$http","$q","$log","$templateCache","$mdUtil"]}(),function(){function n(n,i,u,f,e,o,s,h){this.$element=u;this.$attrs=f;this.$mdConstant=e;this.$mdUtil=s;this.$document=o;this.$scope=n;this.$rootScope=i;this.$timeout=h;var c=this;t.forEach(r,function(n){c[n]=t.bind(c,c[n])})}t.module("material.components.menuBar").controller("MenuBarController",n);var r=["handleKeyDown","handleMenuHover","scheduleOpenHoveredMenu","cancelScheduledOpen"];n.$inject=["$scope","$rootScope","$element","$attrs","$mdConstant","$document","$mdUtil","$timeout"];n.prototype.init=function(){var t=this.$element,u=this.$mdUtil,f=this.$scope,n=this,r=[];t.on("keydown",this.handleKeyDown);this.parentToolbar=u.getClosest(t,"MD-TOOLBAR");r.push(this.$rootScope.$on("$mdMenuOpen",function(i,r){n.getMenus().indexOf(r[0])!=-1&&(t[0].classList.add("_md-open"),r[0].classList.add("_md-open"),n.currentlyOpenMenu=r.controller("mdMenu"),n.currentlyOpenMenu.registerContainerProxy(n.handleKeyDown),n.enableOpenOnHover())}));r.push(this.$rootScope.$on("$mdMenuClose",function(r,f,e){var s=n.getMenus(),o;if(s.indexOf(f[0])!=-1&&(t[0].classList.remove("_md-open"),f[0].classList.remove("_md-open")),t[0].contains(f[0])){for(o=f[0];o&&s.indexOf(o)==-1;)o=u.getClosest(o,"MD-MENU",!0);o&&(e.skipFocus||o.querySelector("button:not([disabled])").focus(),n.currentlyOpenMenu=i,n.disableOpenOnHover(),n.setKeyboardMode(!0))}}));f.$on("$destroy",function(){while(r.length)r.shift()()});this.setKeyboardMode(!0)};n.prototype.setKeyboardMode=function(n){n?this.$element[0].classList.add("_md-keyboard-mode"):this.$element[0].classList.remove("_md-keyboard-mode")};n.prototype.enableOpenOnHover=function(){if(!this.openOnHoverEnabled){this.openOnHoverEnabled=!0;var n;(n=this.parentToolbar)&&(n.dataset.mdRestoreStyle=n.getAttribute("style"),n.style.position="relative",n.style.zIndex=100);t.element(this.getMenus()).on("mouseenter",this.handleMenuHover)}};n.prototype.handleMenuHover=function(n){this.setKeyboardMode(!1);this.openOnHoverEnabled&&this.scheduleOpenHoveredMenu(n)};n.prototype.disableOpenOnHover=function(){if(this.openOnHoverEnabled){this.openOnHoverEnabled=!1;var n;(n=this.parentToolbar)&&(n.style.cssText=n.dataset.mdRestoreStyle||"");t.element(this.getMenus()).off("mouseenter",this.handleMenuHover)}};n.prototype.scheduleOpenHoveredMenu=function(n){var i=t.element(n.currentTarget),r=i.controller("mdMenu");this.setKeyboardMode(!1);this.scheduleOpenMenu(r)};n.prototype.scheduleOpenMenu=function(n){var t=this,r=this.$timeout;n!=t.currentlyOpenMenu&&(r.cancel(t.pendingMenuOpen),t.pendingMenuOpen=r(function(){t.pendingMenuOpen=i;t.currentlyOpenMenu&&t.currentlyOpenMenu.close(!0,{closeAll:!0});n.open()},200,!1))};n.prototype.handleKeyDown=function(n){var u=this.$mdConstant.KEY_CODE,i=this.currentlyOpenMenu,o=i&&i.isOpen,r,f,e;this.setKeyboardMode(!0);switch(n.keyCode){case u.DOWN_ARROW:i?i.focusMenuContainer():this.openFocusedMenu();r=!0;break;case u.UP_ARROW:i&&i.close();r=!0;break;case u.LEFT_ARROW:f=this.focusMenu(-1);o&&(e=t.element(f).controller("mdMenu"),this.scheduleOpenMenu(e));r=!0;break;case u.RIGHT_ARROW:f=this.focusMenu(1);o&&(e=t.element(f).controller("mdMenu"),this.scheduleOpenMenu(e));r=!0}r&&(n&&n.preventDefault&&n.preventDefault(),n&&n.stopImmediatePropagation&&n.stopImmediatePropagation())};n.prototype.focusMenu=function(n){var r=this.getMenus(),t=this.getFocusedMenuIndex(),i;return t==-1&&(t=this.getOpenMenuIndex()),i=!1,t==-1?(t=0,i=!0):(n<0&&t>0||n>0&&t<r.length-n)&&(t+=n,i=!0),i?(r[t].querySelector("button").focus(),r[t]):void 0};n.prototype.openFocusedMenu=function(){var n=this.getFocusedMenu();n&&t.element(n).controller("mdMenu").open()};n.prototype.getMenus=function(){var n=this.$element;return this.$mdUtil.nodesToArray(n[0].children).filter(function(n){return n.nodeName=="MD-MENU"})};n.prototype.getFocusedMenu=function(){return this.getMenus()[this.getFocusedMenuIndex()]};n.prototype.getFocusedMenuIndex=function(){var t=this.$mdUtil,n=t.getClosest(this.$document[0].activeElement,"MD-MENU");return n?this.getMenus().indexOf(n):-1};n.prototype.getOpenMenuIndex=function(){for(var t=this.getMenus(),n=0;n<t.length;++n)if(t[n].classList.contains("_md-open"))return n;return-1}}(),function(){function n(n,i){return{restrict:"E",require:"mdMenuBar",controller:"MenuBarController",compile:function(r,u){return u.ariaRole||r[0].setAttribute("role","menubar"),t.forEach(r[0].children,function(i){if(i.nodeName=="MD-MENU"){i.hasAttribute("md-position-mode")||(i.setAttribute("md-position-mode","left bottom"),i.querySelector("button,a").setAttribute("role","menuitem"));var r=n.nodesToArray(i.querySelectorAll("md-menu-content"));t.forEach(r,function(n){n.classList.add("_md-menu-bar-menu");n.classList.add("md-dense");n.hasAttribute("width")||n.setAttribute("width",5)})}}),function(n,t,r,u){i(n,t);u.init()}}}}t.module("material.components.menuBar").directive("mdMenuBar",n);n.$inject=["$mdUtil","$mdTheming"]}(),function(){function n(){return{restrict:"E",compile:function(n,t){t.role||n[0].setAttribute("role","separator")}}}t.module("material.components.menuBar").directive("mdMenuDivider",n)}(),function(){function n(n,t,i){this.$element=t;this.$attrs=i;this.$scope=n}t.module("material.components.menuBar").controller("MenuItemController",n);n.$inject=["$scope","$element","$attrs"];n.prototype.init=function(n){var i=this.$element,t=this.$attrs;this.ngModel=n;(t.type=="checkbox"||t.type=="radio")&&(this.mode=t.type,this.iconEl=i[0].children[0],this.buttonEl=i[0].children[1],n&&this.initClickListeners())};n.prototype.clearNgAria=function(){var n=this.$element[0];t.forEach(["role","tabindex","aria-invalid","aria-checked"],function(t){n.removeAttribute(t)})};n.prototype.initClickListeners=function(){function c(){if(h=="radio"){var t=n.ngValue?u.$eval(n.ngValue):n.value;return i.$modelValue==t}return i.$modelValue}function o(n){if(n)r.off("click",e);else r.on("click",e)}var s=this,i=this.ngModel,u=this.$scope,n=this.$attrs,l=this.$element,h=this.mode;this.handleClick=t.bind(this,this.handleClick);var f=this.iconEl,r=t.element(this.buttonEl),e=this.handleClick;n.$observe("disabled",o);o(n.disabled);i.$render=function(){s.clearNgAria();c()?(f.style.display="",r.attr("aria-checked","true")):(f.style.display="none",r.attr("aria-checked","false"))};u.$$postDigest(i.$render)};n.prototype.handleClick=function(){var r=this.mode,n=this.ngModel,t=this.$attrs,i;r=="checkbox"?i=!n.$modelValue:r=="radio"&&(i=t.ngValue?this.$scope.$eval(t.ngValue):t.value);n.$setViewValue(i);n.$render()}}(),function(){function n(){return{require:["mdMenuItem","?ngModel"],priority:210,compile:function(n,i){function u(i,r,u){u=u||n;u instanceof t.element&&(u=u[0]);u.hasAttribute(i)||u.setAttribute(i,r)}function e(t){if(n[0].hasAttribute(t)){var i=n[0].getAttribute(t);r[0].setAttribute(t,i);n[0].removeAttribute(t)}}if(i.type=="checkbox"||i.type=="radio"){var f=n[0].textContent,r=t.element('<md-button type="button"><\/md-button>');r.html(f);r.attr("tabindex","0");n.html("");n.append(t.element('<md-icon md-svg-icon="check"><\/md-icon>'));n.append(r);n[0].classList.add("md-indent");u("role",i.type=="checkbox"?"menuitemcheckbox":"menuitemradio",r);t.forEach(["ng-disabled"],e)}else u("role","menuitem",n[0].querySelector("md-button,button,a"));return function(n,t,i,r){var u=r[0],f=r[1];u.init(f)}},controller:"MenuItemController"}}t.module("material.components.menuBar").directive("mdMenuItem",n)}(),function(){function n(n,r,u,f,e,o,s,h){var l,c=this,a,p,v,y;this.nestLevel=parseInt(r.mdNestLevel,10)||0;this.init=function(i,r){r=r||{};l=i;a=u[0].querySelector("[ng-click],[ng-mouseenter]");a.setAttribute("aria-expanded","false");this.isInMenuBar=r.isInMenuBar;this.nestedMenus=e.nodesToArray(l[0].querySelectorAll(".md-nested-menu"));l.on("$mdInterimElementRemove",function(){c.isOpen=!1});var o="menu_container_"+e.nextUid();l.attr("id",o);t.element(a).attr({"aria-owns":o,"aria-haspopup":"true"});f.$on("$destroy",this.disableHoverListener);l.on("$destroy",function(){n.destroy()})};y=[];this.enableHoverListener=function(){y.push(s.$on("$mdMenuOpen",function(n,t){l[0].contains(t[0])&&(c.currentlyOpenMenu=t.controller("mdMenu"),c.isAlreadyOpening=!1,c.currentlyOpenMenu.registerContainerProxy(c.triggerContainerProxy.bind(c)))}));y.push(s.$on("$mdMenuClose",function(n,t){l[0].contains(t[0])&&(c.currentlyOpenMenu=i)}));v=t.element(e.nodesToArray(l[0].children[0].children));v.on("mouseenter",c.handleMenuItemHover);v.on("mouseleave",c.handleMenuItemMouseLeave)};this.disableHoverListener=function(){while(y.length)y.shift()();v&&v.off("mouseenter",c.handleMenuItemHover);v&&v.off("mouseleave",c.handleMenuMouseLeave)};this.handleMenuItemHover=function(n){var i,r;c.isAlreadyOpening||(i=n.target.querySelector("md-menu")||e.getClosest(n.target,"MD-MENU"),p=o(function(){if(i&&(i=t.element(i).controller("mdMenu")),c.currentlyOpenMenu&&c.currentlyOpenMenu!=i){var n=c.nestLevel+1;c.currentlyOpenMenu.close(!0,{closeTo:n});c.isAlreadyOpening=!0;i.open()}else i&&!i.isOpen&&i.open&&(c.isAlreadyOpening=!0,i.open())},i?100:250),r=n.currentTarget.querySelector(".md-button:not([disabled])"),r&&r.focus())};this.handleMenuItemMouseLeave=function(){p&&(o.cancel(p),p=i)};this.open=function(t){(t&&t.stopPropagation(),t&&t.preventDefault(),c.isOpen)||(c.enableHoverListener(),c.isOpen=!0,a=a||(t?t.target:u[0]),a.setAttribute("aria-expanded","true"),f.$emit("$mdMenuOpen",u),n.show({scope:f,mdMenuCtrl:c,nestLevel:c.nestLevel,element:l,target:a,preserveElement:!0,parent:"body"}).finally(function(){a.setAttribute("aria-expanded","false");c.disableHoverListener()}))};f.$mdOpenMenu=this.open;f.$watch(function(){return c.isOpen},function(n){n?(l.attr("aria-hidden","false"),u[0].classList.add("_md-open"),t.forEach(c.nestedMenus,function(n){n.classList.remove("_md-open")})):(l.attr("aria-hidden","true"),u[0].classList.remove("_md-open"));f.$mdMenuIsOpen=c.isOpen});this.focusMenuContainer=function(){var n=l[0].querySelector("[md-menu-focus-target]");n||(n=l[0].querySelector(".md-button"));n.focus()};this.registerContainerProxy=function(n){this.containerProxy=n};this.triggerContainerProxy=function(n){this.containerProxy&&this.containerProxy(n)};this.destroy=function(){return c.isOpen?n.destroy():h.when(!1)};this.close=function(i,r){var o,e;c.isOpen&&(c.isOpen=!1,o=t.extend({},r,{skipFocus:i}),f.$emit("$mdMenuClose",u,o),n.hide(null,r),i||(e=c.restoreFocusTo||u.find("button")[0],e instanceof t.element&&(e=e[0]),e&&e.focus()))};this.positionMode=function(){var n=(r.mdPositionMode||"target").split(" ");return n.length==1&&n.push(n[0]),{left:n[0],top:n[1]}};this.offsets=function(){var n=(r.mdOffset||"0 0").split(" ").map(parseFloat);if(n.length==2)return{left:n[0],top:n[1]};if(n.length==1)return{top:n[0],left:n[0]};throw Error("Invalid offsets specified. Please follow format <x, y> or <n>");}}t.module("material.components.menu").controller("mdMenuCtrl",n);n.$inject=["$mdMenu","$attrs","$element","$scope","$mdUtil","$timeout","$rootScope","$q"]}(),function(){function n(n){function u(i){var u,e,o;if(i.addClass("md-menu"),u=i.children()[0],u.hasAttribute("ng-click")||(u=u.querySelector("[ng-click],[ng-mouseenter]")||u),u&&(u.nodeName=="MD-BUTTON"||u.nodeName=="BUTTON")&&!u.hasAttribute("type")&&u.setAttribute("type","button"),i.children().length!=2)throw Error(r+"Expected two children elements.");return u&&u.setAttribute("aria-haspopup","true"),e=i[0].querySelectorAll("md-menu"),o=parseInt(i[0].getAttribute("md-nest-level"),10)||0,e&&t.forEach(n.nodesToArray(e),function(n){n.hasAttribute("md-position-mode")||n.setAttribute("md-position-mode","cascade");n.classList.add("_md-nested-menu");n.setAttribute("md-nest-level",o+1)}),f}function f(n,r,u,f){var s=f[0],h=f[1]!=i,e=t.element('<div class="_md-open-menu-container md-whiteframe-z2"><\/div>'),o=r.children()[1];o.hasAttribute("role")||o.setAttribute("role","menu");e.append(o);r.on("$destroy",function(){e.remove()});r.append(e);e[0].style.display="none";s.init(e,{isInMenuBar:h})}var r="Invalid HTML for md-menu: ";return{restrict:"E",require:["mdMenu","?^mdMenuBar"],controller:"mdMenuCtrl",scope:!0,compile:u}}t.module("material.components.menu").directive("mdMenu",n);n.$inject=["$mdUtil"]}(),function(){function n(n){function f(n,f,e,o,s,h,c,l,a){function w(i,r,u){return u.nestLevel?t.noop:(u.disableParentScroll&&!n.getClosest(u.target,"MD-DIALOG")?u.restoreScroll=n.disableScrollAround(u.element,u.parent):u.disableParentScroll=!1,u.hasBackdrop&&(u.backdrop=n.createBackdrop(i,"_md-menu-backdrop _md-click-catcher"),a.enter(u.backdrop,o[0].body)),function(){u.backdrop&&u.backdrop.remove();u.disableParentScroll&&u.restoreScroll()})}function b(n,t,i){function u(){return l(t,{addClass:"_md-leave"}).start()}function r(){t.removeClass("_md-active");g(t,i);i.alreadyOpen=!1}return i.cleanupInteraction(),i.cleanupResizing(),i.hideBackdrop(),i.$destroy===!0?r():u().then(r)}function k(i,r,u){function o(){return u.parent.append(r),r[0].style.display="",h(function(n){var t=p(r,u);r.removeClass("_md-leave");l(r,{addClass:"_md-active",from:v.toCss(t),to:v.toCss({transform:""})}).start().then(n)})}function a(){if(!u.target)throw Error("$mdMenu.show() expected a target to animate from in options.target");t.extend(u,{alreadyOpen:!1,isRemoved:!1,target:t.element(u.target),parent:t.element(u.parent),menuContentEl:t.element(r[0].querySelector("md-menu-content"))})}function b(){var n=function(n,t){return c.throttle(function(){if(!u.isRemoved){var i=p(n,t);n.css(v.toCss(i))}})}(r,u);return s.addEventListener("resize",n),s.addEventListener("orientationchange",n),function(){s.removeEventListener("resize",n);s.removeEventListener("orientationchange",n)}}function k(){function s(t){var i,r;switch(t.keyCode){case e.KEY_CODE.ESCAPE:u.mdMenuCtrl.close(!1,{closeAll:!0});i=!0;break;case e.KEY_CODE.UP_ARROW:y(t,u.menuContentEl,u,-1)||u.nestLevel||u.mdMenuCtrl.triggerContainerProxy(t);i=!0;break;case e.KEY_CODE.DOWN_ARROW:y(t,u.menuContentEl,u,1)||u.nestLevel||u.mdMenuCtrl.triggerContainerProxy(t);i=!0;break;case e.KEY_CODE.LEFT_ARROW:u.nestLevel?u.mdMenuCtrl.close():u.mdMenuCtrl.triggerContainerProxy(t);i=!0;break;case e.KEY_CODE.RIGHT_ARROW:r=n.getClosest(t.target,"MD-MENU");r&&r!=u.parent[0]?t.target.click():u.mdMenuCtrl.triggerContainerProxy(t);i=!0}i&&(t.preventDefault(),t.stopImmediatePropagation())}function h(n){n.preventDefault();n.stopPropagation();i.$apply(function(){u.mdMenuCtrl.close(!0,{closeAll:!0})})}function o(t){function o(){i.$apply(function(){u.mdMenuCtrl.close(!0,{closeAll:!0})})}function e(n,t){var r,i,f,u,e;if(!n)return!1;for(r=0;i=t[r];++r)for(f=[i,"data-"+i,"x-"+i],u=0;e=f[u];++u)if(n.hasAttribute(e))return!0;return!1}var r=t.target,f;do{if(r==u.menuContentEl[0])return;if((e(r,["ng-click","ng-href","ui-sref"])||r.nodeName=="BUTTON"||r.nodeName=="MD-BUTTON")&&!e(r,["md-prevent-menu-close"])){f=n.getClosest(r,"MD-MENU");r.hasAttribute("disabled")||f&&f!=u.parent[0]||o();break}}while(r=r.parentNode)}var t,f;if(r.addClass("_md-clickable"),u.backdrop)u.backdrop.on("click",h);u.menuContentEl.on("keydown",s);return u.menuContentEl[0].addEventListener("click",o,!0),t=u.menuContentEl[0].querySelector("[md-menu-focus-target]"),t||(f=u.menuContentEl[0].firstElementChild,t=f&&(f.querySelector(".md-button:not([disabled])")||f.firstElementChild)),t&&t.focus(),function(){r.removeClass("_md-clickable");u.backdrop&&u.backdrop.off("click",h);u.menuContentEl.off("keydown",s);u.menuContentEl[0].removeEventListener("click",o,!0)}}return a(u),f.inherit(u.menuContentEl,u.target),u.cleanupResizing=b(),u.hideBackdrop=w(i,r,u),o().then(function(n){return u.alreadyOpen=!0,u.cleanupInteraction=k(),n})}function y(t,i,r,u){for(var s,h=n.getClosest(t.target,"MD-MENU-ITEM"),e=n.nodesToArray(i[0].children),c=e.indexOf(h),o,f=c+u;f>=0&&f<e.length;f=f+u)if(s=e[f].querySelector(".md-button"),o=d(s),o)break;return o}function d(n){if(n&&n.getAttribute("tabindex")!=-1)return n.focus(),o[0].activeElement==n}function g(n,t){t.preserveElement?r(n).style.display="none":r(n).parentNode===r(t.parent)&&r(t.parent).removeChild(r(n))}function p(t,r){function et(n){n.top=Math.max(Math.min(n.top,p.bottom-a.offsetHeight),p.top);n.left=Math.max(Math.min(n.left,p.right-a.offsetWidth),p.left)}function ot(){for(var n=0;n<w.children.length;++n)if(s.getComputedStyle(w.children[n]).display!="none")return w.children[n]}var a=t[0],w=t[0].firstElementChild,v=w.getBoundingClientRect(),ut=o[0].body,y=ut.getBoundingClientRect(),ft=s.getComputedStyle(w),b=r.target[0].querySelector("[md-menu-origin]")||r.target[0],f=b.getBoundingClientRect(),p={left:y.left+u,top:Math.max(y.top,0)+u,bottom:Math.max(y.bottom,Math.max(y.top,0)+y.height)-u,right:y.right-u},h,k={top:0,left:0,right:0,bottom:0},g={top:0,left:0,right:0,bottom:0},l=r.mdMenuCtrl.positionMode(),e,c,d,nt,tt,it,rt;(l.top=="target"||l.left=="target"||l.left=="target-right")&&(h=ot(),h&&(h=h.firstElementChild||h,h=h.querySelector("[md-menu-align-target]")||h,k=h.getBoundingClientRect(),g={top:parseFloat(a.style.top||0),left:parseFloat(a.style.left||0)}));e={};c="top ";switch(l.top){case"target":e.top=g.top+f.top-k.top;break;case"cascade":e.top=f.top-parseFloat(ft.paddingTop)-b.style.top;break;case"bottom":e.top=f.top+f.height;break;default:throw new Error('Invalid target mode "'+l.top+'" specified for md-menu on Y axis.');}d=n.bidi()=="rtl";switch(l.left){case"target":e.left=g.left+f.left-k.left;c+=d?"right":"left";break;case"target-left":e.left=f.left;c+="left";break;case"target-right":e.left=f.right-v.width+(v.right-k.right);c+="right";break;case"cascade":nt=d?f.left-v.width<p.left:f.right+v.width<p.right;e.left=nt?f.right-b.style.left:f.left-b.style.left-v.width;c+=nt?"left":"right";break;case"left":d?(e.left=f.right-v.width,c+="right"):(e.left=f.left,c+="left");break;default:throw new Error('Invalid target mode "'+l.left+'" specified for md-menu on X axis.');}return tt=r.mdMenuCtrl.offsets(),e.top+=tt.top,e.left+=tt.left,et(e),it=Math.round(100*Math.min(f.width/a.offsetWidth,1))/100,rt=Math.round(100*Math.min(f.height/a.offsetHeight,1))/100,{top:Math.round(e.top),left:Math.round(e.left),transform:r.alreadyOpen?i:n.supplant("scale({0},{1})",[it,rt]),transformOrigin:c}}var v=n.dom.animator;return{parent:"body",onShow:k,onRemove:b,hasBackdrop:!0,disableParentScroll:!0,skipCompile:!0,preserveScope:!0,skipHide:!0,themable:!0}}function r(n){return n instanceof t.element&&(n=n[0]),n}var u=8;return f.$inject=["$mdUtil","$mdTheming","$mdConstant","$document","$window","$q","$$rAF","$animateCss","$animate"],n("$mdMenu").setDefaults({methods:["target"],options:f})}t.module("material.components.menu").provider("$mdMenu",n);n.$inject=["$$interimElementProvider"]}(),function(){function n(n,i,r,u,f,e,o){function w(o,a,p){function it(t,u,e,s,c){var w=++tt,k=f.now(),d=u-t,a=h(o.mdDiameter),p=a-y(a),g=e||r.easeFn,v=s||r.duration;u===t?b.attr("d",l(u,a,p,c)):n(function nt(r){var u=i.Math.min((r||f.now())-k,v);b.attr("d",l(g(u,t,d,v),a,p,c));w===tt&&u<v&&n(nt)})}function rt(){it(d,k,r.easeFnIndeterminate,r.durationIndeterminate,g);g=(g+k)%100;var n=d;d=-k;k=-n}function ut(){if(!w){var i=f.now(),u=r.rotationDurationIndeterminate,t=h(o.mdDiameter)/2;t=" "+t+", "+t;n(function s(e){var o=e||f.now(),h=o-i,c=r.easingPresets.linearEase(h,0,360,u);b.attr("transform","rotate("+c+t+")");w?n(s):b.removeAttr("transform");h>=u&&(i=o)});w=e(rt,r.durationIndeterminate+50,0,!1);rt();a.removeAttr("aria-valuenow")}}function ft(){w&&(e.cancel(w),w=null)}var nt=t.element(a[0].querySelector("svg")),b=t.element(a[0].querySelector("path")),d=r.startIndeterminate,k=r.endIndeterminate,g=0,tt=0,w;u(a);o.mdMode===s&&ut();o.$watchGroup(["value","mdMode"],function(n,t){var i=n[1],r;i!==c&&i!==s&&(i=s,p.$set("mdMode",i));i===s?ut():(r=v(n[0]),ft(),a.attr("aria-valuenow",r),it(v(t[0]),r))});o.$watch("mdDiameter",function(n){var t=h(n),r=y(t),i={width:t+"px",height:t+"px"};nt[0].setAttribute("viewBox","0 0 "+t+" "+t);nt.css(i);a.css(i);b.css("stroke-width",r+"px")})}function l(n,t,i,r){var e=359.99/100,c=r||0,o=t/2,f=i/2,s=c*e,u=n*e,l=a(o,f,s),v=a(o,f,u+s),y=u<0?0:1,h;return h=u<0?u>=-180?0:1:u<=180?0:1,"M"+l+"A"+f+","+f+" 0 "+h+","+y+" "+v}function a(n,t,r){var u=(r-90)*p;return n+t*i.Math.cos(u)+","+(n+t*i.Math.sin(u))}function v(n){return i.Math.max(0,i.Math.min(n||0,100))}function h(n){var i=r.progressSize,t;return n?(t=parseFloat(n),n.lastIndexOf("%")===n.length-1&&(t=t/100*i),t):i}function y(n){return r.strokeWidth/100*n}var p=i.Math.PI/180,c="determinate",s="indeterminate";return{restrict:"E",scope:{value:"@",mdDiameter:"@",mdMode:"@"},template:'<svg xmlns="http://www.w3.org/2000/svg"><path fill="none"/><\/svg>',compile:function(n,i){if(n.attr({"aria-valuemin":0,"aria-valuemax":100,role:"progressbar"}),t.isUndefined(i.mdMode)){var u=t.isDefined(i.value),r=u?c:s;o.debug(f.supplant("Auto-adding the missing md-mode='{0}' to the ProgressCircular element",[r]));i.$set("mdMode",r)}else i.$set("mdMode",i.mdMode.trim());return w}}}t.module("material.components.progressCircular").directive("mdProgressCircular",n);n.$inject=["$$rAF","$window","$mdProgressCircular","$mdTheming","$mdUtil","$interval","$log"]}(),function(){function n(){function i(n,t,i,r){return i*n/r+t}function r(n,t,i,r){var u=(n/=r)*n,f=u*n;return t+i*(6*f*u+-15*u*u+10*f)}var n={progressSize:50,strokeWidth:10,duration:100,easeFn:i,durationIndeterminate:500,startIndeterminate:3,endIndeterminate:80,rotationDurationIndeterminate:2900,easeFnIndeterminate:r,easingPresets:{linearEase:i,materialEase:r}};return{configure:function(i){return n=t.extend(n,i||{})},$get:function(){return n}}}t.module("material.components.progressCircular").provider("$mdProgressCircular",n)}(),function(){function n(){function i(i,r,u,f){if(f){var o=f.getTabElementIndex(r),s=n(r,"md-tab-body").remove(),h=n(r,"md-tab-label").remove(),e=f.insertTab({scope:i,parent:i.$parent,index:o,element:r,template:s.html(),label:h.html()},o);i.select=i.select||t.noop;i.deselect=i.deselect||t.noop;i.$watch("active",function(n){n&&f.select(e.getIndex(),!0)});i.$watch("disabled",function(){f.refreshIndex()});i.$watch(function(){return f.getTabElementIndex(r)},function(n){e.index=n;f.updateTabOrder()});i.$on("$destroy",function(){f.removeTab(e)})}}function n(n,i){for(var u,f=n[0].children,r=0,e=f.length;r<e;r++)if(u=f[r],u.tagName===i.toUpperCase())return t.element(u);return t.element()}return{require:"^?mdTabs",terminal:!0,compile:function(r,u){var f=n(r,"md-tab-label"),e=n(r,"md-tab-body"),o;return f.length==0&&(f=t.element("<md-tab-label><\/md-tab-label>"),u.label?f.text(u.label):f.append(r.contents()),e.length==0&&(o=r.contents().detach(),e=t.element("<md-tab-body><\/md-tab-body>"),e.append(o))),r.append(f),e.html()&&r.append(e),i},scope:{active:"=?mdActive",disabled:"=?ngDisabled",select:"&?mdOnSelect",deselect:"&?mdOnDeselect"}}}t.module("material.components.tabs").directive("mdTab",n)}(),function(){function n(){return{require:"^?mdTabs",link:function(n,t,i,r){r&&r.attachRipple(n,t)}}}t.module("material.components.tabs").directive("mdTabItem",n)}(),function(){function n(){return{terminal:!0}}t.module("material.components.tabs").directive("mdTabLabel",n)}(),function(){function n(n){return{restrict:"A",compile:function(t,i){var r=n(i.mdTabScroll,null,!0);return function(n,t){t.on("mousewheel",function(t){n.$apply(function(){r(n,{$event:t})})})}}}}t.module("material.components.tabs").directive("mdTabScroll",n);n.$inject=["$parse"]}(),function(){function n(n,r,u,f,e,o,s,h,c,l){function pt(){a.selectedIndex=a.selectedIndex||0;wt();kt();bt();l(r);o.nextTick(function(){ht();it();rt();a.tabs[a.selectedIndex]&&a.tabs[a.selectedIndex].scope.select();ut=!0;k()})}function wt(){var i=h.$mdTabsTemplate,n=t.element(v.data);n.html(i);c(n.contents())(a.parent);delete h.$mdTabsTemplate}function bt(){t.element(u).on("resize",ft);n.$on("$destroy",gt)}function kt(){n.$watch("$mdTabsCtrl.selectedIndex",oi)}function dt(n,t){var i=h.$normalize("md-"+n);t&&p(n,t);h.$observe(i,function(t){a[n]=t})}function y(n,t){function r(t){a[n]=t!=="false"}var i=h.$normalize("md-"+n);t&&p(n,t);h.hasOwnProperty(i)&&r(h[i]);h.$observe(i,r)}function gt(){ct=!0;t.element(u).off("resize",ft)}function ni(){t.element(v.wrapper).toggleClass("md-stretch-tabs",at());rt()}function ti(){a.shouldCenterTabs=et()}function ii(n,i){n!==i&&(t.forEach(v.tabs,function(t){t.style.maxWidth=n+"px"}),o.nextTick(a.updateInkBarStyles))}function ri(n,t){n!==t&&(a.maxTabWidth=tt(),a.shouldCenterTabs=et(),o.nextTick(function(){a.maxTabWidth=tt();it(a.selectedIndex)}))}function ui(n){r[n?"removeClass":"addClass"]("md-no-tab-content")}function fi(i){var r=a.shouldCenterTabs?"":"-"+i+"px";t.element(v.paging).css(f.CSS.TRANSFORM,"translate3d("+r+", 0, 0)");n.$broadcast("$mdTabsPaginationChanged")}function ei(n,t){n!==t&&v.tabs[n]&&(it(),vt())}function oi(t,i){t!==i&&(a.selectedIndex=ot(t),a.lastSelectedIndex=i,a.updateInkBarStyles(),ht(),it(t),n.$broadcast("$mdTabsChanged"),a.tabs[i]&&a.tabs[i].scope.deselect(),a.tabs[t]&&a.tabs[t].scope.select())}function si(n){var t=r[0].getElementsByTagName("md-tab");return Array.prototype.indexOf.call(t,n[0])}function b(){b.watcher||(b.watcher=n.$watch(function(){o.nextTick(function(){b.watcher&&r.prop("offsetParent")&&(b.watcher(),b.watcher=null,ft())},!1)}))}function hi(n){switch(n.keyCode){case f.KEY_CODE.LEFT_ARROW:n.preventDefault();st(-1,!0);break;case f.KEY_CODE.RIGHT_ARROW:n.preventDefault();st(1,!0);break;case f.KEY_CODE.SPACE:case f.KEY_CODE.ENTER:n.preventDefault();d||(a.selectedIndex=a.focusIndex)}a.lastClick=!1}function lt(n,t){(d||(a.focusIndex=a.selectedIndex=n),a.lastClick=!0,t&&a.noSelectClick)||o.nextTick(function(){a.tabs[n].element.triggerHandler("click")},!1)}function ci(n){a.shouldPaginate&&(n.preventDefault(),a.offsetLeft=w(a.offsetLeft-n.wheelDelta))}function li(){for(var i=v.canvas.clientWidth,r=i+a.offsetLeft,t,n=0;n<v.tabs.length;n++)if(t=v.tabs[n],t.offsetLeft+t.offsetWidth>r)break;a.offsetLeft=w(t.offsetLeft)}function ai(){for(var n,t=0;t<v.tabs.length;t++)if(n=v.tabs[t],n.offsetLeft+n.offsetWidth>=a.offsetLeft)break;a.offsetLeft=w(n.offsetLeft+n.offsetWidth-v.canvas.clientWidth)}function ft(){a.lastSelectedIndex=a.selectedIndex;a.offsetLeft=w(a.offsetLeft);o.nextTick(function(){a.updateInkBarStyles();k()})}function vi(n){t.element(v.inkBar).toggleClass("ng-hide",n)}function yi(n){r.toggleClass("md-dynamic-height",n)}function pi(n){if(!ct){var t=a.selectedIndex,i=a.tabs.splice(n.getIndex(),1)[0];yt();a.selectedIndex===t&&(i.scope.deselect(),a.tabs[a.selectedIndex]&&a.tabs[a.selectedIndex].scope.select());o.nextTick(function(){k();a.offsetLeft=w(a.offsetLeft)})}}function wi(n,i){var u=ut,f={getIndex:function(){return a.tabs.indexOf(r)},isActive:function(){return this.getIndex()===a.selectedIndex},isLeft:function(){return this.getIndex()<a.selectedIndex},isRight:function(){return this.getIndex()>a.selectedIndex},shouldRender:function(){return!a.noDisconnect||this.isActive()},hasFocus:function(){return!a.lastClick&&a.hasFocus&&this.getIndex()===a.focusIndex},id:o.nextUid()},r=t.extend(f,n);return t.isDefined(i)?a.tabs.splice(i,0,r):a.tabs.push(r),ir(),rr(),o.nextTick(function(){k();u&&a.autoselect&&o.nextTick(function(){o.nextTick(function(){lt(a.tabs.indexOf(r))})})}),r}function nt(){var n={};return n.wrapper=r[0].getElementsByTagName("md-tabs-wrapper")[0],n.data=r[0].getElementsByTagName("md-tab-data")[0],n.canvas=n.wrapper.getElementsByTagName("md-tabs-canvas")[0],n.paging=n.canvas.getElementsByTagName("md-pagination-wrapper")[0],n.tabs=n.paging.getElementsByTagName("md-tab-item"),n.dummies=n.canvas.getElementsByTagName("md-dummy-tab"),n.inkBar=n.paging.getElementsByTagName("md-ink-bar")[0],n.contentsWrapper=r[0].getElementsByTagName("md-tabs-content-wrapper")[0],n.contents=n.contentsWrapper.getElementsByTagName("md-tab-content"),n}function bi(){return a.offsetLeft>0}function ki(){var n=v.tabs[v.tabs.length-1];return n&&n.offsetLeft+n.offsetWidth>v.canvas.clientWidth+a.offsetLeft}function at(){switch(a.stretchTabs){case"always":return!0;case"never":return!1;default:return!a.shouldPaginate&&u.matchMedia("(max-width: 600px)").matches}}function et(){return a.centerTabs&&!a.shouldPaginate}function di(){if(a.noPagination||!ut)return!1;var n=r.prop("clientWidth");return t.forEach(nt().dummies,function(t){n-=t.offsetWidth}),n<0}function ot(n){if(n===-1)return-1;for(var r=Math.max(a.tabs.length-n,n),t,i=0;i<=r;i++)if((t=a.tabs[n+i],t&&t.scope.disabled!==!0)||(t=a.tabs[n-i],t&&t.scope.disabled!==!0))return t.getIndex();return n}function p(n,t,i){Object.defineProperty(a,n,{get:function(){return i},set:function(n){var r=i;i=n;t&&t(n,r)}})}function k(){gi();a.maxTabWidth=tt();a.shouldPaginate=di()}function gi(){at()?t.element(v.paging).css("width",""):t.element(v.paging).css("width",nr()+"px")}function nr(){var n=1;return t.forEach(nt().dummies,function(t){n+=Math.max(t.offsetWidth,t.getBoundingClientRect().width)}),Math.ceil(n)}function tt(){return r.prop("clientWidth")}function tr(){var n=a.tabs[a.selectedIndex],t=a.tabs[a.focusIndex];a.tabs=a.tabs.sort(function(n,t){return n.index-t.index});a.selectedIndex=a.tabs.indexOf(n);a.focusIndex=a.tabs.indexOf(t)}function st(n,t){for(var r=t?"focusIndex":"selectedIndex",u=a[r],i=u+n;a.tabs[i]&&a.tabs[i].scope.disabled;i+=n);a.tabs[i]&&(a[r]=i)}function vt(){nt().dummies[a.focusIndex].focus()}function it(n){if((n==null&&(n=a.focusIndex),v.tabs[n])&&!a.shouldCenterTabs){var t=v.tabs[n],i=t.offsetLeft,r=t.offsetWidth+i;a.offsetLeft=Math.max(a.offsetLeft,w(r-v.canvas.clientWidth+64));a.offsetLeft=Math.min(a.offsetLeft,w(i))}}function ir(){g.forEach(function(n){o.nextTick(n)});g=[]}function rr(){var n=!1;t.forEach(a.tabs,function(t){t.template&&(n=!0)});a.hasContent=n}function yt(){a.selectedIndex=ot(a.selectedIndex);a.focusIndex=ot(a.focusIndex)}function ht(){var f,h;if(!a.dynamicHeight)return r.css("height","");if(!a.tabs.length)return g.push(ht);var e=v.contents[a.selectedIndex],c=e?e.offsetHeight:0,t=v.wrapper.offsetHeight,u=c+t,n=r.prop("clientHeight");n!==u&&(r.attr("md-align-tabs")==="bottom"&&(n-=t,u-=t,r.attr("md-border-bottom")!==i&&++n),d=!0,f={height:n+"px"},h={height:u+"px"},r.css(f),s(r,{from:f,to:h,easing:"cubic-bezier(0.35, 0, 0.25, 1)",duration:.5}).start().done(function(){r.css({transition:"none",height:""});o.nextTick(function(){r.css("transition","")});d=!1}))}function rt(){if(!v.tabs[a.selectedIndex]){t.element(v.inkBar).css({left:"auto",right:"auto"});return}if(!a.tabs.length)return g.push(a.updateInkBarStyles);if(!r.prop("offsetParent"))return b();var e=a.selectedIndex,n=v.paging.offsetWidth,i=v.tabs[e],u=i.offsetLeft,s=n-u-i.offsetWidth,f;a.shouldCenterTabs&&(f=Array.prototype.slice.call(v.tabs).reduce(function(n,t){return n+t.offsetWidth},0),n>f&&o.nextTick(rt,!1));ur();t.element(v.inkBar).css({left:u+"px",right:s+"px"})}function ur(){var i=a.selectedIndex,n=a.lastSelectedIndex,r=t.element(v.inkBar);t.isNumber(n)&&r.toggleClass("md-left",i<n).toggleClass("md-right",i>n)}function w(n){if(!v.tabs.length||!a.shouldPaginate)return 0;var t=v.tabs[v.tabs.length-1],i=t.offsetLeft+t.offsetWidth;return n=Math.max(0,n),Math.min(i-v.canvas.clientWidth,n)}function fr(n,i){var r={colorElement:t.element(v.inkBar)};e.attach(n,i,r)}var a=this,d=!1,v=nt(),g=[],ct=!1,ut=!1;dt("stretchTabs",ni);p("focusIndex",ei,a.selectedIndex||0);p("offsetLeft",fi,0);p("hasContent",ui,!1);p("maxTabWidth",ii,tt());p("shouldPaginate",ri,!1);y("noInkBar",vi);y("dynamicHeight",yi);y("noPagination");y("swipeContent");y("noDisconnect");y("autoselect");y("noSelectClick");y("centerTabs",ti,!1);y("enableDisconnect");a.scope=n;a.parent=n.$parent;a.tabs=[];a.lastSelectedIndex=null;a.hasFocus=!1;a.lastClick=!0;a.shouldCenterTabs=et();a.updatePagination=o.debounce(k,100);a.redirectFocus=vt;a.attachRipple=fr;a.insertTab=wi;a.removeTab=pi;a.select=lt;a.scroll=ci;a.nextPage=li;a.previousPage=ai;a.keydown=hi;a.canPageForward=ki;a.canPageBack=bi;a.refreshIndex=yt;a.incrementIndex=st;a.getTabElementIndex=si;a.updateInkBarStyles=o.debounce(rt,100);a.updateTabOrder=o.debounce(tr,100);pt()}t.module("material.components.tabs").controller("MdTabsController",n);n.$inject=["$scope","$element","$window","$mdConstant","$mdTabInkRipple","$mdUtil","$animateCss","$attrs","$compile","$mdTheming"]}(),function(){function n(){return{scope:{selectedIndex:"=?mdSelected"},template:function(n,t){return t.$mdTabsTemplate=n.html(),'<md-tabs-wrapper> <md-tab-data><\/md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-icon="md-tabs-arrow"><\/md-icon> <\/md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-icon="md-tabs-arrow"><\/md-icon> <\/md-next-button> <md-tabs-canvas tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)" role="tablist"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)"> <md-tab-item tabindex="-1" class="md-tab" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"><\/md-tab-item> <md-ink-bar><\/md-ink-bar> <\/md-pagination-wrapper> <div class="_md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" id="tab-item-{{::tab.id}}" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"><\/md-dummy-tab> <\/div> <\/md-tabs-canvas> <\/md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> <md-tab-content id="tab-content-{{::tab.id}}" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="$mdTabsCtrl.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"><\/div> <\/md-tab-content> <\/md-tabs-content-wrapper>'},controller:"MdTabsController",controllerAs:"$mdTabsCtrl",bindToController:!0}}t.module("material.components.tabs").directive("mdTabs",n)}(),function(){function n(n,t){function i(i,r,u,f){function s(){i.$watch("connected",function(n){n===!1?h():o()});i.$on("$destroy",o)}function h(){f.enableDisconnect&&t.disconnectScope(e)}function o(){f.enableDisconnect&&t.reconnectScope(e)}if(f){var e=f.enableDisconnect?i.compileScope.$new():i.compileScope;r.html(i.template);n(r.contents())(e);r.on("DOMSubtreeModified",function(){f.updatePagination();f.updateInkBarStyles()});return t.nextTick(s)}}return{restrict:"A",link:i,scope:{template:"=mdTabsTemplate",connected:"=?mdConnectedIf",compileScope:"=mdScope"},require:"^?mdTabs"}}t.module("material.components.tabs").directive("mdTabsTemplate",n);n.$inject=["$compile","$mdUtil"]}(),function(){t.module("material.core").constant("$MD_THEME_CSS","/*  Only used with Theme processes */html.md-THEME_NAME-theme, body.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-autocomplete.md-THEME_NAME-theme {  background: '{{background-A100}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-A100}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-600}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-600}}'; }.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  .md-button.md-THEME_NAME-theme.md-primary.md-raised, .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-600}}'; }    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-600}}'; }  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-600}}'; }.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  .md-button.md-THEME_NAME-theme.md-warn.md-raised, .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-600}}'; }    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-600}}'; }  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  .md-button.md-THEME_NAME-theme.md-accent.md-raised, .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-600}}'; }    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-600}}'; }  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }.md-button.md-THEME_NAME-theme[disabled], .md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled], .md-button.md-THEME_NAME-theme.md-accent[disabled], .md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}';  cursor: default; }  .md-button.md-THEME_NAME-theme[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }.md-button.md-THEME_NAME-theme.md-raised[disabled], .md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }a.md-THEME_NAME-theme:not(.md-button) {  color: '{{accent-color}}'; }  a.md-THEME_NAME-theme:not(.md-button):hover {    color: '{{accent-700}}'; }  a.md-THEME_NAME-theme:not(.md-button).md-primary {    color: '{{primary-color}}'; }    a.md-THEME_NAME-theme:not(.md-button).md-primary:hover {      color: '{{primary-700}}'; }  a.md-THEME_NAME-theme:not(.md-button).md-warn {    color: '{{warn-color}}'; }    a.md-THEME_NAME-theme:not(.md-button).md-warn:hover {      color: '{{warn-700}}'; }md-card.md-THEME_NAME-theme {  background-color: '{{background-hue-1}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused ._md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked ._md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked ._md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused ._md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] ._md-container {  color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn ._md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) ._md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] ._md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked ._md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked ._md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] ._md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{foreground-4}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }  md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input {    color: '{{foreground-1}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-webkit-input-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input:-moz-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-moz-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input:-ms-input-placeholder {      color: '{{foreground-3}}'; }    md-chips.md-THEME_NAME-theme .md-chips ._md-chip-input-container input::-webkit-input-placeholder {      color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme md-chip md-icon {    color: '{{background-700}}'; }  md-chips.md-THEME_NAME-theme md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }  md-chips.md-THEME_NAME-theme md-chip._md-chip-editing {    background: transparent;    color: '{{background-800}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-hue-1}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  background: '{{background-A100}}';  color: '{{background-A200-0.87}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-300}}';  color: '{{background-A200-0.87}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-300}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */.md-THEME_NAME-theme .md-datepicker-input {  color: '{{foreground-1}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-datepicker-calendar {  background: '{{background-A100}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-hue-1}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme,.layout-xs-row > md-divider.md-THEME_NAME-theme, .layout-gt-xs-row > md-divider.md-THEME_NAME-theme,.layout-sm-row > md-divider.md-THEME_NAME-theme, .layout-gt-sm-row > md-divider.md-THEME_NAME-theme,.layout-md-row > md-divider.md-THEME_NAME-theme, .layout-gt-md-row > md-divider.md-THEME_NAME-theme,.layout-lg-row > md-divider.md-THEME_NAME-theme, .layout-gt-lg-row > md-divider.md-THEME_NAME-theme,.layout-xl-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: '{{foreground-3}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder {    color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme ._md-placeholder {  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme label.md-required:after {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme .md-input-messages-animation, md-input-container.md-THEME_NAME-theme .md-input-message-animation {  color: '{{warn-A700}}'; }  md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter, md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter {    color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation, md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme ._md-proxy-focus.md-focused div._md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu._md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme._md-open:not(._md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(._md-keyboard-mode):not(._md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(._md-keyboard-mode):not(._md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{background-A200-0.54}}'; }md-menu-content.md-THEME_NAME-theme .md-menu._md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-A100}}';  color: '{{background-A200}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{background-A100-0.87}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{background-A100-0.87}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-A100}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-item {    color: '{{background-A200-0.87}}'; }    md-menu-content.md-THEME_NAME-theme md-menu-item md-icon {      color: '{{background-A200-0.54}}'; }    md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] {      color: '{{background-A200-0.25}}'; }      md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon {        color: '{{background-A200-0.25}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{background-A200-0.11}}'; }md-progress-circular.md-THEME_NAME-theme path {  stroke: '{{primary-color}}'; }md-progress-circular.md-THEME_NAME-theme.md-warn path {  stroke: '{{warn-color}}'; }md-progress-circular.md-THEME_NAME-theme.md-accent path {  stroke: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme ._md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme ._md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn ._md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn ._md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent ._md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent ._md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn ._md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn ._md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent ._md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent ._md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme ._md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme ._md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked ._md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme ._md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary ._md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked ._md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary ._md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn ._md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked ._md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked ._md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked ._md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn ._md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn ._md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] ._md-container ._md-off,  md-radio-button.md-THEME_NAME-theme[disabled] ._md-container ._md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] ._md-container ._md-on,  md-radio-button.md-THEME_NAME-theme[disabled] ._md-container ._md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked ._md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked ._md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary ._md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked ._md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn ._md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] ._md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme ._md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme ._md-select-value._md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty ._md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus ._md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus ._md-select-value._md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent ._md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn ._md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] ._md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] ._md-select-value._md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-content {  background: '{{background-A100}}'; }  md-select-menu.md-THEME_NAME-theme md-content md-optgroup {    color: '{{background-600-0.87}}'; }  md-select-menu.md-THEME_NAME-theme md-content md-option {    color: '{{background-900-0.87}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] ._md-text {      color: '{{background-400-0.87}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus, md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover {      background: '{{background-200}}'; }    md-select-menu.md-THEME_NAME-theme md-content md-option[selected] {      color: '{{primary-500}}'; }      md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus {        color: '{{primary-600}}'; }      md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent {        color: '{{accent-500}}'; }        md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus {          color: '{{accent-600}}'; }[md-checkbox-enabled].md-THEME_NAME-theme .md-ripple {  color: '{{primary-600}}'; }[md-checkbox-enabled].md-THEME_NAME-theme[selected] .md-ripple {  color: '{{background-600}}'; }[md-checkbox-enabled].md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }[md-checkbox-enabled].md-THEME_NAME-theme[selected] .md-ink-ripple {  color: '{{primary-color-0.87}}'; }[md-checkbox-enabled].md-THEME_NAME-theme ._md-icon {  border-color: '{{foreground-2}}'; }[md-checkbox-enabled].md-THEME_NAME-theme[selected] ._md-icon {  background-color: '{{primary-color-0.87}}'; }[md-checkbox-enabled].md-THEME_NAME-theme[selected].md-focused ._md-container:before {  background-color: '{{primary-color-0.26}}'; }[md-checkbox-enabled].md-THEME_NAME-theme[selected] ._md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }[md-checkbox-enabled].md-THEME_NAME-theme .md-indeterminate[disabled] ._md-container {  color: '{{foreground-3}}'; }[md-checkbox-enabled].md-THEME_NAME-theme md-option ._md-text {  color: '{{background-900-0.87}}'; }md-sidenav.md-THEME_NAME-theme, md-sidenav.md-THEME_NAME-theme md-content {  background-color: '{{background-hue-1}}'; }md-slider.md-THEME_NAME-theme ._md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme ._md-track-ticks {  color: '{{background-contrast}}'; }md-slider.md-THEME_NAME-theme ._md-focus-ring {  background-color: '{{accent-200-0.38}}'; }md-slider.md-THEME_NAME-theme ._md-disabled-thumb {  border-color: '{{background-color}}';  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme._md-min ._md-thumb:after {  background-color: '{{background-color}}';  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme._md-min ._md-focus-ring {  background-color: '{{foreground-3-0.38}}'; }md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-thumb:after {  background-color: '{{background-contrast}}';  border-color: transparent; }md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-sign {  background-color: '{{background-400}}'; }  md-slider.md-THEME_NAME-theme._md-min[md-discrete] ._md-sign:after {    border-top-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme._md-min[md-discrete][md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme ._md-track._md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme ._md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme ._md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-focus-ring {  background-color: '{{warn-200-0.38}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-track._md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn ._md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn ._md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-focus-ring {  background-color: '{{primary-200-0.38}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-track._md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary ._md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary[md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary ._md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] ._md-thumb:after {  border-color: transparent; }md-slider.md-THEME_NAME-theme[disabled]:not(._md-min) ._md-thumb:after, md-slider.md-THEME_NAME-theme[disabled][md-discrete] ._md-thumb:after {  background-color: '{{foreground-3}}';  border-color: transparent; }md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-sign {  background-color: '{{background-400}}'; }  md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-sign:after {    border-top-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] ._md-sign:after {  border-top-color: transparent;  border-left-color: '{{background-400}}'; }md-slider.md-THEME_NAME-theme[disabled][readonly] ._md-disabled-thumb {  border-color: transparent;  background-color: transparent; }md-slider-container[disabled] > *:first-child:not(md-slider),md-slider-container[disabled] > *:last-child:not(md-slider) {  color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-hue-2}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme ._md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme ._md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked ._md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked ._md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused ._md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary ._md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary ._md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused ._md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn ._md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn ._md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused ._md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] ._md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] ._md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary {        color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}';    fill: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon {    color: '{{primary-contrast-0.26}}';    fill: '{{primary-contrast-0.26}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple {      color: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon {      color: '{{accent-contrast}}';      fill: '{{accent-contrast}}'; }    md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon {      color: '{{accent-contrast-0.26}}';      fill: '{{accent-contrast-0.26}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme ._md-content {    background-color: '{{foreground-2}}'; }")}()})(window,window.angular);window.ngMaterial={version:{full:"1.1.0-rc2"}};
//# sourceMappingURL=angular-material.min.js.map

/*! 
 * angular-loading-bar v0.9.0
 * https://chieffancypants.github.io/angular-loading-bar
 * Copyright (c) 2016 Wes Cruver
 * License: MIT
 */
!function(){"use strict";angular.module("angular-loading-bar",["cfp.loadingBarInterceptor"]),angular.module("chieffancypants.loadingBar",["cfp.loadingBarInterceptor"]),angular.module("cfp.loadingBarInterceptor",["cfp.loadingBar"]).config(["$httpProvider",function(a){var b=["$q","$cacheFactory","$timeout","$rootScope","$log","cfpLoadingBar",function(b,c,d,e,f,g){function h(){d.cancel(j),g.complete(),l=0,k=0}function i(b){var d,e=c.get("$http"),f=a.defaults;!b.cache&&!f.cache||b.cache===!1||"GET"!==b.method&&"JSONP"!==b.method||(d=angular.isObject(b.cache)?b.cache:angular.isObject(f.cache)?f.cache:e);var g=void 0!==d?void 0!==d.get(b.url):!1;return void 0!==b.cached&&g!==b.cached?b.cached:(b.cached=g,g)}var j,k=0,l=0,m=g.latencyThreshold;return{request:function(a){return a.ignoreLoadingBar||i(a)||(e.$broadcast("cfpLoadingBar:loading",{url:a.url}),0===k&&(j=d(function(){g.start()},m)),k++,g.set(l/k)),a},response:function(a){return a&&a.config?(a.config.ignoreLoadingBar||i(a.config)||(l++,l>=k?(e.$broadcast("cfpLoadingBar:loaded",{url:a.config.url,result:a}),h()):g.set(l/k)),a):(f.error("Broken interceptor detected: Config object not supplied in response:\n https://github.com/chieffancypants/angular-loading-bar/pull/50"),a)},responseError:function(a){return a&&a.config?(a.config.ignoreLoadingBar||i(a.config)||(l++,l>=k?(e.$broadcast("cfpLoadingBar:loaded",{url:a.config.url,result:a}),h()):g.set(l/k)),b.reject(a)):(f.error("Broken interceptor detected: Config object not supplied in rejection:\n https://github.com/chieffancypants/angular-loading-bar/pull/50"),b.reject(a))}}}];a.interceptors.push(b)}]),angular.module("cfp.loadingBar",[]).provider("cfpLoadingBar",function(){this.autoIncrement=!0,this.includeSpinner=!0,this.includeBar=!0,this.latencyThreshold=100,this.startSize=.02,this.parentSelector="body",this.spinnerTemplate='<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>',this.loadingBarTemplate='<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>',this.$get=["$injector","$document","$timeout","$rootScope",function(a,b,c,d){function e(){if(k||(k=a.get("$animate")),c.cancel(m),!r){var e=b[0],g=e.querySelector?e.querySelector(n):b.find(n)[0];g||(g=e.getElementsByTagName("body")[0]);var h=angular.element(g),i=g.lastChild&&angular.element(g.lastChild);d.$broadcast("cfpLoadingBar:started"),r=!0,v&&k.enter(o,h,i),u&&k.enter(q,h,o),f(w)}}function f(a){if(r){var b=100*a+"%";p.css("width",b),s=a,t&&(c.cancel(l),l=c(function(){g()},250))}}function g(){if(!(h()>=1)){var a=0,b=h();a=b>=0&&.25>b?(3*Math.random()+3)/100:b>=.25&&.65>b?3*Math.random()/100:b>=.65&&.9>b?2*Math.random()/100:b>=.9&&.99>b?.005:0;var c=h()+a;f(c)}}function h(){return s}function i(){s=0,r=!1}function j(){k||(k=a.get("$animate")),f(1),c.cancel(m),m=c(function(){var a=k.leave(o,i);a&&a.then&&a.then(i),k.leave(q),d.$broadcast("cfpLoadingBar:completed")},500)}var k,l,m,n=this.parentSelector,o=angular.element(this.loadingBarTemplate),p=o.find("div").eq(0),q=angular.element(this.spinnerTemplate),r=!1,s=0,t=this.autoIncrement,u=this.includeSpinner,v=this.includeBar,w=this.startSize;return{start:e,set:f,status:h,inc:g,complete:j,autoIncrement:this.autoIncrement,includeSpinner:this.includeSpinner,latencyThreshold:this.latencyThreshold,parentSelector:this.parentSelector,startSize:this.startSize}}]})}();
/*
 AngularJS v1.5.5
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (n, e) {
    'use strict'; function B(a) { var c = []; w(c, e.noop).chars(a); return c.join("") } function h(a, c) { var b = {}, d = a.split(","), l; for (l = 0; l < d.length; l++) b[c ? e.lowercase(d[l]) : d[l]] = !0; return b } function C(a, c) {
        null === a || void 0 === a ? a = "" : "string" !== typeof a && (a = "" + a); g.innerHTML = a; var b = 5; do { if (0 === b) throw x("uinput"); b--; n.document.documentMode && t(g); a = g.innerHTML; g.innerHTML = a } while (a !== g.innerHTML); for (b = g.firstChild; b;) {
            switch (b.nodeType) {
                case 1: c.start(b.nodeName.toLowerCase(), D(b.attributes));
                    break; case 3: c.chars(b.textContent)
            } var d; if (!(d = b.firstChild) && (1 == b.nodeType && c.end(b.nodeName.toLowerCase()), d = b.nextSibling, !d)) for (; null == d;) { b = b.parentNode; if (b === g) break; d = b.nextSibling; 1 == b.nodeType && c.end(b.nodeName.toLowerCase()) } b = d
        } for (; b = g.firstChild;) g.removeChild(b)
    } function D(a) { for (var c = {}, b = 0, d = a.length; b < d; b++) { var l = a[b]; c[l.name] = l.value } return c } function y(a) {
        return a.replace(/&/g, "&amp;").replace(E, function (a) {
            var b = a.charCodeAt(0); a = a.charCodeAt(1); return "&#" + (1024 * (b - 55296) +
            (a - 56320) + 65536) + ";"
        }).replace(F, function (a) { return "&#" + a.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
    } function w(a, c) {
        var b = !1, d = e.bind(a, a.push); return {
            start: function (a, f) { a = e.lowercase(a); !b && G[a] && (b = a); b || !0 !== u[a] || (d("<"), d(a), e.forEach(f, function (b, f) { var g = e.lowercase(f), h = "img" === a && "src" === g || "background" === g; !0 !== H[g] || !0 === z[g] && !c(b, h) || (d(" "), d(f), d('="'), d(y(b)), d('"')) }), d(">")) }, end: function (a) {
                a = e.lowercase(a); b || !0 !== u[a] || !0 === A[a] || (d("</"), d(a), d(">")); a ==
                b && (b = !1)
            }, chars: function (a) { b || d(y(a)) }
        }
    } function t(a) { if (a.nodeType === n.Node.ELEMENT_NODE) for (var c = a.attributes, b = 0, d = c.length; b < d; b++) { var e = c[b], f = e.name.toLowerCase(); if ("xmlns:ns1" === f || 0 === f.indexOf("ns1:")) a.removeAttributeNode(e), b--, d-- } (c = a.firstChild) && t(c); (c = a.nextSibling) && t(c) } var x = e.$$minErr("$sanitize"), E = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, F = /([^\#-~ |!])/g, A = h("area,br,col,hr,img,wbr"), q = h("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), k = h("rp,rt"), v = e.extend({}, k, q), q = e.extend({},
    q, h("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")), k = e.extend({}, k, h("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), I = h("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"),
    G = h("script,style"), u = e.extend({}, A, q, k, v), z = h("background,cite,href,longdesc,src,xlink:href"), v = h("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), k = h("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan",
    !0), H = e.extend({}, z, k, v), g; (function (a) { if (a.document && a.document.implementation) a = a.document.implementation.createHTMLDocument("inert"); else throw x("noinert"); var c = (a.documentElement || a.getDocumentElement()).getElementsByTagName("body"); 1 === c.length ? g = c[0] : (c = a.createElement("html"), g = a.createElement("body"), c.appendChild(g), a.appendChild(c)) })(n); e.module("ngSanitize", []).provider("$sanitize", function () {
        var a = !1; this.$get = ["$$sanitizeUri", function (c) {
            a && e.extend(u, I); return function (a) {
                var d =
                []; C(a, w(d, function (a, b) { return !/^unsafe:/.test(c(a, b)) })); return d.join("")
            }
        }]; this.enableSvg = function (c) { return e.isDefined(c) ? (a = c, this) : a }
    }); e.module("ngSanitize").filter("linky", ["$sanitize", function (a) {
        var c = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, b = /^mailto:/i, d = e.$$minErr("linky"), g = e.isString; return function (f, h, m) {
            function k(a) { a && p.push(B(a)) } function q(a, b) {
                var c; p.push("<a "); e.isFunction(m) && (m = m(a)); if (e.isObject(m)) for (c in m) p.push(c +
                '="' + m[c] + '" '); else m = {}; !e.isDefined(h) || "target" in m || p.push('target="', h, '" '); p.push('href="', a.replace(/"/g, "&quot;"), '">'); k(b); p.push("</a>")
            } if (null == f || "" === f) return f; if (!g(f)) throw d("notstring", f); for (var r = f, p = [], s, n; f = r.match(c) ;) s = f[0], f[2] || f[4] || (s = (f[3] ? "http://" : "mailto:") + s), n = f.index, k(r.substr(0, n)), q(s, f[0].replace(b, "")), r = r.substring(n + f[0].length); k(r); return a(p.join(""))
        }
    }])
})(window, window.angular);
//# sourceMappingURL=angular-sanitize.min.js.map

/*
 AngularJS v1.5.5
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (S, q) {
    'use strict'; function Aa(a, b, c) { if (!a) throw Ma("areq", b || "?", c || "required"); return a } function Ba(a, b) { if (!a && !b) return ""; if (!a) return b; if (!b) return a; ba(a) && (a = a.join(" ")); ba(b) && (b = b.join(" ")); return a + " " + b } function Na(a) { var b = {}; a && (a.to || a.from) && (b.to = a.to, b.from = a.from); return b } function X(a, b, c) { var d = ""; a = ba(a) ? a : a && P(a) && a.length ? a.split(/\s+/) : []; r(a, function (a, f) { a && 0 < a.length && (d += 0 < f ? " " : "", d += c ? b + a : a + b) }); return d } function Oa(a) {
        if (a instanceof G) switch (a.length) {
            case 0: return [];
            case 1: if (1 === a[0].nodeType) return a; break; default: return G(ca(a))
        } if (1 === a.nodeType) return G(a)
    } function ca(a) { if (!a[0]) return a; for (var b = 0; b < a.length; b++) { var c = a[b]; if (1 == c.nodeType) return c } } function Pa(a, b, c) { r(b, function (b) { a.addClass(b, c) }) } function Qa(a, b, c) { r(b, function (b) { a.removeClass(b, c) }) } function U(a) { return function (b, c) { c.addClass && (Pa(a, b, c.addClass), c.addClass = null); c.removeClass && (Qa(a, b, c.removeClass), c.removeClass = null) } } function pa(a) {
        a = a || {}; if (!a.$$prepared) {
            var b = a.domOperation ||
            Q; a.domOperation = function () { a.$$domOperationFired = !0; b(); b = Q }; a.$$prepared = !0
        } return a
    } function ga(a, b) { Ca(a, b); Da(a, b) } function Ca(a, b) { b.from && (a.css(b.from), b.from = null) } function Da(a, b) { b.to && (a.css(b.to), b.to = null) } function V(a, b, c) {
        var d = b.options || {}; c = c.options || {}; var e = (d.addClass || "") + " " + (c.addClass || ""), f = (d.removeClass || "") + " " + (c.removeClass || ""); a = Ra(a.attr("class"), e, f); c.preparationClasses && (d.preparationClasses = Y(c.preparationClasses, d.preparationClasses), delete c.preparationClasses);
        e = d.domOperation !== Q ? d.domOperation : null; Ea(d, c); e && (d.domOperation = e); d.addClass = a.addClass ? a.addClass : null; d.removeClass = a.removeClass ? a.removeClass : null; b.addClass = d.addClass; b.removeClass = d.removeClass; return d
    } function Ra(a, b, c) {
        function d(a) { P(a) && (a = a.split(" ")); var b = {}; r(a, function (a) { a.length && (b[a] = !0) }); return b } var e = {}; a = d(a); b = d(b); r(b, function (a, b) { e[b] = 1 }); c = d(c); r(c, function (a, b) { e[b] = 1 === e[b] ? null : -1 }); var f = { addClass: "", removeClass: "" }; r(e, function (b, c) {
            var d, e; 1 === b ? (d = "addClass",
            e = !a[c]) : -1 === b && (d = "removeClass", e = a[c]); e && (f[d].length && (f[d] += " "), f[d] += c)
        }); return f
    } function D(a) { return a instanceof q.element ? a[0] : a } function Sa(a, b, c) { var d = ""; b && (d = X(b, "ng-", !0)); c.addClass && (d = Y(d, X(c.addClass, "-add"))); c.removeClass && (d = Y(d, X(c.removeClass, "-remove"))); d.length && (c.preparationClasses = d, a.addClass(d)) } function qa(a, b) { var c = b ? "-" + b + "s" : ""; la(a, [ma, c]); return [ma, c] } function ta(a, b) { var c = b ? "paused" : "", d = Z + "PlayState"; la(a, [d, c]); return [d, c] } function la(a, b) {
        a.style[b[0]] =
        b[1]
    } function Y(a, b) { return a ? b ? a + " " + b : a : b } function Fa(a, b, c) { var d = Object.create(null), e = a.getComputedStyle(b) || {}; r(c, function (a, b) { var c = e[a]; if (c) { var s = c.charAt(0); if ("-" === s || "+" === s || 0 <= s) c = Ta(c); 0 === c && (c = null); d[b] = c } }); return d } function Ta(a) { var b = 0; a = a.split(/\s*,\s*/); r(a, function (a) { "s" == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1)); a = parseFloat(a) || 0; b = b ? Math.max(a, b) : a }); return b } function ua(a) { return 0 === a || null != a } function Ga(a, b) {
        var c = T, d = a + "s"; b ? c += "Duration" : d += " linear all";
        return [c, d]
    } function Ha() { var a = Object.create(null); return { flush: function () { a = Object.create(null) }, count: function (b) { return (b = a[b]) ? b.total : 0 }, get: function (b) { return (b = a[b]) && b.value }, put: function (b, c) { a[b] ? a[b].total++ : a[b] = { total: 1, value: c } } } } function Ia(a, b, c) { r(c, function (c) { a[c] = da(a[c]) ? a[c] : b.style.getPropertyValue(c) }) } var Q = q.noop, Ja = q.copy, Ea = q.extend, G = q.element, r = q.forEach, ba = q.isArray, P = q.isString, va = q.isObject, C = q.isUndefined, da = q.isDefined, Ka = q.isFunction, wa = q.isElement, T, xa, Z, ya; C(S.ontransitionend) &&
    da(S.onwebkittransitionend) ? (T = "WebkitTransition", xa = "webkitTransitionEnd transitionend") : (T = "transition", xa = "transitionend"); C(S.onanimationend) && da(S.onwebkitanimationend) ? (Z = "WebkitAnimation", ya = "webkitAnimationEnd animationend") : (Z = "animation", ya = "animationend"); var ra = Z + "Delay", za = Z + "Duration", ma = T + "Delay", La = T + "Duration", Ma = q.$$minErr("ng"), Ua = { transitionDuration: La, transitionDelay: ma, transitionProperty: T + "Property", animationDuration: za, animationDelay: ra, animationIterationCount: Z + "IterationCount" },
    Va = { transitionDuration: La, transitionDelay: ma, animationDuration: za, animationDelay: ra }; q.module("ngAnimate", []).directive("ngAnimateSwap", ["$animate", "$rootScope", function (a, b) { return { restrict: "A", transclude: "element", terminal: !0, priority: 600, link: function (b, d, e, f, z) { var B, s; b.$watchCollection(e.ngAnimateSwap || e["for"], function (e) { B && a.leave(B); s && (s.$destroy(), s = null); if (e || 0 === e) s = b.$new(), z(s, function (b) { B = b; a.enter(b, null, d) }) }) } } }]).directive("ngAnimateChildren", ["$interpolate", function (a) {
        return {
            link: function (b,
            c, d) { function e(a) { c.data("$$ngAnimateChildren", "on" === a || "true" === a) } var f = d.ngAnimateChildren; q.isString(f) && 0 === f.length ? c.data("$$ngAnimateChildren", !0) : (e(a(f)(b)), d.$observe("ngAnimateChildren", e)) }
        }
    }]).factory("$$rAFScheduler", ["$$rAF", function (a) { function b(a) { d = d.concat(a); c() } function c() { if (d.length) { for (var b = d.shift(), z = 0; z < b.length; z++) b[z](); e || a(function () { e || c() }) } } var d, e; d = b.queue = []; b.waitUntilQuiet = function (b) { e && e(); e = a(function () { e = null; b(); c() }) }; return b }]).provider("$$animateQueue",
    ["$animateProvider", function (a) {
        function b(a) { if (!a) return null; a = a.split(" "); var b = Object.create(null); r(a, function (a) { b[a] = !0 }); return b } function c(a, c) { if (a && c) { var d = b(c); return a.split(" ").some(function (a) { return d[a] }) } } function d(a, b, c, d) { return f[a].some(function (a) { return a(b, c, d) }) } function e(a, b) { var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass || "").length; return b ? c && d : c || d } var f = this.rules = { skip: [], cancel: [], join: [] }; f.join.push(function (a, b, c) { return !b.structural && e(b) }); f.skip.push(function (a,
        b, c) { return !b.structural && !e(b) }); f.skip.push(function (a, b, c) { return "leave" == c.event && b.structural }); f.skip.push(function (a, b, c) { return c.structural && 2 === c.state && !b.structural }); f.cancel.push(function (a, b, c) { return c.structural && b.structural }); f.cancel.push(function (a, b, c) { return 2 === c.state && b.structural }); f.cancel.push(function (a, b, d) { if (d.structural) return !1; a = b.addClass; b = b.removeClass; var e = d.addClass; d = d.removeClass; return C(a) && C(b) || C(e) && C(d) ? !1 : c(a, d) || c(b, e) }); this.$get = ["$$rAF", "$rootScope",
        "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function (b, c, f, v, I, Wa, u, sa, w, x) {
            function R() { var a = !1; return function (b) { a ? b() : c.$$postDigest(function () { a = !0; b() }) } } function J(a, b, c) { var g = D(b), d = D(a), k = []; (a = h[c]) && r(a, function (a) { ia.call(a.node, g) ? k.push(a.callback) : "leave" === c && ia.call(a.node, d) && k.push(a.callback) }); return k } function k(a, b, c) { var g = ca(b); return a.filter(function (a) { return !(a.node === g && (!c || a.callback === c)) }) }
            function p(a, k, h) {
                function l(c, g, d, h) { f(function () { var c = J(oa, a, g); c.length ? b(function () { r(c, function (b) { b(a, d, h) }); "close" !== d || a[0].parentNode || N.off(a) }) : "close" !== d || a[0].parentNode || N.off(a) }); c.progress(g, d, h) } function A(b) { var c = a, g = m; g.preparationClasses && (c.removeClass(g.preparationClasses), g.preparationClasses = null); g.activeClasses && (c.removeClass(g.activeClasses), g.activeClasses = null); F(a, m); ga(a, m); m.domOperation(); p.complete(!b) } var m = Ja(h), x, oa; if (a = Oa(a)) x = D(a), oa = a.parent(); var m =
                pa(m), p = new u, f = R(); ba(m.addClass) && (m.addClass = m.addClass.join(" ")); m.addClass && !P(m.addClass) && (m.addClass = null); ba(m.removeClass) && (m.removeClass = m.removeClass.join(" ")); m.removeClass && !P(m.removeClass) && (m.removeClass = null); m.from && !va(m.from) && (m.from = null); m.to && !va(m.to) && (m.to = null); if (!x) return A(), p; h = [x.className, m.addClass, m.removeClass].join(" "); if (!Xa(h)) return A(), p; var s = 0 <= ["enter", "move", "leave"].indexOf(k), t = v[0].hidden, w = !g || t || H.get(x); h = !w && y.get(x) || {}; var I = !!h.state; w ||
                I && 1 == h.state || (w = !K(a, oa, k)); if (w) return t && l(p, k, "start"), A(), t && l(p, k, "close"), p; s && L(a); t = { structural: s, element: a, event: k, addClass: m.addClass, removeClass: m.removeClass, close: A, options: m, runner: p }; if (I) { if (d("skip", a, t, h)) { if (2 === h.state) return A(), p; V(a, h, t); return h.runner } if (d("cancel", a, t, h)) if (2 === h.state) h.runner.end(); else if (h.structural) h.close(); else return V(a, h, t), h.runner; else if (d("join", a, t, h)) if (2 === h.state) V(a, t, {}); else return Sa(a, s ? k : null, m), k = t.event = h.event, m = V(a, h, t), h.runner } else V(a,
                t, {}); (I = t.structural) || (I = "animate" === t.event && 0 < Object.keys(t.options.to || {}).length || e(t)); if (!I) return A(), O(a), p; var ia = (h.counter || 0) + 1; t.counter = ia; M(a, 1, t); c.$$postDigest(function () {
                    var b = y.get(x), c = !b, b = b || {}, g = 0 < (a.parent() || []).length && ("animate" === b.event || b.structural || e(b)); if (c || b.counter !== ia || !g) { c && (F(a, m), ga(a, m)); if (c || s && b.event !== k) m.domOperation(), p.end(); g || O(a) } else k = !b.structural && e(b, !0) ? "setClass" : b.event, M(a, 2), b = Wa(a, k, b.options), p.setHost(b), l(p, k, "start", {}), b.done(function (b) {
                        A(!b);
                        (b = y.get(x)) && b.counter === ia && O(D(a)); l(p, k, "close", {})
                    })
                }); return p
            } function L(a) { a = D(a).querySelectorAll("[data-ng-animate]"); r(a, function (a) { var b = parseInt(a.getAttribute("data-ng-animate")), c = y.get(a); if (c) switch (b) { case 2: c.runner.end(); case 1: y.remove(a) } }) } function O(a) { a = D(a); a.removeAttribute("data-ng-animate"); y.remove(a) } function l(a, b) { return D(a) === D(b) } function K(a, b, c) {
                c = G(v[0].body); var g = l(a, c) || "HTML" === a[0].nodeName, d = l(a, f), h = !1, k, e = H.get(D(a)); (a = G.data(a[0], "$ngAnimatePin")) &&
                (b = a); for (b = D(b) ; b;) { d || (d = l(b, f)); if (1 !== b.nodeType) break; a = y.get(b) || {}; if (!h) { var p = H.get(b); if (!0 === p && !1 !== e) { e = !0; break } else !1 === p && (e = !1); h = a.structural } if (C(k) || !0 === k) a = G.data(b, "$$ngAnimateChildren"), da(a) && (k = a); if (h && !1 === k) break; g || (g = l(b, c)); if (g && d) break; if (!d && (a = G.data(b, "$ngAnimatePin"))) { b = D(a); continue } b = b.parentNode } return (!h || k) && !0 !== e && d && g
            } function M(a, b, c) { c = c || {}; c.state = b; a = D(a); a.setAttribute("data-ng-animate", b); c = (b = y.get(a)) ? Ea(b, c) : c; y.put(a, c) } var y = new I, H = new I,
            g = null, oa = c.$watch(function () { return 0 === sa.totalPendingRequests }, function (a) { a && (oa(), c.$$postDigest(function () { c.$$postDigest(function () { null === g && (g = !0) }) })) }), h = {}, A = a.classNameFilter(), Xa = A ? function (a) { return A.test(a) } : function () { return !0 }, F = U(w), ia = S.Node.prototype.contains || function (a) { return this === a || !!(this.compareDocumentPosition(a) & 16) }, N = {
                on: function (a, b, c) { var g = ca(b); h[a] = h[a] || []; h[a].push({ node: g, callback: c }); G(b).on("$destroy", function () { y.get(g) || N.off(a, b, c) }) }, off: function (a,
                b, c) { if (1 !== arguments.length || q.isString(arguments[0])) { var g = h[a]; g && (h[a] = 1 === arguments.length ? null : k(g, b, c)) } else for (g in b = arguments[0], h) h[g] = k(h[g], b) }, pin: function (a, b) { Aa(wa(a), "element", "not an element"); Aa(wa(b), "parentElement", "not an element"); a.data("$ngAnimatePin", b) }, push: function (a, b, c, g) { c = c || {}; c.domOperation = g; return p(a, b, c) }, enabled: function (a, b) { var c = arguments.length; if (0 === c) b = !!g; else if (wa(a)) { var d = D(a), h = H.get(d); 1 === c ? b = !h : H.put(d, !b) } else b = g = !!a; return b }
            }; return N
        }]
    }]).provider("$$animation",
    ["$animateProvider", function (a) {
        function b(a) { return a.data("$$animationRunner") } var c = this.drivers = []; this.$get = ["$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function (a, e, f, z, B, s) {
            function v(a) {
                function b(a) { if (a.processed) return a; a.processed = !0; var d = a.domNode, L = d.parentNode; e.put(d, a); for (var f; L;) { if (f = e.get(L)) { f.processed || (f = b(f)); break } L = L.parentNode } (f || c).children.push(a); return a } var c = { children: [] }, d, e = new B; for (d = 0; d < a.length; d++) {
                    var f = a[d]; e.put(f.domNode,
                    a[d] = { domNode: f.domNode, fn: f.fn, children: [] })
                } for (d = 0; d < a.length; d++) b(a[d]); return function (a) { var b = [], c = [], d; for (d = 0; d < a.children.length; d++) c.push(a.children[d]); a = c.length; var e = 0, f = []; for (d = 0; d < c.length; d++) { var x = c[d]; 0 >= a && (a = e, e = 0, b.push(f), f = []); f.push(x.fn); x.children.forEach(function (a) { e++; c.push(a) }); a-- } f.length && b.push(f); return b }(c)
            } var I = [], q = U(a); return function (u, B, w) {
                function x(a) {
                    a = a.hasAttribute("ng-animate-ref") ? [a] : a.querySelectorAll("[ng-animate-ref]"); var b = []; r(a, function (a) {
                        var c =
                        a.getAttribute("ng-animate-ref"); c && c.length && b.push(a)
                    }); return b
                } function R(a) {
                    var b = [], c = {}; r(a, function (a, g) { var d = D(a.element), e = 0 <= ["enter", "move"].indexOf(a.event), d = a.structural ? x(d) : []; if (d.length) { var k = e ? "to" : "from"; r(d, function (a) { var b = a.getAttribute("ng-animate-ref"); c[b] = c[b] || {}; c[b][k] = { animationID: g, element: G(a) } }) } else b.push(a) }); var d = {}, e = {}; r(c, function (c, h) {
                        var k = c.from, f = c.to; if (k && f) {
                            var p = a[k.animationID], y = a[f.animationID], l = k.animationID.toString(); if (!e[l]) {
                                var x = e[l] =
                                { structural: !0, beforeStart: function () { p.beforeStart(); y.beforeStart() }, close: function () { p.close(); y.close() }, classes: J(p.classes, y.classes), from: p, to: y, anchors: [] }; x.classes.length ? b.push(x) : (b.push(p), b.push(y))
                            } e[l].anchors.push({ out: k.element, "in": f.element })
                        } else k = k ? k.animationID : f.animationID, f = k.toString(), d[f] || (d[f] = !0, b.push(a[k]))
                    }); return b
                } function J(a, b) {
                    a = a.split(" "); b = b.split(" "); for (var c = [], d = 0; d < a.length; d++) {
                        var k = a[d]; if ("ng-" !== k.substring(0, 3)) for (var e = 0; e < b.length; e++) if (k ===
                        b[e]) { c.push(k); break }
                    } return c.join(" ")
                } function k(a) { for (var b = c.length - 1; 0 <= b; b--) { var d = c[b]; if (f.has(d) && (d = f.get(d)(a))) return d } } function p(a, c) { a.from && a.to ? (b(a.from.element).setHost(c), b(a.to.element).setHost(c)) : b(a.element).setHost(c) } function L() { var a = b(u); !a || "leave" === B && w.$$domOperationFired || a.end() } function O(b) { u.off("$destroy", L); u.removeData("$$animationRunner"); q(u, w); ga(u, w); w.domOperation(); y && a.removeClass(u, y); u.removeClass("ng-animate"); K.complete(!b) } w = pa(w); var l = 0 <=
                ["enter", "move", "leave"].indexOf(B), K = new z({ end: function () { O() }, cancel: function () { O(!0) } }); if (!c.length) return O(), K; u.data("$$animationRunner", K); var M = Ba(u.attr("class"), Ba(w.addClass, w.removeClass)), y = w.tempClasses; y && (M += " " + y, w.tempClasses = null); var H; l && (H = "ng-" + B + "-prepare", a.addClass(u, H)); I.push({ element: u, classes: M, event: B, structural: l, options: w, beforeStart: function () { u.addClass("ng-animate"); y && a.addClass(u, y); H && (a.removeClass(u, H), H = null) }, close: O }); u.on("$destroy", L); if (1 < I.length) return K;
                e.$$postDigest(function () { var a = []; r(I, function (c) { b(c.element) ? a.push(c) : c.close() }); I.length = 0; var c = R(a), d = []; r(c, function (a) { d.push({ domNode: D(a.from ? a.from.element : a.element), fn: function () { a.beforeStart(); var c, d = a.close; if (b(a.anchors ? a.from.element || a.to.element : a.element)) { var g = k(a); g && (c = g.start) } c ? (c = c(), c.done(function (a) { d(!a) }), p(a, c)) : d() } }) }); s(v(d)) }); return K
            }
        }]
    }]).provider("$animateCss", ["$animateProvider", function (a) {
        var b = Ha(), c = Ha(); this.$get = ["$window", "$$jqLite", "$$AnimateRunner",
        "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function (a, e, f, z, B, s, v, I) {
            function q(a, b) { var c = a.parentNode; return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++R)) + "-" + a.getAttribute("class") + "-" + b } function u(k, f, x, s) { var l; 0 < b.count(x) && (l = c.get(x), l || (f = X(f, "-stagger"), e.addClass(k, f), l = Fa(a, k, s), l.animationDuration = Math.max(l.animationDuration, 0), l.transitionDuration = Math.max(l.transitionDuration, 0), e.removeClass(k, f), c.put(x, l))); return l || {} } function sa(a) {
                J.push(a);
                v.waitUntilQuiet(function () { b.flush(); c.flush(); for (var a = B(), d = 0; d < J.length; d++) J[d](a); J.length = 0 })
            } function w(c, e, f) { e = b.get(f); e || (e = Fa(a, c, Ua), "infinite" === e.animationIterationCount && (e.animationIterationCount = 1)); b.put(f, e); c = e; f = c.animationDelay; e = c.transitionDelay; c.maxDelay = f && e ? Math.max(f, e) : f || e; c.maxDuration = Math.max(c.animationDuration * c.animationIterationCount, c.transitionDuration); return c } var x = U(e), R = 0, J = []; return function (a, c) {
                function d() { l() } function v() { l(!0) } function l(b) {
                    if (!(R ||
                    G && N)) { R = !0; N = !1; g.$$skipPreparationClasses || e.removeClass(a, fa); e.removeClass(a, da); ta(h, !1); qa(h, !1); r(A, function (a) { h.style[a[0]] = "" }); x(a, g); ga(a, g); Object.keys(J).length && r(J, function (a, b) { a ? h.style.setProperty(b, a) : h.style.removeProperty(b) }); if (g.onDone) g.onDone(); ea && ea.length && a.off(ea.join(" "), y); var c = a.data("$$animateCss"); c && (z.cancel(c[0].timer), a.removeData("$$animateCss")); C && C.complete(!b) }
                } function K(a) { n.blockTransition && qa(h, a); n.blockKeyframeAnimation && ta(h, !!a) } function M() {
                    C =
                    new f({ end: d, cancel: v }); sa(Q); l(); return { $$willAnimate: !1, start: function () { return C }, end: d }
                } function y(a) { a.stopPropagation(); var b = a.originalEvent || a; a = b.$manualTimeStamp || Date.now(); b = parseFloat(b.elapsedTime.toFixed(3)); Math.max(a - V, 0) >= S && b >= m && (G = !0, l()) } function H() {
                    function b() {
                        if (!R) {
                            K(!1); r(A, function (a) { h.style[a[0]] = a[1] }); x(a, g); e.addClass(a, da); if (n.recalculateTimingStyles) {
                                na = h.className + " " + fa; ja = q(h, na); E = w(h, na, ja); $ = E.maxDelay; ha = Math.max($, 0); m = E.maxDuration; if (0 === m) { l(); return } n.hasTransitions =
                                0 < E.transitionDuration; n.hasAnimations = 0 < E.animationDuration
                            } n.applyAnimationDelay && ($ = "boolean" !== typeof g.delay && ua(g.delay) ? parseFloat(g.delay) : $, ha = Math.max($, 0), E.animationDelay = $, aa = [ra, $ + "s"], A.push(aa), h.style[aa[0]] = aa[1]); S = 1E3 * ha; U = 1E3 * m; if (g.easing) { var d, f = g.easing; n.hasTransitions && (d = T + "TimingFunction", A.push([d, f]), h.style[d] = f); n.hasAnimations && (d = Z + "TimingFunction", A.push([d, f]), h.style[d] = f) } E.transitionDuration && ea.push(xa); E.animationDuration && ea.push(ya); V = Date.now(); var H = S +
                            1.5 * U; d = V + H; var f = a.data("$$animateCss") || [], s = !0; if (f.length) { var p = f[0]; (s = d > p.expectedEndTime) ? z.cancel(p.timer) : f.push(l) } s && (H = z(c, H, !1), f[0] = { timer: H, expectedEndTime: d }, f.push(l), a.data("$$animateCss", f)); if (ea.length) a.on(ea.join(" "), y); g.to && (g.cleanupStyles && Ia(J, h, Object.keys(g.to)), Da(a, g))
                        }
                    } function c() { var b = a.data("$$animateCss"); if (b) { for (var d = 1; d < b.length; d++) b[d](); a.removeData("$$animateCss") } } if (!R) if (h.parentNode) {
                        var d = function (a) {
                            if (G) N && a && (N = !1, l()); else if (N = !a, E.animationDuration) if (a =
                            ta(h, N), N) A.push(a); else { var b = A, c = b.indexOf(a); 0 <= a && b.splice(c, 1) }
                        }, f = 0 < ca && (E.transitionDuration && 0 === W.transitionDuration || E.animationDuration && 0 === W.animationDuration) && Math.max(W.animationDelay, W.transitionDelay); f ? z(b, Math.floor(f * ca * 1E3), !1) : b(); P.resume = function () { d(!0) }; P.pause = function () { d(!1) }
                    } else l()
                } var g = c || {}; g.$$prepared || (g = pa(Ja(g))); var J = {}, h = D(a); if (!h || !h.parentNode || !I.enabled()) return M(); var A = [], B = a.attr("class"), F = Na(g), R, N, G, C, P, ha, S, m, U, V, ea = []; if (0 === g.duration || !s.animations &&
                !s.transitions) return M(); var ka = g.event && ba(g.event) ? g.event.join(" ") : g.event, Y = "", t = ""; ka && g.structural ? Y = X(ka, "ng-", !0) : ka && (Y = ka); g.addClass && (t += X(g.addClass, "-add")); g.removeClass && (t.length && (t += " "), t += X(g.removeClass, "-remove")); g.applyClassesEarly && t.length && x(a, g); var fa = [Y, t].join(" ").trim(), na = B + " " + fa, da = X(fa, "-active"), B = F.to && 0 < Object.keys(F.to).length; if (!(0 < (g.keyframeStyle || "").length || B || fa)) return M(); var ja, W; 0 < g.stagger ? (F = parseFloat(g.stagger), W = {
                    transitionDelay: F, animationDelay: F,
                    transitionDuration: 0, animationDuration: 0
                }) : (ja = q(h, na), W = u(h, fa, ja, Va)); g.$$skipPreparationClasses || e.addClass(a, fa); g.transitionStyle && (F = [T, g.transitionStyle], la(h, F), A.push(F)); 0 <= g.duration && (F = 0 < h.style[T].length, F = Ga(g.duration, F), la(h, F), A.push(F)); g.keyframeStyle && (F = [Z, g.keyframeStyle], la(h, F), A.push(F)); var ca = W ? 0 <= g.staggerIndex ? g.staggerIndex : b.count(ja) : 0; (ka = 0 === ca) && !g.skipBlocking && qa(h, 9999); var E = w(h, na, ja), $ = E.maxDelay; ha = Math.max($, 0); m = E.maxDuration; var n = {}; n.hasTransitions =
                0 < E.transitionDuration; n.hasAnimations = 0 < E.animationDuration; n.hasTransitionAll = n.hasTransitions && "all" == E.transitionProperty; n.applyTransitionDuration = B && (n.hasTransitions && !n.hasTransitionAll || n.hasAnimations && !n.hasTransitions); n.applyAnimationDuration = g.duration && n.hasAnimations; n.applyTransitionDelay = ua(g.delay) && (n.applyTransitionDuration || n.hasTransitions); n.applyAnimationDelay = ua(g.delay) && n.hasAnimations; n.recalculateTimingStyles = 0 < t.length; if (n.applyTransitionDuration || n.applyAnimationDuration) m =
                g.duration ? parseFloat(g.duration) : m, n.applyTransitionDuration && (n.hasTransitions = !0, E.transitionDuration = m, F = 0 < h.style[T + "Property"].length, A.push(Ga(m, F))), n.applyAnimationDuration && (n.hasAnimations = !0, E.animationDuration = m, A.push([za, m + "s"])); if (0 === m && !n.recalculateTimingStyles) return M(); if (null != g.delay) { var aa; "boolean" !== typeof g.delay && (aa = parseFloat(g.delay), ha = Math.max(aa, 0)); n.applyTransitionDelay && A.push([ma, aa + "s"]); n.applyAnimationDelay && A.push([ra, aa + "s"]) } null == g.duration && 0 < E.transitionDuration &&
                (n.recalculateTimingStyles = n.recalculateTimingStyles || ka); S = 1E3 * ha; U = 1E3 * m; g.skipBlocking || (n.blockTransition = 0 < E.transitionDuration, n.blockKeyframeAnimation = 0 < E.animationDuration && 0 < W.animationDelay && 0 === W.animationDuration); g.from && (g.cleanupStyles && Ia(J, h, Object.keys(g.from)), Ca(a, g)); n.blockTransition || n.blockKeyframeAnimation ? K(m) : g.skipBlocking || qa(h, !1); return { $$willAnimate: !0, end: d, start: function () { if (!R) return P = { end: d, cancel: v, resume: null, pause: null }, C = new f(P), sa(H), C } }
            }
        }]
    }]).provider("$$animateCssDriver",
    ["$$animationProvider", function (a) {
        a.drivers.push("$$animateCssDriver"); this.$get = ["$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function (a, c, d, e, f, z, B) {
            function s(a) { return a.replace(/\bng-\S+\b/g, "") } function v(a, b) { P(a) && (a = a.split(" ")); P(b) && (b = b.split(" ")); return a.filter(function (a) { return -1 === b.indexOf(a) }).join(" ") } function I(c, e, f) {
                function k(a) {
                    var b = {}, c = D(a).getBoundingClientRect(); r(["width", "height", "top", "left"], function (a) {
                        var d = c[a];
                        switch (a) { case "top": d += C.scrollTop; break; case "left": d += C.scrollLeft } b[a] = Math.floor(d) + "px"
                    }); return b
                } function p() { var c = s(f.attr("class") || ""), d = v(c, l), c = v(l, c), d = a(z, { to: k(f), addClass: "ng-anchor-in " + d, removeClass: "ng-anchor-out " + c, delay: !0 }); return d.$$willAnimate ? d : null } function B() { z.remove(); e.removeClass("ng-animate-shim"); f.removeClass("ng-animate-shim") } var z = G(D(e).cloneNode(!0)), l = s(z.attr("class") || ""); e.addClass("ng-animate-shim"); f.addClass("ng-animate-shim"); z.addClass("ng-anchor");
                w.append(z); var K; c = function () { var c = a(z, { addClass: "ng-anchor-out", delay: !0, from: k(e) }); return c.$$willAnimate ? c : null }(); if (!c && (K = p(), !K)) return B(); var M = c || K; return { start: function () { function a() { c && c.end() } var b, c = M.start(); c.done(function () { c = null; if (!K && (K = p())) return c = K.start(), c.done(function () { c = null; B(); b.complete() }), c; B(); b.complete() }); return b = new d({ end: a, cancel: a }) } }
            } function q(a, b, c, e) {
                var f = u(a, Q), s = u(b, Q), z = []; r(e, function (a) { (a = I(c, a.out, a["in"])) && z.push(a) }); if (f || s || 0 !== z.length) return {
                    start: function () {
                        function a() {
                            r(b,
                            function (a) { a.end() })
                        } var b = []; f && b.push(f.start()); s && b.push(s.start()); r(z, function (a) { b.push(a.start()) }); var c = new d({ end: a, cancel: a }); d.all(b, function (a) { c.complete(a) }); return c
                    }
                }
            } function u(c) { var d = c.element, e = c.options || {}; c.structural && (e.event = c.event, e.structural = !0, e.applyClassesEarly = !0, "leave" === c.event && (e.onDone = e.domOperation)); e.preparationClasses && (e.event = Y(e.event, e.preparationClasses)); c = a(d, e); return c.$$willAnimate ? c : null } if (!f.animations && !f.transitions) return Q; var C = B[0].body;
            c = D(e); var w = G(c.parentNode && 11 === c.parentNode.nodeType || C.contains(c) ? c : C); U(z); return function (a) { return a.from && a.to ? q(a.from, a.to, a.classes, a.anchors) : u(a) }
        }]
    }]).provider("$$animateJs", ["$animateProvider", function (a) {
        this.$get = ["$injector", "$$AnimateRunner", "$$jqLite", function (b, c, d) {
            function e(c) { c = ba(c) ? c : c.split(" "); for (var d = [], e = {}, f = 0; f < c.length; f++) { var r = c[f], q = a.$$registeredAnimations[r]; q && !e[r] && (d.push(b.get(q)), e[r] = !0) } return d } var f = U(d); return function (a, b, d, v) {
                function q() {
                    v.domOperation();
                    f(a, v)
                } function D(a, b, d, e, g) { switch (d) { case "animate": b = [b, e.from, e.to, g]; break; case "setClass": b = [b, x, G, g]; break; case "addClass": b = [b, x, g]; break; case "removeClass": b = [b, G, g]; break; default: b = [b, g] } b.push(e); if (a = a.apply(a, b)) if (Ka(a.start) && (a = a.start()), a instanceof c) a.done(g); else if (Ka(a)) return a; return Q } function u(a, b, d, e, g) {
                    var f = []; r(e, function (e) {
                        var k = e[g]; k && f.push(function () {
                            var e, g, f = !1, h = function (a) { f || (f = !0, (g || Q)(a), e.complete(!a)) }; e = new c({ end: function () { h() }, cancel: function () { h(!0) } });
                            g = D(k, a, b, d, function (a) { h(!1 === a) }); return e
                        })
                    }); return f
                } function C(a, b, d, e, g) {
                    var f = u(a, b, d, e, g); if (0 === f.length) { var h, k; "beforeSetClass" === g ? (h = u(a, "removeClass", d, e, "beforeRemoveClass"), k = u(a, "addClass", d, e, "beforeAddClass")) : "setClass" === g && (h = u(a, "removeClass", d, e, "removeClass"), k = u(a, "addClass", d, e, "addClass")); h && (f = f.concat(h)); k && (f = f.concat(k)) } if (0 !== f.length) return function (a) {
                        var b = []; f.length && r(f, function (a) { b.push(a()) }); b.length ? c.all(b, a) : a(); return function (a) {
                            r(b, function (b) {
                                a ?
                                b.cancel() : b.end()
                            })
                        }
                    }
                } var w = !1; 3 === arguments.length && va(d) && (v = d, d = null); v = pa(v); d || (d = a.attr("class") || "", v.addClass && (d += " " + v.addClass), v.removeClass && (d += " " + v.removeClass)); var x = v.addClass, G = v.removeClass, J = e(d), k, p; if (J.length) { var L, O; "leave" == b ? (O = "leave", L = "afterLeave") : (O = "before" + b.charAt(0).toUpperCase() + b.substr(1), L = b); "enter" !== b && "move" !== b && (k = C(a, b, v, J, O)); p = C(a, b, v, J, L) } if (k || p) {
                    var l; return {
                        $$willAnimate: !0, end: function () { l ? l.end() : (w = !0, q(), ga(a, v), l = new c, l.complete(!0)); return l },
                        start: function () { function b(c) { w = !0; q(); ga(a, v); l.complete(c) } if (l) return l; l = new c; var d, e = []; k && e.push(function (a) { d = k(a) }); e.length ? e.push(function (a) { q(); a(!0) }) : q(); p && e.push(function (a) { d = p(a) }); l.setHost({ end: function () { w || ((d || Q)(void 0), b(void 0)) }, cancel: function () { w || ((d || Q)(!0), b(!0)) } }); c.chain(e, b); return l }
                    }
                }
            }
        }]
    }]).provider("$$animateJsDriver", ["$$animationProvider", function (a) {
        a.drivers.push("$$animateJsDriver"); this.$get = ["$$animateJs", "$$AnimateRunner", function (a, c) {
            function d(c) {
                return a(c.element,
                c.event, c.classes, c.options)
            } return function (a) { if (a.from && a.to) { var b = d(a.from), q = d(a.to); if (b || q) return { start: function () { function a() { return function () { r(d, function (a) { a.end() }) } } var d = []; b && d.push(b.start()); q && d.push(q.start()); c.all(d, function (a) { e.complete(a) }); var e = new c({ end: a(), cancel: a() }); return e } } } else return d(a) }
        }]
    }])
})(window, window.angular);
//# sourceMappingURL=angular-animate.min.js.map

/*
 AngularJS v1.5.5
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (t, p) {
    'use strict'; var b = "BUTTON A INPUT TEXTAREA SELECT DETAILS SUMMARY".split(" "), l = function (a, c) { if (-1 !== c.indexOf(a[0].nodeName)) return !0 }; p.module("ngAria", ["ng"]).provider("$aria", function () {
        function a(a, b, m, h) { return function (d, f, e) { var q = e.$normalize(b); !c[q] || l(f, m) || e[q] || d.$watch(e[a], function (a) { a = h ? !a : !!a; f.attr(b, a) }) } } var c = { ariaHidden: !0, ariaChecked: !0, ariaReadonly: !0, ariaDisabled: !0, ariaRequired: !0, ariaInvalid: !0, ariaValue: !0, tabindex: !0, bindKeypress: !0, bindRoleForClick: !0 };
        this.config = function (a) { c = p.extend(c, a) }; this.$get = function () { return { config: function (a) { return c[a] }, $$watchExpr: a } }
    }).directive("ngShow", ["$aria", function (a) { return a.$$watchExpr("ngShow", "aria-hidden", [], !0) }]).directive("ngHide", ["$aria", function (a) { return a.$$watchExpr("ngHide", "aria-hidden", [], !1) }]).directive("ngValue", ["$aria", function (a) { return a.$$watchExpr("ngValue", "aria-checked", b, !1) }]).directive("ngChecked", ["$aria", function (a) { return a.$$watchExpr("ngChecked", "aria-checked", b, !1) }]).directive("ngReadonly",
    ["$aria", function (a) { return a.$$watchExpr("ngReadonly", "aria-readonly", b, !1) }]).directive("ngRequired", ["$aria", function (a) { return a.$$watchExpr("ngRequired", "aria-required", b, !1) }]).directive("ngModel", ["$aria", function (a) {
        function c(c, h, d, f) { return a.config(h) && !d.attr(c) && (f || !l(d, b)) } function g(a, c) { return !c.attr("role") && c.attr("type") === a && "INPUT" !== c[0].nodeName } function k(a, c) {
            var d = a.type, f = a.role; return "checkbox" === (d || f) || "menuitemcheckbox" === f ? "checkbox" : "radio" === (d || f) || "menuitemradio" ===
            f ? "radio" : "range" === d || "progressbar" === f || "slider" === f ? "range" : ""
        } return {
            restrict: "A", require: "ngModel", priority: 200, compile: function (b, h) {
                var d = k(h, b); return {
                    pre: function (a, e, c, b) { "checkbox" === d && (b.$isEmpty = function (a) { return !1 === a }) }, post: function (f, e, b, n) {
                        function h() { return n.$modelValue } function k(a) { e.attr("aria-checked", b.value == n.$viewValue) } function l() { e.attr("aria-checked", !n.$isEmpty(n.$viewValue)) } var m = c("tabindex", "tabindex", e, !1); switch (d) {
                            case "radio": case "checkbox": g(d, e) && e.attr("role",
                            d); c("aria-checked", "ariaChecked", e, !1) && f.$watch(h, "radio" === d ? k : l); m && e.attr("tabindex", 0); break; case "range": g(d, e) && e.attr("role", "slider"); if (a.config("ariaValue")) {
                                var p = !e.attr("aria-valuemin") && (b.hasOwnProperty("min") || b.hasOwnProperty("ngMin")), r = !e.attr("aria-valuemax") && (b.hasOwnProperty("max") || b.hasOwnProperty("ngMax")), s = !e.attr("aria-valuenow"); p && b.$observe("min", function (a) { e.attr("aria-valuemin", a) }); r && b.$observe("max", function (a) { e.attr("aria-valuemax", a) }); s && f.$watch(h, function (a) {
                                    e.attr("aria-valuenow",
                                    a)
                                })
                            } m && e.attr("tabindex", 0)
                        } !b.hasOwnProperty("ngRequired") && n.$validators.required && c("aria-required", "ariaRequired", e, !1) && b.$observe("required", function () { e.attr("aria-required", !!b.required) }); c("aria-invalid", "ariaInvalid", e, !0) && f.$watch(function () { return n.$invalid }, function (a) { e.attr("aria-invalid", !!a) })
                    }
                }
            }
        }
    }]).directive("ngDisabled", ["$aria", function (a) { return a.$$watchExpr("ngDisabled", "aria-disabled", b, !1) }]).directive("ngMessages", function () {
        return {
            restrict: "A", require: "?ngMessages",
            link: function (a, b, g, k) { b.attr("aria-live") || b.attr("aria-live", "assertive") }
        }
    }).directive("ngClick", ["$aria", "$parse", function (a, c) {
        return {
            restrict: "A", compile: function (g, k) {
                var m = c(k.ngClick, null, !0); return function (c, d, f) {
                    if (!l(d, b) && (a.config("bindRoleForClick") && !d.attr("role") && d.attr("role", "button"), a.config("tabindex") && !d.attr("tabindex") && d.attr("tabindex", 0), a.config("bindKeypress") && !f.ngKeypress)) d.on("keypress", function (a) {
                        function b() { m(c, { $event: a }) } var d = a.which || a.keyCode; 32 !== d &&
                        13 !== d || c.$apply(b)
                    })
                }
            }
        }
    }]).directive("ngDblclick", ["$aria", function (a) { return function (c, g, k) { !a.config("tabindex") || g.attr("tabindex") || l(g, b) || g.attr("tabindex", 0) } }])
})(window, window.angular);
//# sourceMappingURL=angular-aria.min.js.map

/*
 AngularJS v1.5.5
 (c) 2010-2016 Google, Inc. http://angularjs.org
 License: MIT
*/
(function (P, d) {
    'use strict'; function G(t, g) { g = g || {}; d.forEach(g, function (d, q) { delete g[q] }); for (var q in t) !t.hasOwnProperty(q) || "$" === q.charAt(0) && "$" === q.charAt(1) || (g[q] = t[q]); return g } var z = d.$$minErr("$resource"), M = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/; d.module("ngResource", ["ng"]).provider("$resource", function () {
        var t = /^https?:\/\/[^\/]*/, g = this; this.defaults = { stripTrailingSlashes: !0, actions: { get: { method: "GET" }, save: { method: "POST" }, query: { method: "GET", isArray: !0 }, remove: { method: "DELETE" }, "delete": { method: "DELETE" } } };
        this.$get = ["$http", "$log", "$q", "$timeout", function (q, L, H, I) {
            function A(d, h) { return encodeURIComponent(d).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, h ? "%20" : "+") } function B(d, h) { this.template = d; this.defaults = v({}, g.defaults, h); this.urlParams = {} } function J(e, h, n, k) {
                function c(a, b) {
                    var c = {}; b = v({}, h, b); u(b, function (b, h) {
                        x(b) && (b = b()); var f; if (b && b.charAt && "@" == b.charAt(0)) {
                            f = a; var l = b.substr(1); if (null == l || "" === l || "hasOwnProperty" === l || !M.test("." +
                            l)) throw z("badmember", l); for (var l = l.split("."), m = 0, k = l.length; m < k && d.isDefined(f) ; m++) { var r = l[m]; f = null !== f ? f[r] : void 0 }
                        } else f = b; c[h] = f
                    }); return c
                } function N(a) { return a.resource } function m(a) { G(a || {}, this) } var t = new B(e, k); n = v({}, g.defaults.actions, n); m.prototype.toJSON = function () { var a = v({}, this); delete a.$promise; delete a.$resolved; return a }; u(n, function (a, b) {
                    var h = /^(POST|PUT|PATCH)$/i.test(a.method), e = a.timeout, E = d.isDefined(a.cancellable) ? a.cancellable : k && d.isDefined(k.cancellable) ? k.cancellable :
                    g.defaults.cancellable; e && !d.isNumber(e) && (L.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."), delete a.timeout, e = null); m[b] = function (f, l, k, g) {
                        var r = {}, n, w, C; switch (arguments.length) {
                            case 4: C = g, w = k; case 3: case 2: if (x(l)) { if (x(f)) { w = f; C = l; break } w = l; C = k } else { r = f; n = l; w = k; break } case 1: x(f) ?
                            w = f : h ? n = f : r = f; break; case 0: break; default: throw z("badargs", arguments.length);
                        } var D = this instanceof m, p = D ? n : a.isArray ? [] : new m(n), s = {}, A = a.interceptor && a.interceptor.response || N, B = a.interceptor && a.interceptor.responseError || void 0, y, F; u(a, function (a, b) { switch (b) { default: s[b] = O(a); case "params": case "isArray": case "interceptor": case "cancellable": } }); !D && E && (y = H.defer(), s.timeout = y.promise, e && (F = I(y.resolve, e))); h && (s.data = n); t.setUrlParams(s, v({}, c(n, a.params || {}), r), a.url); r = q(s).then(function (f) {
                            var c =
                            f.data; if (c) { if (d.isArray(c) !== !!a.isArray) throw z("badcfg", b, a.isArray ? "array" : "object", d.isArray(c) ? "array" : "object", s.method, s.url); if (a.isArray) p.length = 0, u(c, function (b) { "object" === typeof b ? p.push(new m(b)) : p.push(b) }); else { var l = p.$promise; G(c, p); p.$promise = l } } f.resource = p; return f
                        }, function (b) { (C || K)(b); return H.reject(b) }); r["finally"](function () { p.$resolved = !0; !D && E && (p.$cancelRequest = d.noop, I.cancel(F), y = F = s.timeout = null) }); r = r.then(function (b) { var a = A(b); (w || K)(a, b.headers); return a }, B);
                        return D ? r : (p.$promise = r, p.$resolved = !1, E && (p.$cancelRequest = y.resolve), p)
                    }; m.prototype["$" + b] = function (a, c, d) { x(a) && (d = c, c = a, a = {}); a = m[b].call(this, a, this, c, d); return a.$promise || a }
                }); m.bind = function (a) { return J(e, v({}, h, a), n) }; return m
            } var K = d.noop, u = d.forEach, v = d.extend, O = d.copy, x = d.isFunction; B.prototype = {
                setUrlParams: function (e, h, n) {
                    var k = this, c = n || k.template, g, m, q = "", a = k.urlParams = {}; u(c.split(/\W/), function (b) {
                        if ("hasOwnProperty" === b) throw z("badname"); !/^\d+$/.test(b) && b && (new RegExp("(^|[^\\\\]):" +
                        b + "(\\W|$)")).test(c) && (a[b] = { isQueryParamValue: (new RegExp("\\?.*=:" + b + "(?:\\W|$)")).test(c) })
                    }); c = c.replace(/\\:/g, ":"); c = c.replace(t, function (a) { q = a; return "" }); h = h || {}; u(k.urlParams, function (a, e) {
                        g = h.hasOwnProperty(e) ? h[e] : k.defaults[e]; d.isDefined(g) && null !== g ? (m = a.isQueryParamValue ? A(g, !0) : A(g, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+"), c = c.replace(new RegExp(":" + e + "(\\W|$)", "g"), function (a, b) { return m + b })) : c = c.replace(new RegExp("(/?):" + e + "(\\W|$)", "g"), function (a, b, c) {
                            return "/" ==
                            c.charAt(0) ? c : b + c
                        })
                    }); k.defaults.stripTrailingSlashes && (c = c.replace(/\/+$/, "") || "/"); c = c.replace(/\/\.(?=\w+($|\?))/, "."); e.url = q + c.replace(/\/\\\./, "/."); u(h, function (a, c) { k.urlParams[c] || (e.params = e.params || {}, e.params[c] = a) })
                }
            }; return J
        }]
    })
})(window, window.angular);
//# sourceMappingURL=angular-resource.min.js.map

/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), function (a, b, c) {
    "use strict"; function d(a, b) { return R(new (R(function () { }, { prototype: a })), b) } function e(a) { return Q(arguments, function (b) { b !== a && Q(b, function (b, c) { a.hasOwnProperty(c) || (a[c] = b) }) }), a } function f(a, b) { var c = []; for (var d in a.path) { if (a.path[d] !== b.path[d]) break; c.push(a.path[d]) } return c } function g(a) { if (Object.keys) return Object.keys(a); var b = []; return Q(a, function (a, c) { b.push(c) }), b } function h(a, b) { if (Array.prototype.indexOf) return a.indexOf(b, Number(arguments[2]) || 0); var c = a.length >>> 0, d = Number(arguments[2]) || 0; for (d = 0 > d ? Math.ceil(d) : Math.floor(d), 0 > d && (d += c) ; c > d; d++) if (d in a && a[d] === b) return d; return -1 } function i(a, b, c, d) { var e, i = f(c, d), j = {}, k = []; for (var l in i) if (i[l] && i[l].params && (e = g(i[l].params), e.length)) for (var m in e) h(k, e[m]) >= 0 || (k.push(e[m]), j[e[m]] = a[e[m]]); return R({}, j, b) } function j(a, b, c) { if (!c) { c = []; for (var d in a) c.push(d) } for (var e = 0; e < c.length; e++) { var f = c[e]; if (a[f] != b[f]) return !1 } return !0 } function k(a, b) { var c = {}; return Q(a, function (a) { c[a] = b[a] }), c } function l(a) { var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); return Q(c, function (c) { c in a && (b[c] = a[c]) }), b } function m(a) { var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1)); for (var d in a) -1 == h(c, d) && (b[d] = a[d]); return b } function n(a, b) { var c = P(a), d = c ? [] : {}; return Q(a, function (a, e) { b(a, e) && (d[c ? d.length : e] = a) }), d } function o(a, b) { var c = P(a) ? [] : {}; return Q(a, function (a, d) { c[d] = b(a, d) }), c } function p(a, b) { var d = 1, f = 2, i = {}, j = [], k = i, l = R(a.when(i), { $$promises: i, $$values: i }); this.study = function (i) { function n(a, c) { if (s[c] !== f) { if (r.push(c), s[c] === d) throw r.splice(0, h(r, c)), new Error("Cyclic dependency: " + r.join(" -> ")); if (s[c] = d, N(a)) q.push(c, [function () { return b.get(a) }], j); else { var e = b.annotate(a); Q(e, function (a) { a !== c && i.hasOwnProperty(a) && n(i[a], a) }), q.push(c, a, e) } r.pop(), s[c] = f } } function o(a) { return O(a) && a.then && a.$$promises } if (!O(i)) throw new Error("'invocables' must be an object"); var p = g(i || {}), q = [], r = [], s = {}; return Q(i, n), i = r = s = null, function (d, f, g) { function h() { --u || (v || e(t, f.$$values), r.$$values = t, r.$$promises = r.$$promises || !0, delete r.$$inheritedValues, n.resolve(t)) } function i(a) { r.$$failure = a, n.reject(a) } function j(c, e, f) { function j(a) { l.reject(a), i(a) } function k() { if (!L(r.$$failure)) try { l.resolve(b.invoke(e, g, t)), l.promise.then(function (a) { t[c] = a, h() }, j) } catch (a) { j(a) } } var l = a.defer(), m = 0; Q(f, function (a) { s.hasOwnProperty(a) && !d.hasOwnProperty(a) && (m++, s[a].then(function (b) { t[a] = b, --m || k() }, j)) }), m || k(), s[c] = l.promise } if (o(d) && g === c && (g = f, f = d, d = null), d) { if (!O(d)) throw new Error("'locals' must be an object") } else d = k; if (f) { if (!o(f)) throw new Error("'parent' must be a promise returned by $resolve.resolve()") } else f = l; var n = a.defer(), r = n.promise, s = r.$$promises = {}, t = R({}, d), u = 1 + q.length / 3, v = !1; if (L(f.$$failure)) return i(f.$$failure), r; f.$$inheritedValues && e(t, m(f.$$inheritedValues, p)), R(s, f.$$promises), f.$$values ? (v = e(t, m(f.$$values, p)), r.$$inheritedValues = m(f.$$values, p), h()) : (f.$$inheritedValues && (r.$$inheritedValues = m(f.$$inheritedValues, p)), f.then(h, i)); for (var w = 0, x = q.length; x > w; w += 3) d.hasOwnProperty(q[w]) ? h() : j(q[w], q[w + 1], q[w + 2]); return r } }, this.resolve = function (a, b, c, d) { return this.study(a)(b, c, d) } } function q(a, b, c) { this.fromConfig = function (a, b, c) { return L(a.template) ? this.fromString(a.template, b) : L(a.templateUrl) ? this.fromUrl(a.templateUrl, b) : L(a.templateProvider) ? this.fromProvider(a.templateProvider, b, c) : null }, this.fromString = function (a, b) { return M(a) ? a(b) : a }, this.fromUrl = function (c, d) { return M(c) && (c = c(d)), null == c ? null : a.get(c, { cache: b, headers: { Accept: "text/html" } }).then(function (a) { return a.data }) }, this.fromProvider = function (a, b, d) { return c.invoke(a, null, d || { params: b }) } } function r(a, b, e) { function f(b, c, d, e) { if (q.push(b), o[b]) return o[b]; if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b)) throw new Error("Invalid parameter name '" + b + "' in pattern '" + a + "'"); if (p[b]) throw new Error("Duplicate parameter name '" + b + "' in pattern '" + a + "'"); return p[b] = new U.Param(b, c, d, e), p[b] } function g(a, b, c, d) { var e = ["", ""], f = a.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&"); if (!b) return f; switch (c) { case !1: e = ["(", ")" + (d ? "?" : "")]; break; case !0: f = f.replace(/\/$/, ""), e = ["(?:/(", ")|/)?"]; break; default: e = ["(" + c + "|", ")?"] } return f + e[0] + b + e[1] } function h(e, f) { var g, h, i, j, k; return g = e[2] || e[3], k = b.params[g], i = a.substring(m, e.index), h = f ? e[4] : e[4] || ("*" == e[1] ? ".*" : null), h && (j = U.type(h) || d(U.type("string"), { pattern: new RegExp(h, b.caseInsensitive ? "i" : c) })), { id: g, regexp: h, segment: i, type: j, cfg: k } } b = R({ params: {} }, O(b) ? b : {}); var i, j = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, k = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, l = "^", m = 0, n = this.segments = [], o = e ? e.params : {}, p = this.params = e ? e.params.$$new() : new U.ParamSet, q = []; this.source = a; for (var r, s, t; (i = j.exec(a)) && (r = h(i, !1), !(r.segment.indexOf("?") >= 0)) ;) s = f(r.id, r.type, r.cfg, "path"), l += g(r.segment, s.type.pattern.source, s.squash, s.isOptional), n.push(r.segment), m = j.lastIndex; t = a.substring(m); var u = t.indexOf("?"); if (u >= 0) { var v = this.sourceSearch = t.substring(u); if (t = t.substring(0, u), this.sourcePath = a.substring(0, m + u), v.length > 0) for (m = 0; i = k.exec(v) ;) r = h(i, !0), s = f(r.id, r.type, r.cfg, "search"), m = j.lastIndex } else this.sourcePath = a, this.sourceSearch = ""; l += g(t) + (b.strict === !1 ? "/?" : "") + "$", n.push(t), this.regexp = new RegExp(l, b.caseInsensitive ? "i" : c), this.prefix = n[0], this.$$paramNames = q } function s(a) { R(this, a) } function t() { function a(a) { return null != a ? a.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : a } function e(a) { return null != a ? a.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : a } function f() { return { strict: p, caseInsensitive: m } } function i(a) { return M(a) || P(a) && M(a[a.length - 1]) } function j() { for (; w.length;) { var a = w.shift(); if (a.pattern) throw new Error("You cannot override a type's .pattern at runtime."); b.extend(u[a.name], l.invoke(a.def)) } } function k(a) { R(this, a || {}) } U = this; var l, m = !1, p = !0, q = !1, u = {}, v = !0, w = [], x = { string: { encode: a, decode: e, is: function (a) { return null == a || !L(a) || "string" == typeof a }, pattern: /[^\/]*/ }, "int": { encode: a, decode: function (a) { return parseInt(a, 10) }, is: function (a) { return L(a) && this.decode(a.toString()) === a }, pattern: /\d+/ }, bool: { encode: function (a) { return a ? 1 : 0 }, decode: function (a) { return 0 !== parseInt(a, 10) }, is: function (a) { return a === !0 || a === !1 }, pattern: /0|1/ }, date: { encode: function (a) { return this.is(a) ? [a.getFullYear(), ("0" + (a.getMonth() + 1)).slice(-2), ("0" + a.getDate()).slice(-2)].join("-") : c }, decode: function (a) { if (this.is(a)) return a; var b = this.capture.exec(a); return b ? new Date(b[1], b[2] - 1, b[3]) : c }, is: function (a) { return a instanceof Date && !isNaN(a.valueOf()) }, equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString() }, pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/, capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/ }, json: { encode: b.toJson, decode: b.fromJson, is: b.isObject, equals: b.equals, pattern: /[^\/]*/ }, any: { encode: b.identity, decode: b.identity, equals: b.equals, pattern: /.*/ } }; t.$$getDefaultValue = function (a) { if (!i(a.value)) return a.value; if (!l) throw new Error("Injectable functions cannot be called at configuration time"); return l.invoke(a.value) }, this.caseInsensitive = function (a) { return L(a) && (m = a), m }, this.strictMode = function (a) { return L(a) && (p = a), p }, this.defaultSquashPolicy = function (a) { if (!L(a)) return q; if (a !== !0 && a !== !1 && !N(a)) throw new Error("Invalid squash policy: " + a + ". Valid policies: false, true, arbitrary-string"); return q = a, a }, this.compile = function (a, b) { return new r(a, R(f(), b)) }, this.isMatcher = function (a) { if (!O(a)) return !1; var b = !0; return Q(r.prototype, function (c, d) { M(c) && (b = b && L(a[d]) && M(a[d])) }), b }, this.type = function (a, b, c) { if (!L(b)) return u[a]; if (u.hasOwnProperty(a)) throw new Error("A type named '" + a + "' has already been defined."); return u[a] = new s(R({ name: a }, b)), c && (w.push({ name: a, def: c }), v || j()), this }, Q(x, function (a, b) { u[b] = new s(R({ name: b }, a)) }), u = d(u, {}), this.$get = ["$injector", function (a) { return l = a, v = !1, j(), Q(x, function (a, b) { u[b] || (u[b] = new s(a)) }), this }], this.Param = function (a, d, e, f) { function j(a) { var b = O(a) ? g(a) : [], c = -1 === h(b, "value") && -1 === h(b, "type") && -1 === h(b, "squash") && -1 === h(b, "array"); return c && (a = { value: a }), a.$$fn = i(a.value) ? a.value : function () { return a.value }, a } function k(c, d, e) { if (c.type && d) throw new Error("Param '" + a + "' has two type configurations."); return d ? d : c.type ? b.isString(c.type) ? u[c.type] : c.type instanceof s ? c.type : new s(c.type) : "config" === e ? u.any : u.string } function m() { var b = { array: "search" === f ? "auto" : !1 }, c = a.match(/\[\]$/) ? { array: !0 } : {}; return R(b, c, e).array } function p(a, b) { var c = a.squash; if (!b || c === !1) return !1; if (!L(c) || null == c) return q; if (c === !0 || N(c)) return c; throw new Error("Invalid squash policy: '" + c + "'. Valid policies: false, true, or arbitrary string") } function r(a, b, d, e) { var f, g, i = [{ from: "", to: d || b ? c : "" }, { from: null, to: d || b ? c : "" }]; return f = P(a.replace) ? a.replace : [], N(e) && f.push({ from: e, to: c }), g = o(f, function (a) { return a.from }), n(i, function (a) { return -1 === h(g, a.from) }).concat(f) } function t() { if (!l) throw new Error("Injectable functions cannot be called at configuration time"); var a = l.invoke(e.$$fn); if (null !== a && a !== c && !x.type.is(a)) throw new Error("Default value (" + a + ") for parameter '" + x.id + "' is not an instance of Type (" + x.type.name + ")"); return a } function v(a) { function b(a) { return function (b) { return b.from === a } } function c(a) { var c = o(n(x.replace, b(a)), function (a) { return a.to }); return c.length ? c[0] : a } return a = c(a), L(a) ? x.type.$normalize(a) : t() } function w() { return "{Param:" + a + " " + d + " squash: '" + A + "' optional: " + z + "}" } var x = this; e = j(e), d = k(e, d, f); var y = m(); d = y ? d.$asArray(y, "search" === f) : d, "string" !== d.name || y || "path" !== f || e.value !== c || (e.value = ""); var z = e.value !== c, A = p(e, z), B = r(e, y, z, A); R(this, { id: a, type: d, location: f, array: y, squash: A, replace: B, isOptional: z, value: v, dynamic: c, config: e, toString: w }) }, k.prototype = { $$new: function () { return d(this, R(new k, { $$parent: this })) }, $$keys: function () { for (var a = [], b = [], c = this, d = g(k.prototype) ; c;) b.push(c), c = c.$$parent; return b.reverse(), Q(b, function (b) { Q(g(b), function (b) { -1 === h(a, b) && -1 === h(d, b) && a.push(b) }) }), a }, $$values: function (a) { var b = {}, c = this; return Q(c.$$keys(), function (d) { b[d] = c[d].value(a && a[d]) }), b }, $$equals: function (a, b) { var c = !0, d = this; return Q(d.$$keys(), function (e) { var f = a && a[e], g = b && b[e]; d[e].type.equals(f, g) || (c = !1) }), c }, $$validates: function (a) { var d, e, f, g, h, i = this.$$keys(); for (d = 0; d < i.length && (e = this[i[d]], f = a[i[d]], f !== c && null !== f || !e.isOptional) ; d++) { if (g = e.type.$normalize(f), !e.type.is(g)) return !1; if (h = e.type.encode(g), b.isString(h) && !e.type.pattern.exec(h)) return !1 } return !0 }, $$parent: c }, this.ParamSet = k } function u(a, d) { function e(a) { var b = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source); return null != b ? b[1].replace(/\\(.)/g, "$1") : "" } function f(a, b) { return a.replace(/\$(\$|\d{1,2})/, function (a, c) { return b["$" === c ? 0 : Number(c)] }) } function g(a, b, c) { if (!c) return !1; var d = a.invoke(b, b, { $match: c }); return L(d) ? d : !0 } function h(d, e, f, g, h) { function m(a, b, c) { return "/" === q ? a : b ? q.slice(0, -1) + a : c ? q.slice(1) + a : a } function n(a) { function b(a) { var b = a(f, d); return b ? (N(b) && d.replace().url(b), !0) : !1 } if (!a || !a.defaultPrevented) { p && d.url() === p; p = c; var e, g = j.length; for (e = 0; g > e; e++) if (b(j[e])) return; k && b(k) } } function o() { return i = i || e.$on("$locationChangeSuccess", n) } var p, q = g.baseHref(), r = d.url(); return l || o(), { sync: function () { n() }, listen: function () { return o() }, update: function (a) { return a ? void (r = d.url()) : void (d.url() !== r && (d.url(r), d.replace())) }, push: function (a, b, e) { var f = a.format(b || {}); null !== f && b && b["#"] && (f += "#" + b["#"]), d.url(f), p = e && e.$$avoidResync ? d.url() : c, e && e.replace && d.replace() }, href: function (c, e, f) { if (!c.validates(e)) return null; var g = a.html5Mode(); b.isObject(g) && (g = g.enabled), g = g && h.history; var i = c.format(e); if (f = f || {}, g || null === i || (i = "#" + a.hashPrefix() + i), null !== i && e && e["#"] && (i += "#" + e["#"]), i = m(i, g, f.absolute), !f.absolute || !i) return i; var j = !g && i ? "/" : "", k = d.port(); return k = 80 === k || 443 === k ? "" : ":" + k, [d.protocol(), "://", d.host(), k, j, i].join("") } } } var i, j = [], k = null, l = !1; this.rule = function (a) { if (!M(a)) throw new Error("'rule' must be a function"); return j.push(a), this }, this.otherwise = function (a) { if (N(a)) { var b = a; a = function () { return b } } else if (!M(a)) throw new Error("'rule' must be a function"); return k = a, this }, this.when = function (a, b) { var c, h = N(b); if (N(a) && (a = d.compile(a)), !h && !M(b) && !P(b)) throw new Error("invalid 'handler' in when()"); var i = { matcher: function (a, b) { return h && (c = d.compile(b), b = ["$match", function (a) { return c.format(a) }]), R(function (c, d) { return g(c, b, a.exec(d.path(), d.search())) }, { prefix: N(a.prefix) ? a.prefix : "" }) }, regex: function (a, b) { if (a.global || a.sticky) throw new Error("when() RegExp must not be global or sticky"); return h && (c = b, b = ["$match", function (a) { return f(c, a) }]), R(function (c, d) { return g(c, b, a.exec(d.path())) }, { prefix: e(a) }) } }, j = { matcher: d.isMatcher(a), regex: a instanceof RegExp }; for (var k in j) if (j[k]) return this.rule(i[k](a, b)); throw new Error("invalid 'what' in when()") }, this.deferIntercept = function (a) { a === c && (a = !0), l = a }, this.$get = h, h.$inject = ["$location", "$rootScope", "$injector", "$browser", "$sniffer"] } function v(a, e) { function f(a) { return 0 === a.indexOf(".") || 0 === a.indexOf("^") } function m(a, b) { if (!a) return c; var d = N(a), e = d ? a : a.name, g = f(e); if (g) { if (!b) throw new Error("No reference point given for path '" + e + "'"); b = m(b); for (var h = e.split("."), i = 0, j = h.length, k = b; j > i; i++) if ("" !== h[i] || 0 !== i) { if ("^" !== h[i]) break; if (!k.parent) throw new Error("Path '" + e + "' not valid for state '" + b.name + "'"); k = k.parent } else k = b; h = h.slice(i).join("."), e = k.name + (k.name && h ? "." : "") + h } var l = z[e]; return !l || !d && (d || l !== a && l.self !== a) ? c : l } function n(a, b) { A[a] || (A[a] = []), A[a].push(b) } function p(a) { for (var b = A[a] || []; b.length;) q(b.shift()) } function q(b) { b = d(b, { self: b, resolve: b.resolve || {}, toString: function () { return this.name } }); var c = b.name; if (!N(c) || c.indexOf("@") >= 0) throw new Error("State must have a valid name"); if (z.hasOwnProperty(c)) throw new Error("State '" + c + "' is already defined"); var e = -1 !== c.indexOf(".") ? c.substring(0, c.lastIndexOf(".")) : N(b.parent) ? b.parent : O(b.parent) && N(b.parent.name) ? b.parent.name : ""; if (e && !z[e]) return n(e, b.self); for (var f in C) M(C[f]) && (b[f] = C[f](b, C.$delegates[f])); return z[c] = b, !b[B] && b.url && a.when(b.url, ["$match", "$stateParams", function (a, c) { y.$current.navigable == b && j(a, c) || y.transitionTo(b, a, { inherit: !0, location: !1 }) }]), p(c), b } function r(a) { return a.indexOf("*") > -1 } function s(a) { for (var b = a.split("."), c = y.$current.name.split("."), d = 0, e = b.length; e > d; d++) "*" === b[d] && (c[d] = "*"); return "**" === b[0] && (c = c.slice(h(c, b[1])), c.unshift("**")), "**" === b[b.length - 1] && (c.splice(h(c, b[b.length - 2]) + 1, Number.MAX_VALUE), c.push("**")), b.length != c.length ? !1 : c.join("") === b.join("") } function t(a, b) { return N(a) && !L(b) ? C[a] : M(b) && N(a) ? (C[a] && !C.$delegates[a] && (C.$delegates[a] = C[a]), C[a] = b, this) : this } function u(a, b) { return O(a) ? b = a : b.name = a, q(b), this } function v(a, e, f, h, l, n, p, q, t) { function u(b, c, d, f) { var g = a.$broadcast("$stateNotFound", b, c, d); if (g.defaultPrevented) return p.update(), D; if (!g.retry) return null; if (f.$retry) return p.update(), E; var h = y.transition = e.when(g.retry); return h.then(function () { return h !== y.transition ? A : (b.options.$retry = !0, y.transitionTo(b.to, b.toParams, b.options)) }, function () { return D }), p.update(), h } function v(a, c, d, g, i, j) { function m() { var c = []; return Q(a.views, function (d, e) { var g = d.resolve && d.resolve !== a.resolve ? d.resolve : {}; g.$template = [function () { return f.load(e, { view: d, locals: i.globals, params: n, notify: j.notify }) || "" }], c.push(l.resolve(g, i.globals, i.resolve, a).then(function (c) { if (M(d.controllerProvider) || P(d.controllerProvider)) { var f = b.extend({}, g, i.globals); c.$$controller = h.invoke(d.controllerProvider, null, f) } else c.$$controller = d.controller; c.$$state = a, c.$$controllerAs = d.controllerAs, i[e] = c })) }), e.all(c).then(function () { return i.globals }) } var n = d ? c : k(a.params.$$keys(), c), o = { $stateParams: n }; i.resolve = l.resolve(a.resolve, o, i.resolve, a); var p = [i.resolve.then(function (a) { i.globals = a })]; return g && p.push(g), e.all(p).then(m).then(function (a) { return i }) } var A = e.reject(new Error("transition superseded")), C = e.reject(new Error("transition prevented")), D = e.reject(new Error("transition aborted")), E = e.reject(new Error("transition failed")); return x.locals = { resolve: null, globals: { $stateParams: {} } }, y = { params: {}, current: x.self, $current: x, transition: null }, y.reload = function (a) { return y.transitionTo(y.current, n, { reload: a || !0, inherit: !1, notify: !0 }) }, y.go = function (a, b, c) { return y.transitionTo(a, b, R({ inherit: !0, relative: y.$current }, c)) }, y.transitionTo = function (b, c, f) { c = c || {}, f = R({ location: !0, inherit: !1, relative: null, notify: !0, reload: !1, $retry: !1 }, f || {}); var g, j = y.$current, l = y.params, o = j.path, q = m(b, f.relative), r = c["#"]; if (!L(q)) { var s = { to: b, toParams: c, options: f }, t = u(s, j.self, l, f); if (t) return t; if (b = s.to, c = s.toParams, f = s.options, q = m(b, f.relative), !L(q)) { if (!f.relative) throw new Error("No such state '" + b + "'"); throw new Error("Could not resolve '" + b + "' from state '" + f.relative + "'") } } if (q[B]) throw new Error("Cannot transition to abstract state '" + b + "'"); if (f.inherit && (c = i(n, c || {}, y.$current, q)), !q.params.$$validates(c)) return E; c = q.params.$$values(c), b = q; var z = b.path, D = 0, F = z[D], G = x.locals, H = []; if (f.reload) { if (N(f.reload) || O(f.reload)) { if (O(f.reload) && !f.reload.name) throw new Error("Invalid reload state object"); var I = f.reload === !0 ? o[0] : m(f.reload); if (f.reload && !I) throw new Error("No such reload state '" + (N(f.reload) ? f.reload : f.reload.name) + "'"); for (; F && F === o[D] && F !== I;) G = H[D] = F.locals, D++, F = z[D] } } else for (; F && F === o[D] && F.ownParams.$$equals(c, l) ;) G = H[D] = F.locals, D++, F = z[D]; if (w(b, c, j, l, G, f)) return r && (c["#"] = r), y.params = c, S(y.params, n), S(k(b.params.$$keys(), n), b.locals.globals.$stateParams), f.location && b.navigable && b.navigable.url && (p.push(b.navigable.url, c, { $$avoidResync: !0, replace: "replace" === f.location }), p.update(!0)), y.transition = null, e.when(y.current); if (c = k(b.params.$$keys(), c || {}), r && (c["#"] = r), f.notify && a.$broadcast("$stateChangeStart", b.self, c, j.self, l, f).defaultPrevented) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), null == y.transition && p.update(), C; for (var J = e.when(G), K = D; K < z.length; K++, F = z[K]) G = H[K] = d(G), J = v(F, c, F === b, J, G, f); var M = y.transition = J.then(function () { var d, e, g; if (y.transition !== M) return A; for (d = o.length - 1; d >= D; d--) g = o[d], g.self.onExit && h.invoke(g.self.onExit, g.self, g.locals.globals), g.locals = null; for (d = D; d < z.length; d++) e = z[d], e.locals = H[d], e.self.onEnter && h.invoke(e.self.onEnter, e.self, e.locals.globals); return y.transition !== M ? A : (y.$current = b, y.current = b.self, y.params = c, S(y.params, n), y.transition = null, f.location && b.navigable && p.push(b.navigable.url, b.navigable.locals.globals.$stateParams, { $$avoidResync: !0, replace: "replace" === f.location }), f.notify && a.$broadcast("$stateChangeSuccess", b.self, c, j.self, l), p.update(!0), y.current) }, function (d) { return y.transition !== M ? A : (y.transition = null, g = a.$broadcast("$stateChangeError", b.self, c, j.self, l, d), g.defaultPrevented || p.update(), e.reject(d)) }); return M }, y.is = function (a, b, d) { d = R({ relative: y.$current }, d || {}); var e = m(a, d.relative); return L(e) ? y.$current !== e ? !1 : b ? j(e.params.$$values(b), n) : !0 : c }, y.includes = function (a, b, d) { if (d = R({ relative: y.$current }, d || {}), N(a) && r(a)) { if (!s(a)) return !1; a = y.$current.name } var e = m(a, d.relative); return L(e) ? L(y.$current.includes[e.name]) ? b ? j(e.params.$$values(b), n, g(b)) : !0 : !1 : c }, y.href = function (a, b, d) { d = R({ lossy: !0, inherit: !0, absolute: !1, relative: y.$current }, d || {}); var e = m(a, d.relative); if (!L(e)) return null; d.inherit && (b = i(n, b || {}, y.$current, e)); var f = e && d.lossy ? e.navigable : e; return f && f.url !== c && null !== f.url ? p.href(f.url, k(e.params.$$keys().concat("#"), b || {}), { absolute: d.absolute }) : null }, y.get = function (a, b) { if (0 === arguments.length) return o(g(z), function (a) { return z[a].self }); var c = m(a, b || y.$current); return c && c.self ? c.self : null }, y } function w(a, b, c, d, e, f) { function g(a, b, c) { function d(b) { return "search" != a.params[b].location } var e = a.params.$$keys().filter(d), f = l.apply({}, [a.params].concat(e)), g = new U.ParamSet(f); return g.$$equals(b, c) } return !f.reload && a === c && (e === c.locals || a.self.reloadOnSearch === !1 && g(c, d, b)) ? !0 : void 0 } var x, y, z = {}, A = {}, B = "abstract", C = { parent: function (a) { if (L(a.parent) && a.parent) return m(a.parent); var b = /^(.+)\.[^.]+$/.exec(a.name); return b ? m(b[1]) : x }, data: function (a) { return a.parent && a.parent.data && (a.data = a.self.data = d(a.parent.data, a.data)), a.data }, url: function (a) { var b = a.url, c = { params: a.params || {} }; if (N(b)) return "^" == b.charAt(0) ? e.compile(b.substring(1), c) : (a.parent.navigable || x).url.concat(b, c); if (!b || e.isMatcher(b)) return b; throw new Error("Invalid url '" + b + "' in state '" + a + "'") }, navigable: function (a) { return a.url ? a : a.parent ? a.parent.navigable : null }, ownParams: function (a) { var b = a.url && a.url.params || new U.ParamSet; return Q(a.params || {}, function (a, c) { b[c] || (b[c] = new U.Param(c, null, a, "config")) }), b }, params: function (a) { var b = l(a.ownParams, a.ownParams.$$keys()); return a.parent && a.parent.params ? R(a.parent.params.$$new(), b) : new U.ParamSet }, views: function (a) { var b = {}; return Q(L(a.views) ? a.views : { "": a }, function (c, d) { d.indexOf("@") < 0 && (d += "@" + a.parent.name), b[d] = c }), b }, path: function (a) { return a.parent ? a.parent.path.concat(a) : [] }, includes: function (a) { var b = a.parent ? R({}, a.parent.includes) : {}; return b[a.name] = !0, b }, $delegates: {} }; x = q({ name: "", url: "^", views: null, "abstract": !0 }), x.navigable = null, this.decorator = t, this.state = u, this.$get = v, v.$inject = ["$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory"] } function w() { function a(a, b) { return { load: function (a, c) { var d, e = { template: null, controller: null, view: null, locals: null, notify: !0, async: !0, params: {} }; return c = R(e, c), c.view && (d = b.fromConfig(c.view, c.params, c.locals)), d } } } this.$get = a, a.$inject = ["$rootScope", "$templateFactory"] } function x() { var a = !1; this.useAnchorScroll = function () { a = !0 }, this.$get = ["$anchorScroll", "$timeout", function (b, c) { return a ? b : function (a) { return c(function () { a[0].scrollIntoView() }, 0, !1) } }] } function y(a, c, d, e) { function f() { return c.has ? function (a) { return c.has(a) ? c.get(a) : null } : function (a) { try { return c.get(a) } catch (b) { return null } } } function g(a, c) { function d(a) { return 1 === V && W >= 4 ? !!j.enabled(a) : 1 === V && W >= 2 ? !!j.enabled() : !!i } var e = { enter: function (a, b, c) { b.after(a), c() }, leave: function (a, b) { a.remove(), b() } }; if (a.noanimation) return e; if (j) return { enter: function (a, c, f) { d(a) ? b.version.minor > 2 ? j.enter(a, null, c).then(f) : j.enter(a, null, c, f) : e.enter(a, c, f) }, leave: function (a, c) { d(a) ? b.version.minor > 2 ? j.leave(a).then(c) : j.leave(a, c) : e.leave(a, c) } }; if (i) { var f = i && i(c, a); return { enter: function (a, b, c) { f.enter(a, null, b), c() }, leave: function (a, b) { f.leave(a), b() } } } return e } var h = f(), i = h("$animator"), j = h("$animate"), k = { restrict: "ECA", terminal: !0, priority: 400, transclude: "element", compile: function (c, f, h) { return function (c, f, i) { function j() { function a() { b && b.remove(), c && c.$destroy() } var b = l, c = n; c && (c._willBeDestroyed = !0), m ? (r.leave(m, function () { a(), l = null }), l = m) : (a(), l = null), m = null, n = null } function k(g) { var k, l = A(c, i, f, e), s = l && a.$current && a.$current.locals[l]; if ((g || s !== o) && !c._willBeDestroyed) { k = c.$new(), o = a.$current.locals[l], k.$emit("$viewContentLoading", l); var t = h(k, function (a) { r.enter(a, f, function () { n && n.$emit("$viewContentAnimationEnded"), (b.isDefined(q) && !q || c.$eval(q)) && d(a) }), j() }); m = t, n = k, n.$emit("$viewContentLoaded", l), n.$eval(p) } } var l, m, n, o, p = i.onload || "", q = i.autoscroll, r = g(i, c); c.$on("$stateChangeSuccess", function () { k(!1) }), k(!0) } } }; return k } function z(a, b, c, d) { return { restrict: "ECA", priority: -400, compile: function (e) { var f = e.html(); return function (e, g, h) { var i = c.$current, j = A(e, h, g, d), k = i && i.locals[j]; if (k) { g.data("$uiView", { name: j, state: k.$$state }), g.html(k.$template ? k.$template : f); var l = a(g.contents()); if (k.$$controller) { k.$scope = e, k.$element = g; var m = b(k.$$controller, k); k.$$controllerAs && (e[k.$$controllerAs] = m), g.data("$ngControllerController", m), g.children().data("$ngControllerController", m) } l(e) } } } } } function A(a, b, c, d) { var e = d(b.uiView || b.name || "")(a), f = c.inheritedData("$uiView"); return e.indexOf("@") >= 0 ? e : e + "@" + (f ? f.state.name : "") } function B(a, b) { var c, d = a.match(/^\s*({[^}]*})\s*$/); if (d && (a = b + "(" + d[1] + ")"), c = a.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), !c || 4 !== c.length) throw new Error("Invalid state ref '" + a + "'"); return { state: c[1], paramExpr: c[3] || null } } function C(a) { var b = a.parent().inheritedData("$uiView"); return b && b.state && b.state.name ? b.state : void 0 } function D(a) { var b = "[object SVGAnimatedString]" === Object.prototype.toString.call(a.prop("href")), c = "FORM" === a[0].nodeName; return { attr: c ? "action" : b ? "xlink:href" : "href", isAnchor: "A" === a.prop("tagName").toUpperCase(), clickable: !c } } function E(a, b, c, d, e) { return function (f) { var g = f.which || f.button, h = e(); if (!(g > 1 || f.ctrlKey || f.metaKey || f.shiftKey || a.attr("target"))) { var i = c(function () { b.go(h.state, h.params, h.options) }); f.preventDefault(); var j = d.isAnchor && !h.href ? 1 : 0; f.preventDefault = function () { j-- <= 0 && c.cancel(i) } } } } function F(a, b) { return { relative: C(a) || b.$current, inherit: !0 } } function G(a, c) { return { restrict: "A", require: ["?^uiSrefActive", "?^uiSrefActiveEq"], link: function (d, e, f, g) { var h = B(f.uiSref, a.current.name), i = { state: h.state, href: null, params: null }, j = D(e), k = g[1] || g[0]; i.options = R(F(e, a), f.uiSrefOpts ? d.$eval(f.uiSrefOpts) : {}); var l = function (c) { c && (i.params = b.copy(c)), i.href = a.href(h.state, i.params, i.options), k && k.$$addStateInfo(h.state, i.params), null !== i.href && f.$set(j.attr, i.href) }; h.paramExpr && (d.$watch(h.paramExpr, function (a) { a !== i.params && l(a) }, !0), i.params = b.copy(d.$eval(h.paramExpr))), l(), j.clickable && e.bind("click", E(e, a, c, j, function () { return i })) } } } function H(a, b) { return { restrict: "A", require: ["?^uiSrefActive", "?^uiSrefActiveEq"], link: function (c, d, e, f) { function g(b) { l.state = b[0], l.params = b[1], l.options = b[2], l.href = a.href(l.state, l.params, l.options), i && i.$$addStateInfo(l.state, l.params), l.href && e.$set(h.attr, l.href) } var h = D(d), i = f[1] || f[0], j = [e.uiState, e.uiStateParams || null, e.uiStateOpts || null], k = "[" + j.map(function (a) { return a || "null" }).join(", ") + "]", l = { state: null, params: null, options: null, href: null }; c.$watch(k, g, !0), g(c.$eval(k)), h.clickable && d.bind("click", E(d, a, b, h, function () { return l })) } } } function I(a, b, c) { return { restrict: "A", controller: ["$scope", "$element", "$attrs", "$timeout", function (b, d, e, f) { function g(b, c, e) { var f = a.get(b, C(d)), g = h(b, c); p.push({ state: f || { name: b }, params: c, hash: g }), q[g] = e } function h(a, c) { if (!N(a)) throw new Error("state should be a string"); return O(c) ? a + T(c) : (c = b.$eval(c), O(c) ? a + T(c) : a) } function i() { for (var a = 0; a < p.length; a++) l(p[a].state, p[a].params) ? j(d, q[p[a].hash]) : k(d, q[p[a].hash]), m(p[a].state, p[a].params) ? j(d, n) : k(d, n) } function j(a, b) { f(function () { a.addClass(b) }) } function k(a, b) { a.removeClass(b) } function l(b, c) { return a.includes(b.name, c) } function m(b, c) { return a.is(b.name, c) } var n, o, p = [], q = {}; n = c(e.uiSrefActiveEq || "", !1)(b); try { o = b.$eval(e.uiSrefActive) } catch (r) { } o = o || c(e.uiSrefActive || "", !1)(b), O(o) && Q(o, function (c, d) { if (N(c)) { var e = B(c, a.current.name); g(e.state, b.$eval(e.paramExpr), d) } }), this.$$addStateInfo = function (a, b) { O(o) && p.length > 0 || (g(a, b, o), i()) }, b.$on("$stateChangeSuccess", i), i() }] } } function J(a) { var b = function (b, c) { return a.is(b, c) }; return b.$stateful = !0, b } function K(a) { var b = function (b, c, d) { return a.includes(b, c, d) }; return b.$stateful = !0, b } var L = b.isDefined, M = b.isFunction, N = b.isString, O = b.isObject, P = b.isArray, Q = b.forEach, R = b.extend, S = b.copy, T = b.toJson; b.module("ui.router.util", ["ng"]), b.module("ui.router.router", ["ui.router.util"]), b.module("ui.router.state", ["ui.router.router", "ui.router.util"]), b.module("ui.router", ["ui.router.state"]), b.module("ui.router.compat", ["ui.router"]), p.$inject = ["$q", "$injector"], b.module("ui.router.util").service("$resolve", p), q.$inject = ["$http", "$templateCache", "$injector"], b.module("ui.router.util").service("$templateFactory", q); var U; r.prototype.concat = function (a, b) { var c = { caseInsensitive: U.caseInsensitive(), strict: U.strictMode(), squash: U.defaultSquashPolicy() }; return new r(this.sourcePath + a + this.sourceSearch, R(c, b), this) }, r.prototype.toString = function () { return this.source }, r.prototype.exec = function (a, b) { function c(a) { function b(a) { return a.split("").reverse().join("") } function c(a) { return a.replace(/\\-/g, "-") } var d = b(a).split(/-(?!\\)/), e = o(d, b); return o(e, c).reverse() } var d = this.regexp.exec(a); if (!d) return null; b = b || {}; var e, f, g, h = this.parameters(), i = h.length, j = this.segments.length - 1, k = {}; if (j !== d.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'"); var l, m; for (e = 0; j > e; e++) { for (g = h[e], l = this.params[g], m = d[e + 1], f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to); m && l.array === !0 && (m = c(m)), L(m) && (m = l.type.decode(m)), k[g] = l.value(m) } for (; i > e; e++) { for (g = h[e], k[g] = this.params[g].value(b[g]), l = this.params[g], m = b[g], f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to); L(m) && (m = l.type.decode(m)), k[g] = l.value(m) } return k }, r.prototype.parameters = function (a) { return L(a) ? this.params[a] || null : this.$$paramNames }, r.prototype.validates = function (a) { return this.params.$$validates(a) }, r.prototype.format = function (a) { function b(a) { return encodeURIComponent(a).replace(/-/g, function (a) { return "%5C%" + a.charCodeAt(0).toString(16).toUpperCase() }) } a = a || {}; var c = this.segments, d = this.parameters(), e = this.params; if (!this.validates(a)) return null; var f, g = !1, h = c.length - 1, i = d.length, j = c[0]; for (f = 0; i > f; f++) { var k = h > f, l = d[f], m = e[l], n = m.value(a[l]), p = m.isOptional && m.type.equals(m.value(), n), q = p ? m.squash : !1, r = m.type.encode(n); if (k) { var s = c[f + 1], t = f + 1 === h; if (q === !1) null != r && (j += P(r) ? o(r, b).join("-") : encodeURIComponent(r)), j += s; else if (q === !0) { var u = j.match(/\/$/) ? /\/?(.*)/ : /(.*)/; j += s.match(u)[1] } else N(q) && (j += q + s); t && m.squash === !0 && "/" === j.slice(-1) && (j = j.slice(0, -1)) } else { if (null == r || p && q !== !1) continue; if (P(r) || (r = [r]), 0 === r.length) continue; r = o(r, encodeURIComponent).join("&" + l + "="), j += (g ? "&" : "?") + (l + "=" + r), g = !0 } } return j }, s.prototype.is = function (a, b) { return !0 }, s.prototype.encode = function (a, b) { return a }, s.prototype.decode = function (a, b) { return a }, s.prototype.equals = function (a, b) { return a == b }, s.prototype.$subPattern = function () { var a = this.pattern.toString(); return a.substr(1, a.length - 2) }, s.prototype.pattern = /.*/, s.prototype.toString = function () { return "{Type:" + this.name + "}" }, s.prototype.$normalize = function (a) { return this.is(a) ? a : this.decode(a) }, s.prototype.$asArray = function (a, b) { function d(a, b) { function d(a, b) { return function () { return a[b].apply(a, arguments) } } function e(a) { return P(a) ? a : L(a) ? [a] : [] } function f(a) { switch (a.length) { case 0: return c; case 1: return "auto" === b ? a[0] : a; default: return a } } function g(a) { return !a } function h(a, b) { return function (c) { if (P(c) && 0 === c.length) return c; c = e(c); var d = o(c, a); return b === !0 ? 0 === n(d, g).length : f(d) } } function i(a) { return function (b, c) { var d = e(b), f = e(c); if (d.length !== f.length) return !1; for (var g = 0; g < d.length; g++) if (!a(d[g], f[g])) return !1; return !0 } } this.encode = h(d(a, "encode")), this.decode = h(d(a, "decode")), this.is = h(d(a, "is"), !0), this.equals = i(d(a, "equals")), this.pattern = a.pattern, this.$normalize = h(d(a, "$normalize")), this.name = a.name, this.$arrayMode = b } if (!a) return this; if ("auto" === a && !b) throw new Error("'auto' array mode is for query parameters only"); return new d(this, a) }, b.module("ui.router.util").provider("$urlMatcherFactory", t), b.module("ui.router.util").run(["$urlMatcherFactory", function (a) { }]), u.$inject = ["$locationProvider", "$urlMatcherFactoryProvider"], b.module("ui.router.router").provider("$urlRouter", u), v.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"], b.module("ui.router.state").factory("$stateParams", function () { return {} }).provider("$state", v), w.$inject = [], b.module("ui.router.state").provider("$view", w), b.module("ui.router.state").provider("$uiViewScroll", x); var V = b.version.major, W = b.version.minor; y.$inject = ["$state", "$injector", "$uiViewScroll", "$interpolate"], z.$inject = ["$compile", "$controller", "$state", "$interpolate"], b.module("ui.router.state").directive("uiView", y), b.module("ui.router.state").directive("uiView", z), G.$inject = ["$state", "$timeout"], H.$inject = ["$state", "$timeout"], I.$inject = ["$state", "$stateParams", "$interpolate"], b.module("ui.router.state").directive("uiSref", G).directive("uiSrefActive", I).directive("uiSrefActiveEq", I).directive("uiState", H),
    J.$inject = ["$state"], K.$inject = ["$state"], b.module("ui.router.state").filter("isState", J).filter("includedByState", K)
}(window, window.angular);
/*! angular-css 1.0.8 | Copyright (c) 2016 Alex Castillo | MIT License */"use strict"; !function (a) { var b = a.module("angularCSS", []); a.module("door3.css", []).run(function () { console.error('AngularCSS: The module name "door3.css" is now deprecated. Please use "angularCSS" instead.') }), b.provider("$css", [function () { var b = this.defaults = { element: "link", rel: "stylesheet", type: "text/css", container: "head", method: "append", weight: 0 }, d = !1; this.debugMode = function (b) { return a.isDefined(b) && (d = b), d }, this.$get = ["$rootScope", "$injector", "$q", "$window", "$timeout", "$compile", "$http", "$filter", "$log", "$interpolate", function (e, f, g, h, i, j, k, l, m, n) { function o(a, b, c) { c && b.hasOwnProperty("css") && y.bind(b.css, c) } function p(a, b, c) { c && (y.remove(y.getFromRoute(c).concat(F)), F.length = 0), b && y.add(y.getFromRoute(b)) } function q(a, b, c, d) { d && (y.remove(y.getFromState(d).concat(F)), F.length = 0), b && y.add(y.getFromState(b)) } function r(b) { a.isDefined(D.breakpoints) && (b.breakpoint in D.breakpoints && (b.media = D.breakpoints[b.breakpoint]), delete b.breakpoints) } function s(b) { return b ? (a.isFunction(b) && (b = a.copy(f.invoke(b))), a.isString(b) && (b = a.extend({ href: b }, D)), a.isArray(b) && a.isString(b[0]) && a.forEach(b, function (c) { b = a.extend({ href: c }, D) }), a.isObject(b) && !a.isArray(b) && (b = a.extend({}, D, b)), a.isArray(b) && a.isObject(b[0]) && a.forEach(b, function (c) { b = a.extend(c, D) }), r(b), b) : void 0 } function t(a) { if (!a) return void (d && m.error("No stylesheets provided")); var b = "?cache="; -1 === a.href.indexOf(b) && (a.href = a.href + (a.bustCache ? b + (new Date).getTime() : "")) } function u(a, b) { return a && b ? l("filter")(a, function (a) { return a[b] }) : void (d && m.error("filterBy: missing array or property")) } function v(a) { return a ? (A[a.href] = h.matchMedia(a.media), B[a.href] = function (b) { i(function () { if (b.matches) e.stylesheets.push(a); else { var c = e.stylesheets.indexOf(l("filter")(e.stylesheets, { href: a.href })[0]); -1 !== c && e.stylesheets.splice(c, 1) } }) }, A[a.href].addListener(B[a.href]), void B[a.href](A[a.href])) : void (d && m.error("No stylesheet provided")) } function w(b) { return b ? void (e && a.isDefined(A) && A[b.href] && a.isDefined(B) && A[b.href].removeListener(B[b.href])) : void (d && m.error("No stylesheet provided")) } function x(a) { return a ? !(!a.media || -1 !== C.indexOf(a.media) || !h.matchMedia) : void (d && m.error("No stylesheet provided")) } var y = {}, z = '<link ng-repeat="stylesheet in stylesheets | orderBy: \'weight\' track by $index " rel="{{ stylesheet.rel }}" type="{{ stylesheet.type }}" ng-href="{{ stylesheet.href }}" ng-attr-media="{{ stylesheet.media }}">'; z = z.replace(/{{/g, n.startSymbol()).replace(/}}/g, n.endSymbol()); var A = {}, B = {}, C = ["print"], D = a.extend({}, b), E = a.element(document.querySelector ? document.querySelector(D.container) : document.getElementsByTagName(D.container)[0]), F = []; return a.forEach(c, function (a, b) { a.hasOwnProperty("css") && (c[b] = s(a.css)) }), e.stylesheets = [], E[D.method](j(z)(e)), e.$on("$directiveAdd", o), e.$on("$routeChangeSuccess", p), e.$on("$stateChangeSuccess", q), y.getFromRoute = function (b) { if (!b) return void (d && m.error("Get From Route: No route provided")); var c = null, e = []; return b.$$route && b.$$route.css ? c = b.$$route.css : b.css && (c = b.css), c && (a.isArray(c) ? a.forEach(c, function (b) { a.isFunction(b) && F.push(s(b)), e.push(s(b)) }) : (a.isFunction(c) && F.push(s(c)), e.push(s(c)))), e }, y.getFromRoutes = function (b) { if (!b) return void (d && m.error("Get From Routes: No routes provided")); var c = []; return a.forEach(b, function (a) { var b = y.getFromRoute(a); b.length && c.push(b[0]) }), c }, y.getFromState = function (b) { if (!b) return void (d && m.error("Get From State: No state provided")); var c = []; if (a.isDefined(b.views) && a.forEach(b.views, function (b) { b.css && (a.isFunction(b.css) && F.push(s(b.css)), c.push(s(b.css))) }), a.isDefined(b.children) && a.forEach(b.children, function (b) { b.css && (a.isFunction(b.css) && F.push(s(b.css)), c.push(s(b.css))), a.isDefined(b.children) && a.forEach(b.children, function (b) { b.css && (a.isFunction(b.css) && F.push(s(b.css)), c.push(s(b.css))) }) }), a.isDefined(b.css) || a.isDefined(b.data) && a.isDefined(b.data.css)) { var e = b.css || b.data.css; a.isArray(e) ? a.forEach(e, function (b) { a.isFunction(b) && F.push(s(b)), c.push(s(b)) }) : (a.isFunction(e) && F.push(s(e)), c.push(s(e))) } return c }, y.getFromStates = function (b) { if (!b) return void (d && m.error("Get From States: No states provided")); var c = []; return a.forEach(b, function (b) { var d = y.getFromState(b); a.isArray(d) ? a.forEach(d, function (a) { c.push(a) }) : c.push(d) }), c }, y.preload = function (b, e) { b || (b = [], c.length && Array.prototype.push.apply(b, c), f.has("$route") && Array.prototype.push.apply(b, y.getFromRoutes(f.get("$route").routes)), f.has("$state") && Array.prototype.push.apply(b, y.getFromStates(f.get("$state").get())), b = u(b, "preload")), a.isArray(b) || (b = [b]); var h = []; a.forEach(b, function (a, c) { a = b[c] = s(a), h.push(k.get(a.href).error(function (b) { d && m.error("AngularCSS: Incorrect path for " + a.href) })) }), a.isFunction(e) && g.all(h).then(function () { e(b) }) }, y.bind = function (b, c) { if (!b || !c) return void (d && m.error("No scope or stylesheets provided")); var e = []; a.isArray(b) ? a.forEach(b, function (a) { e.push(s(a)) }) : e.push(s(b)), y.add(e), d && m.debug("$css.bind(): Added", e), c.$on("$destroy", function () { y.remove(e), d && m.debug("$css.bind(): Removed", e) }) }, y.add = function (b, c) { return b ? (a.isArray(b) || (b = [b]), a.forEach(b, function (a) { a = s(a), a.href && !l("filter")(e.stylesheets, { href: a.href }).length && (t(a), x(a) ? v(a) : e.stylesheets.push(a), d && m.debug("$css.add(): " + a.href)) }), void e.$broadcast("$cssAdd", b, e.stylesheets)) : void (d && m.error("No stylesheets provided")) }, y.remove = function (b, c) { return b ? (a.isArray(b) || (b = [b]), b = l("filter")(b, function (a) { return !a.persist }), a.forEach(b, function (a) { a = s(a); var b = e.stylesheets.indexOf(l("filter")(e.stylesheets, { href: a.href })[0]); -1 !== b && e.stylesheets.splice(b, 1), w(a), d && m.debug("$css.remove(): " + a.href) }), void e.$broadcast("$cssRemove", b, e.stylesheets)) : void (d && m.error("No stylesheets provided")) }, y.removeAll = function () { e && e.hasOwnProperty("stylesheets") && (e.stylesheets.length = 0), d && m.debug("all stylesheets removed") }, y.preload(), y }] }]), b.filter("$cssLinks", function () { return function (b) { if (!b || !a.isArray(b)) return b; var c = ""; return a.forEach(b, function (a) { c += '<link rel="' + a.rel + '" type="' + a.type + '" href="' + a.href + '"', c += a.media ? ' media="' + a.media + '"' : "", c += ">\n\n" }), c } }), b.run(["$css", function (a) { }]); var c = [], d = a.module, e = function (a, b) { return a.reduce(function (a, c) { return a.push(b(c)), a }, []) }, f = function (a, b) { return a.indexOf(b) > -1 }; a.module = function () { var b = d.apply(this, arguments), g = b.directive; b.directive = function (b, d) { var h = a.isFunction(d) ? d : d[d ? d.length - 1 : 0]; try { var i = a.copy(h)(); i.directiveName = b, i.hasOwnProperty("css") && !f(e(c, function (a) { return a.ddo.directiveName }), b) && c.push({ ddo: i, handled: !1 }) } catch (j) { } return g.apply(this, arguments) }; var h = b.component; return b.component = function (a, b) { return b.directiveName = a, b.hasOwnProperty("css") && !f(e(c, function (a) { return a.ddo.directiveName }), a) && c.push({ ddo: b, handled: !1 }), h.apply(this, arguments) }, b.config(["$provide", "$injector", function (b, d) { a.forEach(c, function (a) { if (!a.handled) { var c = a.ddo, e = c.directiveName + "Directive"; d.has(e) && (a.handled = !0, b.decorator(e, ["$delegate", "$rootScope", "$timeout", function (a, b, d) { var e = a[0], f = e.compile; return e.css || (e.css = c.css), e.compile = function () { var a = f ? f.apply(this, arguments) : !1; return function (c) { var f = arguments; d(function () { a && a.apply(this, f) }), b.$broadcast("$directiveAdd", e, c) } }, a }])) } }) }]), b } }(angular);
/*
 * angular-gridster
 * http://manifestwebdesign.github.io/angular-gridster
 *
 * @version: 0.13.10
 * @license: MIT
 */
!function(a,b){"use strict";"function"==typeof define&&define.amd?define(["angular"],b):"object"==typeof exports?module.exports=b(require("angular")):b(a.angular)}(this,function(a){"use strict";return a.module("gridster",[]).constant("gridsterConfig",{columns:6,pushing:!0,floating:!0,swapping:!1,width:"auto",colWidth:"auto",rowHeight:"match",margins:[10,10],outerMargin:!0,isMobile:!1,mobileBreakPoint:600,mobileModeEnabled:!0,minColumns:1,minRows:1,maxRows:100,defaultSizeX:2,defaultSizeY:1,minSizeX:1,maxSizeX:null,minSizeY:1,maxSizeY:null,saveGridItemCalculatedHeightInMobile:!1,resizable:{enabled:!0,handles:["s","e","n","w","se","ne","sw","nw"]},draggable:{enabled:!0,scrollSensitivity:20,scrollSpeed:15}}).controller("GridsterCtrl",["gridsterConfig","$timeout",function(b,c){var d=this;a.extend(this,b),this.resizable=a.extend({},b.resizable||{}),this.draggable=a.extend({},b.draggable||{});var e=!1;this.layoutChanged=function(){e||(e=!0,c(function(){e=!1,d.loaded&&d.floatItemsUp(),d.updateHeight(d.movingItem?d.movingItem.sizeY:0)},30))},this.grid=[],this.destroy=function(){this.grid&&(this.grid=[]),this.$element=null},this.setOptions=function(b){if(b)if(b=a.extend({},b),b.draggable&&(a.extend(this.draggable,b.draggable),delete b.draggable),b.resizable&&(a.extend(this.resizable,b.resizable),delete b.resizable),a.extend(this,b),this.margins&&2===this.margins.length)for(var c=0,d=this.margins.length;c<d;++c)this.margins[c]=parseInt(this.margins[c],10),isNaN(this.margins[c])&&(this.margins[c]=0);else this.margins=[0,0]},this.canItemOccupy=function(a,b,c){return b>-1&&c>-1&&a.sizeX+c<=this.columns&&a.sizeY+b<=this.maxRows},this.autoSetItemPosition=function(a){for(var b=0;b<this.maxRows;++b)for(var c=0;c<this.columns;++c){var d=this.getItems(b,c,a.sizeX,a.sizeY,a);if(0===d.length&&this.canItemOccupy(a,b,c))return void this.putItem(a,b,c)}throw new Error("Unable to place item!")},this.getItems=function(a,b,c,d,e){var f=[];c&&d||(c=d=1),!e||e instanceof Array||(e=[e]);for(var g=0;g<d;++g)for(var h=0;h<c;++h){var i=this.getItem(a+g,b+h,e);!i||e&&e.indexOf(i)!==-1||f.indexOf(i)!==-1||f.push(i)}return f},this.getBoundingBox=function(a){if(0===a.length)return null;if(1===a.length)return{row:a[0].row,col:a[0].col,sizeY:a[0].sizeY,sizeX:a[0].sizeX};for(var b=0,c=0,d=9999,e=9999,f=0,g=a.length;f<g;++f){var h=a[f];d=Math.min(h.row,d),e=Math.min(h.col,e),b=Math.max(h.row+h.sizeY,b),c=Math.max(h.col+h.sizeX,c)}return{row:d,col:e,sizeY:b-d,sizeX:c-e}},this.removeItem=function(a){for(var b=0,c=this.grid.length;b<c;++b){var d=this.grid[b];if(d){var e=d.indexOf(a);if(e!==-1){d[e]=null;break}}}this.layoutChanged()},this.getItem=function(a,b,c){!c||c instanceof Array||(c=[c]);for(var d=1;a>-1;){for(var e=1,f=b;f>-1;){var g=this.grid[a];if(g){var h=g[f];if(h&&(!c||c.indexOf(h)===-1)&&h.sizeX>=e&&h.sizeY>=d)return h}++e,--f}--a,++d}return null},this.putItems=function(a){for(var b=0,c=a.length;b<c;++b)this.putItem(a[b])},this.putItem=function(a,b,c,d){if(("undefined"==typeof b||null===b)&&(b=a.row,c=a.col,"undefined"==typeof b||null===b))return void this.autoSetItemPosition(a);if(this.canItemOccupy(a,b,c)||(c=Math.min(this.columns-a.sizeX,Math.max(0,c)),b=Math.min(this.maxRows-a.sizeY,Math.max(0,b))),null!==a.oldRow&&"undefined"!=typeof a.oldRow){var e=a.oldRow===b&&a.oldColumn===c,f=this.grid[b]&&this.grid[b][c]===a;if(e&&f)return a.row=b,void(a.col=c);var g=this.grid[a.oldRow];g&&g[a.oldColumn]===a&&delete g[a.oldColumn]}a.oldRow=a.row=b,a.oldColumn=a.col=c,this.moveOverlappingItems(a,d),this.grid[b]||(this.grid[b]=[]),this.grid[b][c]=a,this.movingItem===a&&this.floatItemUp(a),this.layoutChanged()},this.swapItems=function(a,b){this.grid[a.row][a.col]=b,this.grid[b.row][b.col]=a;var c=a.row,d=a.col;a.row=b.row,a.col=b.col,b.row=c,b.col=d},this.moveOverlappingItems=function(a,b){b?b.indexOf(a)===-1&&(b=b.slice(0),b.push(a)):b=[a];var c=this.getItems(a.row,a.col,a.sizeX,a.sizeY,b);this.moveItemsDown(c,a.row+a.sizeY,b)},this.moveItemsDown=function(a,b,c){if(a&&0!==a.length){a.sort(function(a,b){return a.row-b.row}),c=c?c.slice(0):[];var d,e,f,g={};for(e=0,f=a.length;e<f;++e){d=a[e];var h=g[d.col];("undefined"==typeof h||d.row<h)&&(g[d.col]=d.row)}for(e=0,f=a.length;e<f;++e){d=a[e];var i=b-g[d.col];this.moveItemDown(d,d.row+i,c),c.push(d)}}},this.moveItemDown=function(a,b,c){if(!(a.row>=b)){for(;a.row<b;)++a.row,this.moveOverlappingItems(a,c);this.putItem(a,a.row,a.col,c)}},this.floatItemsUp=function(){if(this.floating!==!1)for(var a=0,b=this.grid.length;a<b;++a){var c=this.grid[a];if(c)for(var d=0,e=c.length;d<e;++d){var f=c[d];f&&this.floatItemUp(f)}}},this.floatItemUp=function(a){if(this.floating!==!1){for(var b=a.col,c=a.sizeY,d=a.sizeX,e=null,f=null,g=a.row-1;g>-1;){var h=this.getItems(g,b,d,c,a);if(0!==h.length)break;e=g,f=b,--g}null!==e&&this.putItem(a,e,f)}},this.updateHeight=function(a){var b=this.minRows;a=a||0;for(var c=this.grid.length;c>=0;--c){var d=this.grid[c];if(d)for(var e=0,f=d.length;e<f;++e)d[e]&&(b=Math.max(b,c+a+d[e].sizeY))}this.gridHeight=this.maxRows-b>0?Math.min(this.maxRows,b):Math.max(this.maxRows,b)},this.pixelsToRows=function(a,b){return this.outerMargin||(a+=this.margins[0]/2),b===!0?Math.ceil(a/this.curRowHeight):b===!1?Math.floor(a/this.curRowHeight):Math.round(a/this.curRowHeight)},this.pixelsToColumns=function(a,b){return this.outerMargin||(a+=this.margins[1]/2),b===!0?Math.ceil(a/this.curColWidth):b===!1?Math.floor(a/this.curColWidth):Math.round(a/this.curColWidth)}}]).directive("gridsterPreview",function(){return{replace:!0,scope:!0,require:"^gridster",template:'<div ng-style="previewStyle()" class="gridster-item gridster-preview-holder"></div>',link:function(a,b,c,d){a.previewStyle=function(){return d.movingItem?{display:"block",height:d.movingItem.sizeY*d.curRowHeight-d.margins[0]+"px",width:d.movingItem.sizeX*d.curColWidth-d.margins[1]+"px",top:d.movingItem.row*d.curRowHeight+(d.outerMargin?d.margins[0]:0)+"px",left:d.movingItem.col*d.curColWidth+(d.outerMargin?d.margins[1]:0)+"px"}:{display:"none"}}}}}).directive("gridster",["$timeout","$window","$rootScope","gridsterDebounce",function(b,c,d,e){return{scope:!0,restrict:"EAC",controller:"GridsterCtrl",controllerAs:"gridster",compile:function(f){return f.prepend('<div ng-if="gridster.movingItem" gridster-preview></div>'),function(f,g,h,i){function j(a){if(i.setOptions(a),l(g[0])){"auto"===i.width?i.curWidth=g[0].offsetWidth||parseInt(g.css("width"),10):i.curWidth=i.width,"auto"===i.colWidth?i.curColWidth=(i.curWidth+(i.outerMargin?-i.margins[1]:i.margins[1]))/i.columns:i.curColWidth=i.colWidth,i.curRowHeight=i.rowHeight,"string"==typeof i.rowHeight&&("match"===i.rowHeight?i.curRowHeight=Math.round(i.curColWidth):i.rowHeight.indexOf("*")!==-1?i.curRowHeight=Math.round(i.curColWidth*i.rowHeight.replace("*","").replace(" ","")):i.rowHeight.indexOf("/")!==-1&&(i.curRowHeight=Math.round(i.curColWidth/i.rowHeight.replace("/","").replace(" ","")))),i.isMobile=i.mobileModeEnabled&&i.curWidth<=i.mobileBreakPoint;for(var b=0,c=i.grid.length;b<c;++b){var d=i.grid[b];if(d)for(var e=0,f=d.length;e<f;++e)if(d[e]){var h=d[e];h.setElementPosition(),h.setElementSizeY(),h.setElementSizeX()}}k()}}function k(){g.css("height",i.gridHeight*i.curRowHeight+(i.outerMargin?i.margins[0]:-i.margins[0])+"px")}i.loaded=!1,i.$element=g,f.gridster=i,g.addClass("gridster");var l=function(a){return"hidden"!==a.style.visibility&&"none"!==a.style.display},m=h.gridster;m?f.$parent.$watch(m,function(a){j(a)},!0):j({}),f.$watch(function(){return i.loaded},function(){i.loaded?g.addClass("gridster-loaded"):g.removeClass("gridster-loaded")}),f.$watch(function(){return i.isMobile},function(){i.isMobile?g.addClass("gridster-mobile").removeClass("gridster-desktop"):g.removeClass("gridster-mobile").addClass("gridster-desktop"),d.$broadcast("gridster-mobile-changed",i)}),f.$watch(function(){return i.draggable},function(){d.$broadcast("gridster-draggable-changed",i)},!0),f.$watch(function(){return i.resizable},function(){d.$broadcast("gridster-resizable-changed",i)},!0),f.$watch(function(){return i.gridHeight},k),f.$watch(function(){return i.movingItem},function(){i.updateHeight(i.movingItem?i.movingItem.sizeY:0)});var n=g[0].offsetWidth||parseInt(g.css("width"),10),o=function(){var a=g[0].offsetWidth||parseInt(g.css("width"),10);a&&a!==n&&!i.movingItem&&(n=a,i.loaded&&g.removeClass("gridster-loaded"),j(),i.loaded&&g.addClass("gridster-loaded"),d.$broadcast("gridster-resized",[a,g[0].offsetHeight],i))},p=e(function(){o(),b(function(){f.$apply()})},100);f.$watch(function(){return l(g[0])},p),"function"==typeof window.addResizeListener?window.addResizeListener(g[0],p):f.$watch(function(){return g[0].offsetWidth||parseInt(g.css("width"),10)},o);var q=a.element(c);q.on("resize",p),f.$on("$destroy",function(){i.destroy(),q.off("resize",p),"function"==typeof window.removeResizeListener&&window.removeResizeListener(g[0],p)}),b(function(){f.$watch("gridster.floating",function(){i.floatItemsUp()}),i.loaded=!0},100)}}}}]).controller("GridsterItemCtrl",function(){this.$element=null,this.gridster=null,this.row=null,this.col=null,this.sizeX=null,this.sizeY=null,this.minSizeX=0,this.minSizeY=0,this.maxSizeX=null,this.maxSizeY=null,this.init=function(a,b){this.$element=a,this.gridster=b,this.sizeX=b.defaultSizeX,this.sizeY=b.defaultSizeY},this.destroy=function(){this.gridster=null,this.$element=null},this.toJSON=function(){return{row:this.row,col:this.col,sizeY:this.sizeY,sizeX:this.sizeX}},this.isMoving=function(){return this.gridster.movingItem===this},this.setPosition=function(a,b){this.gridster.putItem(this,a,b),this.isMoving()||this.setElementPosition()},this.setSize=function(a,b,c){a=a.toUpperCase();var d="size"+a,e="Size"+a;if(""!==b){b=parseInt(b,10),(isNaN(b)||0===b)&&(b=this.gridster["default"+e]);var f="X"===a?this.gridster.columns:this.gridster.maxRows;this["max"+e]&&(f=Math.min(this["max"+e],f)),this.gridster["max"+e]&&(f=Math.min(this.gridster["max"+e],f)),"X"===a&&this.cols?f-=this.cols:"Y"===a&&this.rows&&(f-=this.rows);var g=0;this["min"+e]&&(g=Math.max(this["min"+e],g)),this.gridster["min"+e]&&(g=Math.max(this.gridster["min"+e],g)),b=Math.max(Math.min(b,f),g);var h=this[d]!==b||this["old"+e]&&this["old"+e]!==b;return this["old"+e]=this[d]=b,this.isMoving()||this["setElement"+e](),!c&&h&&(this.gridster.moveOverlappingItems(this),this.gridster.layoutChanged()),h}},this.setSizeY=function(a,b){return this.setSize("Y",a,b)},this.setSizeX=function(a,b){return this.setSize("X",a,b)},this.setElementPosition=function(){this.gridster.isMobile?this.$element.css({marginLeft:this.gridster.margins[0]+"px",marginRight:this.gridster.margins[0]+"px",marginTop:this.gridster.margins[1]+"px",marginBottom:this.gridster.margins[1]+"px",top:"",left:""}):this.$element.css({margin:0,top:this.row*this.gridster.curRowHeight+(this.gridster.outerMargin?this.gridster.margins[0]:0)+"px",left:this.col*this.gridster.curColWidth+(this.gridster.outerMargin?this.gridster.margins[1]:0)+"px"})},this.setElementSizeY=function(){this.gridster.isMobile&&!this.gridster.saveGridItemCalculatedHeightInMobile?this.$element.css("height",""):this.$element.css("height",this.sizeY*this.gridster.curRowHeight-this.gridster.margins[0]+"px")},this.setElementSizeX=function(){this.gridster.isMobile?this.$element.css("width",""):this.$element.css("width",this.sizeX*this.gridster.curColWidth-this.gridster.margins[1]+"px")},this.getElementSizeX=function(){return this.sizeX*this.gridster.curColWidth-this.gridster.margins[1]},this.getElementSizeY=function(){return this.sizeY*this.gridster.curRowHeight-this.gridster.margins[0]}}).factory("GridsterTouch",[function(){return function(a,b,c,d){var e,f,g={},h=function(a){if(Object.keys)return Object.keys(a).length;var b,c=0;for(b in a)++c;return c},i=function(a){for(var b=0,c=0,d=navigator.userAgent.match(/\bMSIE\b/),e=a;null!=e;e=e.offsetParent)d&&(!document.documentMode||document.documentMode<8)&&"relative"===e.currentStyle.position&&e.offsetParent&&"relative"===e.offsetParent.currentStyle.position&&e.offsetLeft===e.offsetParent.offsetLeft?c+=e.offsetTop:(b+=e.offsetLeft,c+=e.offsetTop);return{x:b,y:c}},j=i(a),k=function(e){if("mousemove"!==e.type||0!==h(g)){for(var f=!0,m=e.changedTouches?e.changedTouches:[e],n=0;n<m.length;++n){var o=m[n],p="undefined"!=typeof o.identifier?o.identifier:"undefined"!=typeof o.pointerId?o.pointerId:1;if("undefined"==typeof o.pageX)if(o.pageX=o.offsetX+j.x,o.pageY=o.offsetY+j.y,o.srcElement.offsetParent===a&&document.documentMode&&8===document.documentMode&&"mousedown"===o.type)o.pageX+=o.srcElement.offsetLeft,o.pageY+=o.srcElement.offsetTop;else if(o.srcElement!==a&&!document.documentMode||document.documentMode<8){for(var q=-2,r=-2,s=o.srcElement;null!==s;s=s.parentNode)q+=s.scrollLeft?s.scrollLeft:0,r+=s.scrollTop?s.scrollTop:0;o.pageX=o.clientX+q,o.pageY=o.clientY+r}var t=o.pageX,u=o.pageY;e.type.match(/(start|down)$/i)?(j=i(a),g[p]&&(d&&d({target:e.target,which:e.which,pointerId:p,pageX:t,pageY:u}),delete g[p]),b&&f&&(f=b({target:e.target,which:e.which,pointerId:p,pageX:t,pageY:u})),g[p]={x:t,y:u},a.msSetPointerCapture?a.msSetPointerCapture(p):"mousedown"===e.type&&1===h(g)&&(l?a.setCapture(!0):(document.addEventListener("mousemove",k,!1),document.addEventListener("mouseup",k,!1)))):e.type.match(/move$/i)?!g[p]||g[p].x===t&&g[p].y===u||(c&&f&&(f=c({target:e.target,which:e.which,pointerId:p,pageX:t,pageY:u})),g[p].x=t,g[p].y=u):g[p]&&e.type.match(/(up|end|cancel)$/i)&&(d&&f&&(f=d({target:e.target,which:e.which,pointerId:p,pageX:t,pageY:u})),delete g[p],a.msReleasePointerCapture?a.msReleasePointerCapture(p):"mouseup"===e.type&&0===h(g)&&(l?a.releaseCapture():(document.removeEventListener("mousemove",k,!1),document.removeEventListener("mouseup",k,!1))))}f&&(e.preventDefault&&e.preventDefault(),e.preventManipulation&&e.preventManipulation(),e.preventMouseEvent&&e.preventMouseEvent())}},l=!1;return this.enable=function(){window.navigator.msPointerEnabled?(a.addEventListener("MSPointerDown",k,!1),a.addEventListener("MSPointerMove",k,!1),a.addEventListener("MSPointerUp",k,!1),a.addEventListener("MSPointerCancel",k,!1),"undefined"!=typeof a.style.msContentZooming&&(e=a.style.msContentZooming,a.style.msContentZooming="none"),"undefined"!=typeof a.style.msTouchAction&&(f=a.style.msTouchAction,a.style.msTouchAction="none")):a.addEventListener?(a.addEventListener("touchstart",k,!1),a.addEventListener("touchmove",k,!1),a.addEventListener("touchend",k,!1),a.addEventListener("touchcancel",k,!1),a.addEventListener("mousedown",k,!1),a.setCapture&&!window.navigator.userAgent.match(/\bGecko\b/)&&(l=!0,a.addEventListener("mousemove",k,!1),a.addEventListener("mouseup",k,!1))):a.attachEvent&&a.setCapture&&(l=!0,a.attachEvent("onmousedown",function(){return k(window.event),window.event.returnValue=!1,!1}),a.attachEvent("onmousemove",function(){return k(window.event),window.event.returnValue=!1,!1}),a.attachEvent("onmouseup",function(){return k(window.event),window.event.returnValue=!1,!1}))},this.disable=function(){window.navigator.msPointerEnabled?(a.removeEventListener("MSPointerDown",k,!1),a.removeEventListener("MSPointerMove",k,!1),a.removeEventListener("MSPointerUp",k,!1),a.removeEventListener("MSPointerCancel",k,!1),e&&(a.style.msContentZooming=e),f&&(a.style.msTouchAction=f)):a.removeEventListener?(a.removeEventListener("touchstart",k,!1),a.removeEventListener("touchmove",k,!1),a.removeEventListener("touchend",k,!1),a.removeEventListener("touchcancel",k,!1),a.removeEventListener("mousedown",k,!1),a.setCapture&&!window.navigator.userAgent.match(/\bGecko\b/)&&(l=!0,a.removeEventListener("mousemove",k,!1),a.removeEventListener("mouseup",k,!1))):a.detachEvent&&a.setCapture&&(l=!0,a.detachEvent("onmousedown"),a.detachEvent("onmousemove"),a.detachEvent("onmouseup"))},this}}]).factory("GridsterDraggable",["$document","$window","GridsterTouch",function(b,c,d){function e(e,f,g,h,i){function j(b){if(E.indexOf(b.target.nodeName.toLowerCase())!==-1)return!1;var c=a.element(b.target);if(c.hasClass("gridster-item-resizable-handler"))return!1;if(c.attr("onclick")||c.attr("ng-click"))return!1;if(c.closest&&c.closest(".gridster-no-drag").length)return!1;if(g.draggable&&g.draggable.handle){var d=a.element(e[0].querySelectorAll(g.draggable.handle)),f=!1;a:for(var i=0,j=d.length;i<j;++i){var k=d[i];if(k===b.target){f=!0;break}for(var l=b.target,n=0;n<20;++n){var o=l.parentNode;if(o===e[0])break;if(o===k){f=!0;break a}l=o}}if(!f)return!1}switch(b.which){case 1:break;case 2:case 3:return}return x=b.pageX,y=b.pageY,p=parseInt(e.css("left"),10),q=parseInt(e.css("top"),10),r=e[0].offsetWidth,s=e[0].offsetHeight,t=h.col,u=h.row,m(b),!0}function k(a){if(!e.hasClass("gridster-item-moving")||e.hasClass("gridster-item-resizing"))return!1;var b=g.curWidth-1,c=g.curRowHeight*g.maxRows-1;v=a.pageX,w=a.pageY;var d=v-x+z,f=w-y+A;z=A=0,x=v,y=w;var h=d,i=f;return p+h<C?(d=C-p,z=h-d):p+r+h>b&&(d=b-p-r,z=h-d),q+i<B?(f=B-q,A=i-f):q+s+i>c&&(f=c-q-s,A=i-f),p+=d,q+=f,e.css({top:q+"px",left:p+"px"}),n(a),!0}function l(a){return!(!e.hasClass("gridster-item-moving")||e.hasClass("gridster-item-resizing"))&&(z=A=0,o(a),!0)}function m(a){e.addClass("gridster-item-moving"),g.movingItem=h,g.updateHeight(h.sizeY),f.$apply(function(){g.draggable&&g.draggable.start&&g.draggable.start(a,e,i)})}function n(a){var b=h.row,d=h.col,j=g.draggable&&g.draggable.drag,k=g.draggable.scrollSensitivity,l=g.draggable.scrollSpeed,m=Math.min(g.pixelsToRows(q),g.maxRows-1),n=Math.min(g.pixelsToColumns(p),g.columns-1),o=g.getItems(m,n,h.sizeX,h.sizeY,h),r=0!==o.length;if(g.swapping===!0&&r){var s=g.getBoundingBox(o),t=s.sizeX===h.sizeX&&s.sizeY===h.sizeY,u=s.row===b,v=s.col===d,w=s.row===m&&s.col===n,x=u||v;if(t&&1===o.length){if(w)g.swapItems(h,o[0]);else if(x)return}else if(s.sizeX<=h.sizeX&&s.sizeY<=h.sizeY&&x)for(var y=h.row<=m?h.row:m+h.sizeY,z=h.col<=n?h.col:n+h.sizeX,A=y-s.row,B=z-s.col,C=0,E=o.length;C<E;++C){var F=o[C],G=g.getItems(F.row+A,F.col+B,F.sizeX,F.sizeY,h);0===G.length&&g.putItem(F,F.row+A,F.col+B)}}g.pushing===!1&&r||(h.row=m,h.col=n),a.pageY-D.body.scrollTop<k?D.body.scrollTop=D.body.scrollTop-l:c.innerHeight-(a.pageY-D.body.scrollTop)<k&&(D.body.scrollTop=D.body.scrollTop+l),a.pageX-D.body.scrollLeft<k?D.body.scrollLeft=D.body.scrollLeft-l:c.innerWidth-(a.pageX-D.body.scrollLeft)<k&&(D.body.scrollLeft=D.body.scrollLeft+l),(j||b!==h.row||d!==h.col)&&f.$apply(function(){j&&g.draggable.drag(a,e,i)})}function o(a){e.removeClass("gridster-item-moving");var b=Math.min(g.pixelsToRows(q),g.maxRows-1),c=Math.min(g.pixelsToColumns(p),g.columns-1);g.pushing===!1&&0!==g.getItems(b,c,h.sizeX,h.sizeY,h).length||(h.row=b,h.col=c),g.movingItem=null,h.setPosition(h.row,h.col),f.$apply(function(){g.draggable&&g.draggable.stop&&g.draggable.stop(a,e,i)})}var p,q,r,s,t,u,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=b[0],E=["select","option","input","textarea","button"],F=null,G=null;this.enable=function(){if(F!==!0){if(F=!0,G)return void G.enable();G=new d(e[0],j,k,l),G.enable()}},this.disable=function(){F!==!1&&(F=!1,G&&G.disable())},this.toggle=function(a){a?this.enable():this.disable()},this.destroy=function(){this.disable()}}return e}]).factory("GridsterResizable",["GridsterTouch",function(b){function c(c,d,e,f,g){function h(h){function i(a){switch(a.which){case 1:break;case 2:case 3:return}return u=e.draggable.enabled,u&&(e.draggable.enabled=!1,d.$broadcast("gridster-draggable-changed",e)),z=a.pageX,A=a.pageY,o=parseInt(c.css("left"),10),p=parseInt(c.css("top"),10),q=c[0].offsetWidth,r=c[0].offsetHeight,s=f.sizeX,t=f.sizeY,j(a),!0}function j(a){c.addClass("gridster-item-moving"),c.addClass("gridster-item-resizing"),e.movingItem=f,f.setElementSizeX(),f.setElementSizeY(),f.setElementPosition(),e.updateHeight(1),d.$apply(function(){e.resizable&&e.resizable.start&&e.resizable.start(a,c,g)})}function k(a){var b=e.curWidth-1;x=a.pageX,y=a.pageY;var d=x-z+B,f=y-A+C;B=C=0,z=x,A=y;var g=f,h=d;return w.indexOf("n")>=0&&(r-g<G()?(f=r-G(),C=g-f):p+g<D&&(f=D-p,C=g-f),p+=f,r-=f),w.indexOf("s")>=0&&(r+g<G()?(f=G()-r,C=g-f):p+r+g>E&&(f=E-p-r,C=g-f),r+=f),w.indexOf("w")>=0&&(q-h<H()?(d=q-H(),B=h-d):o+h<F&&(d=F-o,B=h-d),o+=d,q-=d),w.indexOf("e")>=0&&(q+h<H()?(d=H()-q,B=h-d):o+q+h>b&&(d=b-o-q,B=h-d),q+=d),c.css({top:p+"px",left:o+"px",width:q+"px",height:r+"px"}),m(a),!0}function l(a){return e.draggable.enabled!==u&&(e.draggable.enabled=u,d.$broadcast("gridster-draggable-changed",e)),B=C=0,n(a),!0}function m(a){var b=f.row,i=f.col,j=f.sizeX,k=f.sizeY,l=e.resizable&&e.resizable.resize,m=f.col;["w","nw","sw"].indexOf(h)!==-1&&(m=e.pixelsToColumns(o,!1));var n=f.row;["n","ne","nw"].indexOf(h)!==-1&&(n=e.pixelsToRows(p,!1));var s=f.sizeX;["n","s"].indexOf(h)===-1&&(s=e.pixelsToColumns(q,!0));var t=f.sizeY;["e","w"].indexOf(h)===-1&&(t=e.pixelsToRows(r,!0));var u=n>-1&&m>-1&&s+m<=e.columns&&t+n<=e.maxRows;!u||e.pushing===!1&&0!==e.getItems(n,m,s,t,f).length||(f.row=n,f.col=m,f.sizeX=s,f.sizeY=t);var v=f.row!==b||f.col!==i||f.sizeX!==j||f.sizeY!==k;(l||v)&&d.$apply(function(){l&&e.resizable.resize(a,c,g)})}function n(a){c.removeClass("gridster-item-moving"),c.removeClass("gridster-item-resizing"),e.movingItem=null,f.setPosition(f.row,f.col),f.setSizeY(f.sizeY),f.setSizeX(f.sizeX),d.$apply(function(){e.resizable&&e.resizable.stop&&e.resizable.stop(a,c,g)})}var o,p,q,r,s,t,u,v,w=h,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=9999,F=0,G=function(){return(f.minSizeY?f.minSizeY:1)*e.curRowHeight-e.margins[0]},H=function(){return(f.minSizeX?f.minSizeX:1)*e.curColWidth-e.margins[1]},I=null;this.enable=function(){I||(I=a.element('<div class="gridster-item-resizable-handler handle-'+w+'"></div>'),c.append(I)),v=new b(I[0],i,k,l),v.enable()},this.disable=function(){I&&(I.remove(),I=null),v.disable(),v=void 0},this.destroy=function(){this.disable()}}var i=[],j=e.resizable.handles;"string"==typeof j&&(j=e.resizable.handles.split(","));for(var k=!1,l=0,m=j.length;l<m;l++)i.push(new h(j[l]));this.enable=function(){if(!k){for(var a=0,b=i.length;a<b;a++)i[a].enable();k=!0}},this.disable=function(){if(k){for(var a=0,b=i.length;a<b;a++)i[a].disable();k=!1}},this.toggle=function(a){a?this.enable():this.disable()},this.destroy=function(){for(var a=0,b=i.length;a<b;a++)i[a].destroy()}}return c}]).factory("gridsterDebounce",function(){return function(a,b,c){var d;return function(){var e=this,f=arguments,g=function(){d=null,c||a.apply(e,f)},h=c&&!d;clearTimeout(d),d=setTimeout(g,b),h&&a.apply(e,f)}}}).directive("gridsterItem",["$parse","GridsterDraggable","GridsterResizable","gridsterDebounce",function(a,b,c,d){return{scope:!0,restrict:"EA",controller:"GridsterItemCtrl",controllerAs:"gridsterItem",require:["^gridster","gridsterItem"],link:function(e,f,g,h){function i(){o.setPosition(o.row,o.col),r.row&&r.row.assign&&r.row.assign(e,o.row),r.col&&r.col.assign&&r.col.assign(e,o.col)}function j(){var a=o.setSizeX(o.sizeX,!0);a&&r.sizeX&&r.sizeX.assign&&r.sizeX.assign(e,o.sizeX);var b=o.setSizeY(o.sizeY,!0);b&&r.sizeY&&r.sizeY.assign&&r.sizeY.assign(e,o.sizeY),(a||b)&&(o.gridster.moveOverlappingItems(o),n.layoutChanged(),e.$broadcast("gridster-item-resized",o))}function k(){var a=document.createElement("div"),b={transition:"transitionend",OTransition:"oTransitionEnd",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(var c in b)if(void 0!==a.style[c])return b[c]}var l,m=g.gridsterItem,n=h[0],o=h[1];if(e.gridster=n,m){var p=a(m);l=p(e)||{},!l&&p.assign&&(l={row:o.row,col:o.col,sizeX:o.sizeX,sizeY:o.sizeY,minSizeX:0,minSizeY:0,maxSizeX:null,maxSizeY:null},p.assign(e,l))}else l=g;o.init(f,n),f.addClass("gridster-item");for(var q=["minSizeX","maxSizeX","minSizeY","maxSizeY","sizeX","sizeY","row","col"],r={},s=[],t=function(b){var c;if("string"==typeof l[b])c=l[b];else if("string"==typeof l[b.toLowerCase()])c=l[b.toLowerCase()];else{if(!m)return;c=m+"."+b}s.push('"'+b+'":'+c),r[b]=a(c);var d=r[b](e);"number"==typeof d&&(o[b]=d)},u=0,v=q.length;u<v;++u)t(q[u]);var w="{"+s.join(",")+"}";e.$watchCollection(w,function(a,b){for(var c in a){var d=a[c],e=b[c];e!==d&&(d=parseInt(d,10),isNaN(d)||(o[c]=d))}}),e.$watch(function(){return o.row+","+o.col},i),e.$watch(function(){return o.sizeY+","+o.sizeX+","+o.minSizeX+","+o.maxSizeX+","+o.minSizeY+","+o.maxSizeY},j);var x=new b(f,e,n,o,l),y=new c(f,e,n,o,l),z=function(){y.toggle(!n.isMobile&&n.resizable&&n.resizable.enabled)};z();var A=function(){x.toggle(!n.isMobile&&n.draggable&&n.draggable.enabled)};A(),e.$on("gridster-draggable-changed",A),e.$on("gridster-resizable-changed",z),e.$on("gridster-resized",z),e.$on("gridster-mobile-changed",function(){z(),A()});var B=d(function(){e.$apply(function(){e.$broadcast("gridster-item-transition-end",o)})},50);return f.on(k(),B),e.$broadcast("gridster-item-initialized",o),e.$on("$destroy",function(){try{y.destroy(),x.destroy()}catch(a){}try{n.removeItem(o)}catch(a){}try{o.destroy()}catch(a){}})}}}]).directive("gridsterNoDrag",function(){return{restrict:"A",link:function(a,b){b.addClass("gridster-no-drag")}}})});
// ==ClosureCompiler==
// @compilation_level SIMPLE_OPTIMIZATIONS

/**
 * @license Highcharts JS v4.2.6 (2016-08-02)
 *
 * (c) 2009-2016 Torstein Honsi
 *
 * License: www.highcharts.com/license
 */

(function (root, factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = root.document ?
            factory(root) : 
            factory;
    } else {
        root.Highcharts = factory(root);
    }
}(typeof window !== 'undefined' ? window : this, function (win) { // eslint-disable-line no-undef
// encapsulated variables
    var UNDEFINED,
        doc = win.document,
        math = Math,
        mathRound = math.round,
        mathFloor = math.floor,
        mathCeil = math.ceil,
        mathMax = math.max,
        mathMin = math.min,
        mathAbs = math.abs,
        mathCos = math.cos,
        mathSin = math.sin,
        mathPI = math.PI,
        deg2rad = mathPI * 2 / 360,


        // some variables
        userAgent = (win.navigator && win.navigator.userAgent) || '',
        isOpera = win.opera,
        isMS = /(msie|trident|edge)/i.test(userAgent) && !isOpera,
        docMode8 = doc && doc.documentMode === 8,
        isWebKit = !isMS && /AppleWebKit/.test(userAgent),
        isFirefox = /Firefox/.test(userAgent),
        isTouchDevice = /(Mobile|Android|Windows Phone)/.test(userAgent),
        SVG_NS = 'http://www.w3.org/2000/svg',
        hasSVG = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,
        hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4, // issue #38
        useCanVG = doc && !hasSVG && !isMS && !!doc.createElement('canvas').getContext,
        Renderer,
        hasTouch,
        symbolSizes = {},
        idCounter = 0,
        garbageBin,
        defaultOptions,
        dateFormat, // function
        pathAnim,
        timeUnits,
        noop = function () {},
        charts = [],
        chartCount = 0,
        PRODUCT = 'Highcharts',
        VERSION = '4.2.6',

        // some constants for frequently used strings
        DIV = 'div',
        ABSOLUTE = 'absolute',
        RELATIVE = 'relative',
        HIDDEN = 'hidden',
        PREFIX = 'highcharts-',
        VISIBLE = 'visible',
        PX = 'px',
        NONE = 'none',
        M = 'M',
        L = 'L',
        numRegex = /^[0-9]+$/,
        NORMAL_STATE = '',
        HOVER_STATE = 'hover',
        SELECT_STATE = 'select',
        marginNames = ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],

        // Object for extending Axis
        AxisPlotLineOrBandExtension,

        // constants for attributes
        STROKE_WIDTH = 'stroke-width',

        // time methods, changed based on whether or not UTC is used
        Date,  // Allow using a different Date class
        makeTime,
        timezoneOffset,
        getTimezoneOffset,
        getMinutes,
        getHours,
        getDay,
        getDate,
        getMonth,
        getFullYear,
        setMilliseconds,
        setSeconds,
        setMinutes,
        setHours,
        setDate,
        setMonth,
        setFullYear,


        // lookup over the types and the associated classes
        seriesTypes = {},
        Highcharts;

    /**
     * Provide error messages for debugging, with links to online explanation
     */
    function error(code, stop) {
        var msg = 'Highcharts error #' + code + ': www.highcharts.com/errors/' + code;
        if (stop) {
            throw new Error(msg);
        }
        // else ...
        if (win.console) {
            console.log(msg); // eslint-disable-line no-console
        }
    }

    // The Highcharts namespace
    Highcharts = win.Highcharts ? error(16, true) : { win: win };

    Highcharts.seriesTypes = seriesTypes;
    var timers = [],
        getStyle,

        // Previous adapter functions
        inArray,
        each,
        grep,
        offset,
        map,
        addEvent,
        removeEvent,
        fireEvent,
        animate,
        stop;

    /**
     * An animator object. One instance applies to one property (attribute or style prop) 
     * on one element.
     * 
     * @param {object} elem    The element to animate. May be a DOM element or a Highcharts SVGElement wrapper.
     * @param {object} options Animation options, including duration, easing, step and complete.
     * @param {object} prop    The property to animate.
     */
    function Fx(elem, options, prop) {
        this.options = options;
        this.elem = elem;
        this.prop = prop;
    }
    Fx.prototype = {
    
        /**
         * Animating a path definition on SVGElement
         * @returns {undefined} 
         */
        dSetter: function () {
            var start = this.paths[0],
                end = this.paths[1],
                ret = [],
                now = this.now,
                i = start.length,
                startVal;

            if (now === 1) { // land on the final path without adjustment points appended in the ends
                ret = this.toD;

            } else if (i === end.length && now < 1) {
                while (i--) {
                    startVal = parseFloat(start[i]);
                    ret[i] =
                        isNaN(startVal) ? // a letter instruction like M or L
                                start[i] :
                                now * (parseFloat(end[i] - startVal)) + startVal;

                }
            } else { // if animation is finished or length not matching, land on right value
                ret = end;
            }
            this.elem.attr('d', ret);
        },

        /**
         * Update the element with the current animation step
         * @returns {undefined}
         */
        update: function () {
            var elem = this.elem,
                prop = this.prop, // if destroyed, it is null
                now = this.now,
                step = this.options.step;

            // Animation setter defined from outside
            if (this[prop + 'Setter']) {
                this[prop + 'Setter']();

            // Other animations on SVGElement
            } else if (elem.attr) {
                if (elem.element) {
                    elem.attr(prop, now);
                }

            // HTML styles, raw HTML content like container size
            } else {
                elem.style[prop] = now + this.unit;
            }
        
            if (step) {
                step.call(elem, now, this);
            }

        },

        /**
         * Run an animation
         */
        run: function (from, to, unit) {
            var self = this,
                timer = function (gotoEnd) {
                    return timer.stopped ? false : self.step(gotoEnd);
                },
                i;

            this.startTime = +new Date();
            this.start = from;
            this.end = to;
            this.unit = unit;
            this.now = this.start;
            this.pos = 0;

            timer.elem = this.elem;

            if (timer() && timers.push(timer) === 1) {
                timer.timerId = setInterval(function () {
                
                    for (i = 0; i < timers.length; i++) {
                        if (!timers[i]()) {
                            timers.splice(i--, 1);
                        }
                    }

                    if (!timers.length) {
                        clearInterval(timer.timerId);
                    }
                }, 13);
            }
        },
    
        /**
         * Run a single step in the animation
         * @param   {Boolean} gotoEnd Whether to go to then endpoint of the animation after abort
         * @returns {Boolean} True if animation continues
         */
        step: function (gotoEnd) {
            var t = +new Date(),
                ret,
                done,
                options = this.options,
                elem = this.elem,
                complete = options.complete,
                duration = options.duration,
                curAnim = options.curAnim,
                i;
        
            if (elem.attr && !elem.element) { // #2616, element including flag is destroyed
                ret = false;

            } else if (gotoEnd || t >= duration + this.startTime) {
                this.now = this.end;
                this.pos = 1;
                this.update();

                curAnim[this.prop] = true;

                done = true;
                for (i in curAnim) {
                    if (curAnim[i] !== true) {
                        done = false;
                    }
                }

                if (done && complete) {
                    complete.call(elem);
                }
                ret = false;

            } else {
                this.pos = options.easing((t - this.startTime) / duration);
                this.now = this.start + ((this.end - this.start) * this.pos);
                this.update();
                ret = true;
            }
            return ret;
        },

        /**
         * Prepare start and end values so that the path can be animated one to one
         */
        initPath: function (elem, fromD, toD) {
            fromD = fromD || '';
            var shift,
                startX = elem.startX,
                endX = elem.endX,
                bezier = fromD.indexOf('C') > -1,
                numParams = bezier ? 7 : 3,
                fullLength,
                slice,
                i,
                start = fromD.split(' '),
                end = toD.slice(), // copy
                isArea = elem.isArea,
                positionFactor = isArea ? 2 : 1,
                reverse;
        
            /**
             * In splines make move points have six parameters like bezier curves
             */
            function sixify(arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i] === M || arr[i] === L) {
                        arr.splice(i + 1, 0, arr[i + 1], arr[i + 2], arr[i + 1], arr[i + 2]);
                    }
                }
            }

            /**
             * Insert an array at the given position of another array
             */
            function insertSlice(arr, subArr, index) {
                [].splice.apply(
                    arr,
                    [index, 0].concat(subArr)
                );
            }

            /**
             * If shifting points, prepend a dummy point to the end path. 
             */
            function prepend(arr, other) {
                while (arr.length < fullLength) {
                
                    // Move to, line to or curve to?
                    arr[0] = other[fullLength - arr.length];

                    // Prepend a copy of the first point
                    insertSlice(arr, arr.slice(0, numParams), 0);

                    // For areas, the bottom path goes back again to the left, so we need
                    // to append a copy of the last point.
                    if (isArea) {
                        insertSlice(arr, arr.slice(arr.length - numParams), arr.length);
                        i--;
                    }
                }
                arr[0] = 'M';
            }

            /**
             * Copy and append last point until the length matches the end length
             */
            function append(arr, other) {
                var i = (fullLength - arr.length) / numParams;
                while (i > 0 && i--) {

                    // Pull out the slice that is going to be appended or inserted. In a line graph,
                    // the positionFactor is 1, and the last point is sliced out. In an area graph,
                    // the positionFactor is 2, causing the middle two points to be sliced out, since
                    // an area path starts at left, follows the upper path then turns and follows the
                    // bottom back. 
                    slice = arr.slice().splice(
                        (arr.length / positionFactor) - numParams, 
                        numParams * positionFactor
                    );

                    // Move to, line to or curve to?
                    slice[0] = other[fullLength - numParams - (i * numParams)];
                
                    // Disable first control point
                    if (bezier) {
                        slice[numParams - 6] = slice[numParams - 2];
                        slice[numParams - 5] = slice[numParams - 1];
                    }
                
                    // Now insert the slice, either in the middle (for areas) or at the end (for lines)
                    insertSlice(arr, slice, arr.length / positionFactor);

                    if (isArea) {
                        i--;
                    }
                }
            }

            if (bezier) {
                sixify(start);
                sixify(end);
            }

            // For sideways animation, find out how much we need to shift to get the start path Xs
            // to match the end path Xs.
            if (startX && endX) {
                for (i = 0; i < startX.length; i++) {
                    if (startX[i] === endX[0]) { // Moving left, new points coming in on right
                        shift = i;
                        break;
                    } else if (startX[0] === endX[endX.length - startX.length + i]) { // Moving right
                        shift = i;
                        reverse = true;
                        break;
                    }
                }
                if (shift === undefined) {
                    start = [];
                }
            }

            if (start.length && Highcharts.isNumber(shift)) {

                // The common target length for the start and end array, where both 
                // arrays are padded in opposite ends
                fullLength = end.length + shift * positionFactor * numParams;
            
                if (!reverse) {
                    prepend(end, start);
                    append(start, end);
                } else {
                    prepend(start, end);
                    append(end, start);
                }
            }

            return [start, end];
        }
    }; // End of Fx prototype


    /**
     * Extend an object with the members of another
     * @param {Object} a The object to be extended
     * @param {Object} b The object to add to the first one
     */
    var extend = Highcharts.extend = function (a, b) {
        var n;
        if (!a) {
            a = {};
        }
        for (n in b) {
            a[n] = b[n];
        }
        return a;
    };

    /**
     * Deep merge two or more objects and return a third object. If the first argument is
     * true, the contents of the second object is copied into the first object.
     * Previously this function redirected to jQuery.extend(true), but this had two limitations.
     * First, it deep merged arrays, which lead to workarounds in Highcharts. Second,
     * it copied properties from extended prototypes.
     */
    function merge() {
        var i,
            args = arguments,
            len,
            ret = {},
            doCopy = function (copy, original) {
                var value, key;

                // An object is replacing a primitive
                if (typeof copy !== 'object') {
                    copy = {};
                }

                for (key in original) {
                    if (original.hasOwnProperty(key)) {
                        value = original[key];

                        // Copy the contents of objects, but not arrays or DOM nodes
                        if (value && typeof value === 'object' && Object.prototype.toString.call(value) !== '[object Array]' &&
                                key !== 'renderTo' && typeof value.nodeType !== 'number') {
                            copy[key] = doCopy(copy[key] || {}, value);

                        // Primitives and arrays are copied over directly
                        } else {
                            copy[key] = original[key];
                        }
                    }
                }
                return copy;
            };

        // If first argument is true, copy into the existing object. Used in setOptions.
        if (args[0] === true) {
            ret = args[1];
            args = Array.prototype.slice.call(args, 2);
        }

        // For each argument, extend the return
        len = args.length;
        for (i = 0; i < len; i++) {
            ret = doCopy(ret, args[i]);
        }

        return ret;
    }

    /**
     * Shortcut for parseInt
     * @param {Object} s
     * @param {Number} mag Magnitude
     */
    function pInt(s, mag) {
        return parseInt(s, mag || 10);
    }

    /**
     * Check for string
     * @param {Object} s
     */
    function isString(s) {
        return typeof s === 'string';
    }

    /**
     * Check for array
     * @param {Object} obj
     */
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    }

    /**
     * Check for object
     * @param {Object} obj
     * @param {Boolean} strict Also checks that the object is not an array
     */
    var isObject = Highcharts.isObject = function (obj, strict) {
        //debugger;
        return obj && typeof obj === 'object' && (!strict || !isArray(obj));
    };

    /**
     * Check for number
     * @param {Object} n
     */
    var isNumber = Highcharts.isNumber = function isNumber(n) {
        return typeof n === 'number' && !isNaN(n);
    };

    /**
     * Remove last occurence of an item from an array
     * @param {Array} arr
     * @param {Mixed} item
     */
    function erase(arr, item) {
        var i = arr.length;
        while (i--) {
            if (arr[i] === item) {
                arr.splice(i, 1);
                break;
            }
        }
        //return arr;
    }

    /**
     * Returns true if the object is not null or undefined.
     * @param {Object} obj
     */
    function defined(obj) {
        return obj !== UNDEFINED && obj !== null;
    }

    /**
     * Set or get an attribute or an object of attributes. Can't use jQuery attr because
     * it attempts to set expando properties on the SVG element, which is not allowed.
     *
     * @param {Object} elem The DOM element to receive the attribute(s)
     * @param {String|Object} prop The property or an abject of key-value pairs
     * @param {String} value The value if a single property is set
     */
    function attr(elem, prop, value) {
        var key,
            ret;

        // if the prop is a string
        if (isString(prop)) {
            // set the value
            if (defined(value)) {
                elem.setAttribute(prop, value);

            // get the value
            } else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                ret = elem.getAttribute(prop);
            }

        // else if prop is defined, it is a hash of key/value pairs
        } else if (defined(prop) && isObject(prop)) {
            for (key in prop) {
                elem.setAttribute(key, prop[key]);
            }
        }
        return ret;
    }
    /**
     * Check if an element is an array, and if not, make it into an array.
     */
    function splat(obj) {
        return isArray(obj) ? obj : [obj];
    }

    /**
     * Set a timeout if the delay is given, otherwise perform the function synchronously
     * @param   {Function} fn      The function to perform
     * @param   {Number}   delay   Delay in milliseconds
     * @param   {Ojbect}   context The context
     * @returns {Nubmer}           An identifier for the timeout
     */
    function syncTimeout(fn, delay, context) {
        if (delay) {
            return setTimeout(fn, delay, context);
        }
        fn.call(0, context);
    }


    /**
     * Return the first value that is defined.
     */
    var pick = Highcharts.pick = function () {
        var args = arguments,
            i,
            arg,
            length = args.length;
        for (i = 0; i < length; i++) {
            arg = args[i];
            if (arg !== UNDEFINED && arg !== null) {
                return arg;
            }
        }
    };

    /**
     * Set CSS on a given element
     * @param {Object} el
     * @param {Object} styles Style object with camel case property names
     */
    function css(el, styles) {
        if (isMS && !hasSVG) { // #2686
            if (styles && styles.opacity !== UNDEFINED) {
                styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';
            }
        }
        extend(el.style, styles);
    }

    /**
     * Utility function to create element with attributes and styles
     * @param {Object} tag
     * @param {Object} attribs
     * @param {Object} styles
     * @param {Object} parent
     * @param {Object} nopad
     */
    function createElement(tag, attribs, styles, parent, nopad) {
        var el = doc.createElement(tag);
        if (attribs) {
            extend(el, attribs);
        }
        if (nopad) {
            css(el, { padding: 0, border: 'none', margin: 0 });
        }
        if (styles) {
            css(el, styles);
        }
        if (parent) {
            parent.appendChild(el);
        }
        return el;
    }

    /**
     * Extend a prototyped class by new members
     * @param {Object} parent
     * @param {Object} members
     */
    function extendClass(Parent, members) {
        var object = function () {
        };
        object.prototype = new Parent();
        extend(object.prototype, members);
        return object;
    }

    /**
     * Pad a string to a given length by adding 0 to the beginning
     * @param {Number} number
     * @param {Number} length
     */
    function pad(number, length, padder) {
        return new Array((length || 2) + 1 - String(number).length).join(padder || 0) + number;
    }

    /**
     * Return a length based on either the integer value, or a percentage of a base.
     */
    function relativeLength(value, base) {
        return (/%$/).test(value) ? base * parseFloat(value) / 100 : parseFloat(value);
    }

    /**
     * Wrap a method with extended functionality, preserving the original function
     * @param {Object} obj The context object that the method belongs to
     * @param {String} method The name of the method to extend
     * @param {Function} func A wrapper function callback. This function is called with the same arguments
     * as the original function, except that the original function is unshifted and passed as the first
     * argument.
     */
    var wrap = Highcharts.wrap = function (obj, method, func) {
        var proceed = obj[method];
        obj[method] = function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(proceed);
            return func.apply(this, args);
        };
    };


    function getTZOffset(timestamp) {
        return ((getTimezoneOffset && getTimezoneOffset(timestamp)) || timezoneOffset || 0) * 60000;
    }

    /**
     * Based on http://www.php.net/manual/en/function.strftime.php
     * @param {String} format
     * @param {Number} timestamp
     * @param {Boolean} capitalize
     */
    dateFormat = function (format, timestamp, capitalize) {
        if (!defined(timestamp) || isNaN(timestamp)) {
            return defaultOptions.lang.invalidDate || '';
        }
        format = pick(format, '%Y-%m-%d %H:%M:%S');

        var date = new Date(timestamp - getTZOffset(timestamp)),
            key, // used in for constuct below
            // get the basic time values
            hours = date[getHours](),
            day = date[getDay](),
            dayOfMonth = date[getDate](),
            month = date[getMonth](),
            fullYear = date[getFullYear](),
            lang = defaultOptions.lang,
            langWeekdays = lang.weekdays,
            shortWeekdays = lang.shortWeekdays,

            // List all format keys. Custom formats can be added from the outside.
            replacements = extend({

                // Day
                'a': shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
                'A': langWeekdays[day], // Long weekday, like 'Monday'
                'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31
                'e': pad(dayOfMonth, 2, ' '), // Day of the month, 1 through 31
                'w': day,

                // Week (none implemented)
                //'W': weekNumber(),

                // Month
                'b': lang.shortMonths[month], // Short month, like 'Jan'
                'B': lang.months[month], // Long month, like 'January'
                'm': pad(month + 1), // Two digit month number, 01 through 12

                // Year
                'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
                'Y': fullYear, // Four digits year, like 2009

                // Time
                'H': pad(hours), // Two digits hours in 24h format, 00 through 23
                'k': hours, // Hours in 24h format, 0 through 23
                'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
                'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
                'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
                'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
                'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
                'S': pad(date.getSeconds()), // Two digits seconds, 00 through  59
                'L': pad(mathRound(timestamp % 1000), 3) // Milliseconds (naming from Ruby)
            }, Highcharts.dateFormats);


        // do the replaces
        for (key in replacements) {
            while (format.indexOf('%' + key) !== -1) { // regex would do it in one line, but this is faster
                format = format.replace('%' + key, typeof replacements[key] === 'function' ? replacements[key](timestamp) : replacements[key]);
            }
        }

        // Optionally capitalize the string and return
        return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
    };

    /**
     * Format a single variable. Similar to sprintf, without the % prefix.
     */
    function formatSingle(format, val) {
        var floatRegex = /f$/,
            decRegex = /\.([0-9])/,
            lang = defaultOptions.lang,
            decimals;

        if (floatRegex.test(format)) { // float
            decimals = format.match(decRegex);
            decimals = decimals ? decimals[1] : -1;
            if (val !== null) {
                val = Highcharts.numberFormat(
                    val,
                    decimals,
                    lang.decimalPoint,
                    format.indexOf(',') > -1 ? lang.thousandsSep : ''
                );
            }
        } else {
            val = dateFormat(format, val);
        }
        return val;
    }

    /**
     * Format a string according to a subset of the rules of Python's String.format method.
     */
    function format(str, ctx) {
        var splitter = '{',
            isInside = false,
            segment,
            valueAndFormat,
            path,
            i,
            len,
            ret = [],
            val,
            index;

        while ((index = str.indexOf(splitter)) !== -1) {

            segment = str.slice(0, index);
            if (isInside) { // we're on the closing bracket looking back

                valueAndFormat = segment.split(':');
                path = valueAndFormat.shift().split('.'); // get first and leave format
                len = path.length;
                val = ctx;

                // Assign deeper paths
                for (i = 0; i < len; i++) {
                    val = val[path[i]];
                }

                // Format the replacement
                if (valueAndFormat.length) {
                    val = formatSingle(valueAndFormat.join(':'), val);
                }

                // Push the result and advance the cursor
                ret.push(val);

            } else {
                ret.push(segment);

            }
            str = str.slice(index + 1); // the rest
            isInside = !isInside; // toggle
            splitter = isInside ? '}' : '{'; // now look for next matching bracket
        }
        ret.push(str);
        return ret.join('');
    }

    /**
     * Get the magnitude of a number
     */
    function getMagnitude(num) {
        return math.pow(10, mathFloor(math.log(num) / math.LN10));
    }

    /**
     * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
     * @param {Number} interval
     * @param {Array} multiples
     * @param {Number} magnitude
     * @param {Object} options
     */
    function normalizeTickInterval(interval, multiples, magnitude, allowDecimals, preventExceed) {
        var normalized,
            i,
            retInterval = interval;

        // round to a tenfold of 1, 2, 2.5 or 5
        magnitude = pick(magnitude, 1);
        normalized = interval / magnitude;

        // multiples for a linear scale
        if (!multiples) {
            multiples = [1, 2, 2.5, 5, 10];

            // the allowDecimals option
            if (allowDecimals === false) {
                if (magnitude === 1) {
                    multiples = [1, 2, 5, 10];
                } else if (magnitude <= 0.1) {
                    multiples = [1 / magnitude];
                }
            }
        }

        // normalize the interval to the nearest multiple
        for (i = 0; i < multiples.length; i++) {
            retInterval = multiples[i];
            if ((preventExceed && retInterval * magnitude >= interval) || // only allow tick amounts smaller than natural
                    (!preventExceed && (normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2))) {
                break;
            }
        }

        // multiply back to the correct magnitude
        retInterval *= magnitude;

        return retInterval;
    }


    /**
     * Utility method that sorts an object array and keeping the order of equal items.
     * ECMA script standard does not specify the behaviour when items are equal.
     */
    function stableSort(arr, sortFunction) {
        var length = arr.length,
            sortValue,
            i;

        // Add index to each item
        for (i = 0; i < length; i++) {
            arr[i].safeI = i; // stable sort index
        }

        arr.sort(function (a, b) {
            sortValue = sortFunction(a, b);
            return sortValue === 0 ? a.safeI - b.safeI : sortValue;
        });

        // Remove index from items
        for (i = 0; i < length; i++) {
            delete arr[i].safeI; // stable sort index
        }
    }

    /**
     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
     * method is slightly slower, but safe.
     */
    function arrayMin(data) {
        var i = data.length,
            min = data[0];

        while (i--) {
            if (data[i] < min) {
                min = data[i];
            }
        }
        return min;
    }

    /**
     * Non-recursive method to find the lowest member of an array. Math.min raises a maximum
     * call stack size exceeded error in Chrome when trying to apply more than 150.000 points. This
     * method is slightly slower, but safe.
     */
    function arrayMax(data) {
        var i = data.length,
            max = data[0];

        while (i--) {
            if (data[i] > max) {
                max = data[i];
            }
        }
        return max;
    }

    /**
     * Utility method that destroys any SVGElement or VMLElement that are properties on the given object.
     * It loops all properties and invokes destroy if there is a destroy method. The property is
     * then delete'ed.
     * @param {Object} The object to destroy properties on
     * @param {Object} Exception, do not destroy this property, only delete it.
     */
    function destroyObjectProperties(obj, except) {
        var n;
        for (n in obj) {
            // If the object is non-null and destroy is defined
            if (obj[n] && obj[n] !== except && obj[n].destroy) {
                // Invoke the destroy
                obj[n].destroy();
            }

            // Delete the property from the object.
            delete obj[n];
        }
    }


    /**
     * Discard an element by moving it to the bin and delete
     * @param {Object} The HTML node to discard
     */
    function discardElement(element) {
        // create a garbage bin element, not part of the DOM
        if (!garbageBin) {
            garbageBin = createElement(DIV);
        }

        // move the node and empty bin
        if (element) {
            garbageBin.appendChild(element);
        }
        garbageBin.innerHTML = '';
    }

    /**
     * Fix JS round off float errors
     * @param {Number} num
     */
    function correctFloat(num, prec) {
        return parseFloat(
            num.toPrecision(prec || 14)
        );
    }

    /**
     * Set the global animation to either a given value, or fall back to the
     * given chart's animation option
     * @param {Object} animation
     * @param {Object} chart
     */
    function setAnimation(animation, chart) {
        chart.renderer.globalAnimation = pick(animation, chart.animation);
    }

    /**
     * Get the animation in object form, where a disabled animation is always
     * returned with duration: 0
     */
    function animObject(animation) {
        return isObject(animation) ? merge(animation) : { duration: animation ? 500 : 0 };
    }

    /**
     * The time unit lookup
     */
    timeUnits = {
        millisecond: 1,
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 24 * 3600000,
        week: 7 * 24 * 3600000,
        month: 28 * 24 * 3600000,
        year: 364 * 24 * 3600000
    };


    /**
     * Format a number and return a string based on input settings
     * @param {Number} number The input number to format
     * @param {Number} decimals The amount of decimals
     * @param {String} decimalPoint The decimal point, defaults to the one given in the lang options
     * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
     */
    Highcharts.numberFormat = function (number, decimals, decimalPoint, thousandsSep) {

        number = +number || 0;
        decimals = +decimals;

        var lang = defaultOptions.lang,
            origDec = (number.toString().split('.')[1] || '').length,
            decimalComponent,
            strinteger,
            thousands,
            absNumber = Math.abs(number),
            ret;

        if (decimals === -1) {
            decimals = Math.min(origDec, 20); // Preserve decimals. Not huge numbers (#3793).
        } else if (!isNumber(decimals)) {
            decimals = 2;
        }

        // A string containing the positive integer component of the number
        strinteger = String(pInt(absNumber.toFixed(decimals)));

        // Leftover after grouping into thousands. Can be 0, 1 or 3.
        thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;

        // Language
        decimalPoint = pick(decimalPoint, lang.decimalPoint);
        thousandsSep = pick(thousandsSep, lang.thousandsSep);

        // Start building the return
        ret = number < 0 ? '-' : '';

        // Add the leftover after grouping into thousands. For example, in the number 42 000 000,
        // this line adds 42.
        ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';

        // Add the remaining thousands groups, joined by the thousands separator
        ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, '$1' + thousandsSep);

        // Add the decimal point and the decimal component
        if (decimals) {
            // Get the decimal component, and add power to avoid rounding errors with float numbers (#4573)
            decimalComponent = Math.abs(absNumber - strinteger + Math.pow(10, -Math.max(decimals, origDec) - 1));
            ret += decimalPoint + decimalComponent.toFixed(decimals).slice(2);
        }

        return ret;
    };

    /**
     * Easing definition
     * @param   {Number} pos Current position, ranging from 0 to 1
     */
    Math.easeInOutSine = function (pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
    };

    /**
     * Internal method to return CSS value for given element and property
     */
    getStyle = function (el, prop) {

        var style;

        // For width and height, return the actual inner pixel size (#4913)
        if (prop === 'width') {
            return Math.min(el.offsetWidth, el.scrollWidth) - getStyle(el, 'padding-left') - getStyle(el, 'padding-right');
        } else if (prop === 'height') {
            return Math.min(el.offsetHeight, el.scrollHeight) - getStyle(el, 'padding-top') - getStyle(el, 'padding-bottom');
        }

        // Otherwise, get the computed style
        style = win.getComputedStyle(el, undefined);
        return style && pInt(style.getPropertyValue(prop));
    };

    /**
     * Return the index of an item in an array, or -1 if not found
     */
    inArray = function (item, arr) {
        return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
    };

    /**
     * Filter an array
     */
    grep = function (elements, callback) {
        return [].filter.call(elements, callback);
    };

    /**
     * Map an array
     */
    map = function (arr, fn) {
        var results = [],
            i = 0,
            len = arr.length;

        for (; i < len; i++) {
            results[i] = fn.call(arr[i], arr[i], i, arr);
        }

        return results;
    };

    /**
     * Get the element's offset position, corrected by overflow:auto.
     */
    offset = function (el) {
        var docElem = doc.documentElement,
            box = el.getBoundingClientRect();

        return {
            top: box.top  + (win.pageYOffset || docElem.scrollTop)  - (docElem.clientTop  || 0),
            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
        };
    };

    /**
     * Stop running animation.
     * A possible extension to this would be to stop a single property, when
     * we want to continue animating others. Then assign the prop to the timer
     * in the Fx.run method, and check for the prop here. This would be an improvement
     * in all cases where we stop the animation from .attr. Instead of stopping
     * everything, we can just stop the actual attributes we're setting.
     */
    stop = function (el) {

        var i = timers.length;

        // Remove timers related to this element (#4519)
        while (i--) {
            if (timers[i].elem === el) {
                timers[i].stopped = true; // #4667
            }
        }
    };

    /**
     * Utility for iterating over an array.
     * @param {Array} arr
     * @param {Function} fn
     */
    each = function (arr, fn) { // modern browsers
        return Array.prototype.forEach.call(arr, fn);
    };

    /**
     * Add an event listener
     */
    addEvent = function (el, type, fn) {
    
        var events = el.hcEvents = el.hcEvents || {};

        function wrappedFn(e) {
            e.target = e.srcElement || win; // #2820
            fn.call(el, e);
        }

        // Handle DOM events in modern browsers
        if (el.addEventListener) {
            el.addEventListener(type, fn, false);

        // Handle old IE implementation
        } else if (el.attachEvent) {

            if (!el.hcEventsIE) {
                el.hcEventsIE = {};
            }

            // Link wrapped fn with original fn, so we can get this in removeEvent
            el.hcEventsIE[fn.toString()] = wrappedFn;

            el.attachEvent('on' + type, wrappedFn);
        }

        if (!events[type]) {
            events[type] = [];
        }

        events[type].push(fn);
    };

    /**
     * Remove event added with addEvent
     */
    removeEvent = function (el, type, fn) {
    
        var events,
            hcEvents = el.hcEvents,
            index;

        function removeOneEvent(type, fn) {
            if (el.removeEventListener) {
                el.removeEventListener(type, fn, false);
            } else if (el.attachEvent) {
                fn = el.hcEventsIE[fn.toString()];
                el.detachEvent('on' + type, fn);
            }
        }

        function removeAllEvents() {
            var types,
                len,
                n;

            if (!el.nodeName) {
                return; // break on non-DOM events
            }

            if (type) {
                types = {};
                types[type] = true;
            } else {
                types = hcEvents;
            }

            for (n in types) {
                if (hcEvents[n]) {
                    len = hcEvents[n].length;
                    while (len--) {
                        removeOneEvent(n, hcEvents[n][len]);
                    }
                }
            }
        }

        if (hcEvents) {
            if (type) {
                events = hcEvents[type] || [];
                if (fn) {
                    index = inArray(fn, events);
                    if (index > -1) {
                        events.splice(index, 1);
                        hcEvents[type] = events;
                    }
                    removeOneEvent(type, fn);

                } else {
                    removeAllEvents();
                    hcEvents[type] = [];
                }
            } else {
                removeAllEvents();
                el.hcEvents = {};
            }
        }
    };

    /**
     * Fire an event on a custom object
     */
    fireEvent = function (el, type, eventArguments, defaultFunction) {
        var e,
            hcEvents = el.hcEvents,
            events,
            len,
            i,
            fn;

        eventArguments = eventArguments || {};

        if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {
            e = doc.createEvent('Events');
            e.initEvent(type, true, true);
            e.target = el;

            extend(e, eventArguments);

            if (el.dispatchEvent) {
                el.dispatchEvent(e);
            } else {
                el.fireEvent(type, e);
            }

        } else if (hcEvents) {
        
            events = hcEvents[type] || [];
            len = events.length;

            // Attach a simple preventDefault function to skip default handler if called. 
            // The built-in defaultPrevented property is not overwritable (#5112)
            if (!eventArguments.preventDefault) {
                eventArguments.preventDefault = function () {
                    eventArguments.defaultPrevented = true;
                };
            }

            eventArguments.target = el;

            // If the type is not set, we're running a custom event (#2297). If it is set,
            // we're running a browser event, and setting it will cause en error in
            // IE8 (#2465).
            if (!eventArguments.type) {
                eventArguments.type = type;
            }
        
            for (i = 0; i < len; i++) {
                fn = events[i];

                // If the event handler return false, prevent the default handler from executing
                if (fn && fn.call(el, eventArguments) === false) {
                    eventArguments.preventDefault();
                }
            }
        }
            
        // Run the default if not prevented
        if (defaultFunction && !eventArguments.defaultPrevented) {
            defaultFunction(eventArguments);
        }
    };

    /**
     * The global animate method, which uses Fx to create individual animators.
     */
    animate = function (el, params, opt) {
        var start,
            unit = '',
            end,
            fx,
            args,
            prop;

        if (!isObject(opt)) { // Number or undefined/null
            args = arguments;
            opt = {
                duration: args[2],
                easing: args[3],
                complete: args[4]
            };
        }
        if (!isNumber(opt.duration)) {
            opt.duration = 400;
        }
        opt.easing = typeof opt.easing === 'function' ? opt.easing : (Math[opt.easing] || Math.easeInOutSine);
        opt.curAnim = merge(params);

        for (prop in params) {
            fx = new Fx(el, opt, prop);
            end = null;

            if (prop === 'd') {
                fx.paths = fx.initPath(
                    el,
                    el.d,
                    params.d
                );
                fx.toD = params.d;
                start = 0;
                end = 1;
            } else if (el.attr) {
                start = el.attr(prop);
            } else {
                start = parseFloat(getStyle(el, prop)) || 0;
                if (prop !== 'opacity') {
                    unit = 'px';
                }
            }

            if (!end) {
                end = params[prop];
            }
            if (end.match && end.match('px')) {
                end = end.replace(/px/g, ''); // #4351
            }
            fx.run(start, end, unit);
        }
    };

    /**
     * Register Highcharts as a plugin in jQuery
     */
    if (win.jQuery) {
        win.jQuery.fn.highcharts = function () {
            var args = [].slice.call(arguments);

            if (this[0]) { // this[0] is the renderTo div

                // Create the chart
                if (args[0]) {
                    new Highcharts[ // eslint-disable-line no-new
                        isString(args[0]) ? args.shift() : 'Chart' // Constructor defaults to Chart
                    ](this[0], args[0], args[1]);
                    return this;
                }

                // When called without parameters or with the return argument, return an existing chart
                return charts[attr(this[0], 'data-highcharts-chart')];
            }
        };
    }


    /**
     * Compatibility section to add support for legacy IE. This can be removed if old IE 
     * support is not needed.
     */
    if (doc && !doc.defaultView) {
        getStyle = function (el, prop) {
            var val,
                alias = { width: 'clientWidth', height: 'clientHeight' }[prop];
            
            if (el.style[prop]) {
                return pInt(el.style[prop]);
            }
            if (prop === 'opacity') {
                prop = 'filter';
            }

            // Getting the rendered width and height
            if (alias) {
                el.style.zoom = 1;
                return Math.max(el[alias] - 2 * getStyle(el, 'padding'), 0);
            }
        
            val = el.currentStyle[prop.replace(/\-(\w)/g, function (a, b) {
                return b.toUpperCase();
            })];
            if (prop === 'filter') {
                val = val.replace(
                    /alpha\(opacity=([0-9]+)\)/, 
                    function (a, b) { 
                        return b / 100; 
                    }
                );
            }
        
            return val === '' ? 1 : pInt(val);
        };
    }

    if (!Array.prototype.forEach) {
        each = function (arr, fn) { // legacy
            var i = 0, 
                len = arr.length;
            for (; i < len; i++) {
                if (fn.call(arr[i], arr[i], i, arr) === false) {
                    return i;
                }
            }
        };
    }

    if (!Array.prototype.indexOf) {
        inArray = function (item, arr) {
            var len, 
                i = 0;

            if (arr) {
                len = arr.length;
            
                for (; i < len; i++) {
                    if (arr[i] === item) {
                        return i;
                    }
                }
            }

            return -1;
        };
    }

    if (!Array.prototype.filter) {
        grep = function (elements, fn) {
            var ret = [],
                i = 0,
                length = elements.length;

            for (; i < length; i++) {
                if (fn(elements[i], i)) {
                    ret.push(elements[i]);
                }
            }

            return ret;
        };
    }

    //--- End compatibility section ---

    // Expose utilities
    Highcharts.Fx = Fx;
    Highcharts.inArray = inArray;
    Highcharts.each = each;
    Highcharts.grep = grep;
    Highcharts.offset = offset;
    Highcharts.map = map;
    Highcharts.addEvent = addEvent;
    Highcharts.removeEvent = removeEvent;
    Highcharts.fireEvent = fireEvent;
    Highcharts.animate = animate;
    Highcharts.animObject = animObject;
    Highcharts.stop = stop;

    /* ****************************************************************************
     * Handle the options                                                         *
     *****************************************************************************/
    defaultOptions = {
        colors: ['#7cb5ec', '#434348', '#90ed7d', '#f7a35c',
                '#8085e9', '#f15c80', '#e4d354', '#2b908f', '#f45b5b', '#91e8e1'],
        symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
        lang: {
            loading: 'Loading...',
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July',
                    'August', 'September', 'October', 'November', 'December'],
            shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            // invalidDate: '',
            decimalPoint: '.',
            numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels
            resetZoom: 'Reset zoom',
            resetZoomTitle: 'Reset zoom level 1:1',
            thousandsSep: ' '
        },
        global: {
            useUTC: true,
            //timezoneOffset: 0,
            canvasToolsURL: 'http://code.highcharts.com/modules/canvas-tools.js',
            VMLRadialGradientURL: 'http://code.highcharts.com/4.2.6/gfx/vml-radial-gradient.png'
        },
        chart: {
            //animation: true,
            //alignTicks: false,
            //reflow: true,
            //className: null,
            //events: { load, selection },
            //margin: [null],
            //marginTop: null,
            //marginRight: null,
            //marginBottom: null,
            //marginLeft: null,
            borderColor: '#4572A7',
            //borderWidth: 0,
            borderRadius: 0,
            defaultSeriesType: 'line',
            ignoreHiddenSeries: true,
            //inverted: false,
            //shadow: false,
            spacing: [10, 10, 15, 10],
            //spacingTop: 10,
            //spacingRight: 10,
            //spacingBottom: 15,
            //spacingLeft: 10,
            //style: {
            //    fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
            //    fontSize: '12px'
            //},
            backgroundColor: '#FFFFFF',
            //plotBackgroundColor: null,
            plotBorderColor: '#C0C0C0',
            //plotBorderWidth: 0,
            //plotShadow: false,
            //zoomType: ''
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: 'right',
                    x: -10,
                    //verticalAlign: 'top',
                    y: 10
                }
                // relativeTo: 'plot'
            },
            width: null,
            height: null
        },
        title: {
            text: 'Chart title',
            align: 'center',
            // floating: false,
            margin: 15,
            // x: 0,
            // verticalAlign: 'top',
            // y: null,
            style: {
                color: '#333333',
                fontSize: '18px'
            },
            widthAdjust: -44

        },
        subtitle: {
            text: '',
            align: 'center',
            // floating: false
            // x: 0,
            // verticalAlign: 'top',
            // y: null,
            style: {
                color: '#555555'
            },
            widthAdjust: -44
        },

        plotOptions: {
            line: { // base series options
                allowPointSelect: false,
                showCheckbox: false,
                animation: {
                    duration: 1000
                },
                //connectNulls: false,
                //cursor: 'default',
                //clip: true,
                //dashStyle: null,
                //enableMouseTracking: true,
                events: {},
                //legendIndex: 0,
                //linecap: 'round',
                lineWidth: 2,
                //shadow: false,
                // stacking: null,
                marker: {
                    //enabled: true,
                    //symbol: null,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: '#FFFFFF',
                    //fillColor: null,
                    states: { // states for a single point
                        hover: {
                            enabled: true,
                            lineWidthPlus: 1,
                            radiusPlus: 2
                        },
                        select: {
                            fillColor: '#FFFFFF',
                            lineColor: '#000000',
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: {
                    align: 'center',
                    // defer: true,
                    // enabled: false,
                    formatter: function () {
                        return this.y === null ? '' : Highcharts.numberFormat(this.y, -1);
                    },
                    style: {
                        color: 'contrast',
                        fontSize: '11px',
                        fontWeight: 'bold',
                        textShadow: '0 0 6px contrast, 0 0 3px contrast'
                    },
                    verticalAlign: 'bottom', // above singular point
                    x: 0,
                    y: 0,
                    // backgroundColor: undefined,
                    // borderColor: undefined,
                    // borderRadius: undefined,
                    // borderWidth: undefined,
                    padding: 5
                    // shadow: false
                },
                cropThreshold: 300, // draw points outside the plot area when the number of points is less than this
                pointRange: 0,
                //pointStart: 0,
                //pointInterval: 1,
                //showInLegend: null, // auto: true for standalone series, false for linked series
                softThreshold: true,
                states: { // states for the entire series
                    hover: {
                        //enabled: false,
                        lineWidthPlus: 1,
                        marker: {
                            // lineWidth: base + 1,
                            // radius: base + 1
                        },
                        halo: {
                            size: 10,
                            opacity: 0.25
                        }
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: true,
                //tooltip: {
                    //pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b>'
                    //valueDecimals: null,
                    //xDateFormat: '%A, %b %e, %Y',
                    //valuePrefix: '',
                    //ySuffix: ''
                //}
                turboThreshold: 1000
                // zIndex: null
            }
        },
        labels: {
            //items: [],
            style: {
                //font: defaultFont,
                position: ABSOLUTE,
                color: '#3E576F'
            }
        },
        legend: {
            enabled: true,
            align: 'center',
            //floating: false,
            layout: 'horizontal',
            labelFormatter: function () {
                return this.name;
            },
            //borderWidth: 0,
            borderColor: '#909090',
            borderRadius: 0,
            navigation: {
                // animation: true,
                activeColor: '#274b6d',
                // arrowSize: 12
                inactiveColor: '#CCC'
                // style: {} // text styles
            },
            // margin: 20,
            // reversed: false,
            shadow: false,
            // backgroundColor: null,
            /*style: {
                padding: '5px'
            },*/
            itemStyle: {
                color: '#333333',
                fontSize: '12px',
                fontWeight: 'bold'
            },
            itemHoverStyle: {
                //cursor: 'pointer', removed as of #601
                color: '#000'
            },
            itemHiddenStyle: {
                color: '#CCC'
            },
            itemCheckboxStyle: {
                position: ABSOLUTE,
                width: '13px', // for IE precision
                height: '13px'
            },
            // itemWidth: undefined,
            // symbolRadius: 0,
            // symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: 'bottom',
            // width: undefined,
            x: 0,
            y: 0,
            title: {
                //text: null,
                style: {
                    fontWeight: 'bold'
                }
            }
        },

        loading: {
            // hideDuration: 100,
            labelStyle: {
                fontWeight: 'bold',
                position: RELATIVE,
                top: '45%'
            },
            // showDuration: 0,
            style: {
                position: ABSOLUTE,
                backgroundColor: 'white',
                opacity: 0.5,
                textAlign: 'center'
            }
        },

        tooltip: {
            enabled: true,
            animation: hasSVG,
            //crosshairs: null,
            backgroundColor: 'rgba(249, 249, 249, .85)',
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: '%A, %b %e, %H:%M:%S.%L',
                second: '%A, %b %e, %H:%M:%S',
                minute: '%A, %b %e, %H:%M',
                hour: '%A, %b %e, %H:%M',
                day: '%A, %b %e, %Y',
                week: 'Week from %A, %b %e, %Y',
                month: '%B %Y',
                year: '%Y'
            },
            footerFormat: '',
            //formatter: defaultFormatter,
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
            shadow: true,
            //shape: 'callout',
            //shared: false,
            snap: isTouchDevice ? 25 : 10,
            style: {
                color: '#333333',
                cursor: 'default',
                fontSize: '12px',
                padding: '8px',
                pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events
                whiteSpace: 'nowrap'
            }
            //xDateFormat: '%A, %b %e, %Y',
            //valueDecimals: null,
            //valuePrefix: '',
            //valueSuffix: ''
        },

        credits: {
            enabled: true,
            text: 'Highcharts.com',
            href: 'http://www.highcharts.com',
            position: {
                align: 'right',
                x: -10,
                verticalAlign: 'bottom',
                y: -5
            },
            style: {
                cursor: 'pointer',
                color: '#909090',
                fontSize: '9px'
            }
        }
    };



    /**
     * Set the time methods globally based on the useUTC option. Time method can be either
     * local time or UTC (default).
     */
    function setTimeMethods() {
        var globalOptions = defaultOptions.global,
            useUTC = globalOptions.useUTC,
            GET = useUTC ? 'getUTC' : 'get',
            SET = useUTC ? 'setUTC' : 'set';


        Date = globalOptions.Date || win.Date;
        timezoneOffset = useUTC && globalOptions.timezoneOffset;
        getTimezoneOffset = useUTC && globalOptions.getTimezoneOffset;
        makeTime = function (year, month, date, hours, minutes, seconds) {
            var d;
            if (useUTC) {
                d = Date.UTC.apply(0, arguments);
                d += getTZOffset(d);
            } else {
                d = new Date(
                    year,
                    month,
                    pick(date, 1),
                    pick(hours, 0),
                    pick(minutes, 0),
                    pick(seconds, 0)
                ).getTime();
            }
            return d;
        };
        getMinutes =      GET + 'Minutes';
        getHours =        GET + 'Hours';
        getDay =          GET + 'Day';
        getDate =         GET + 'Date';
        getMonth =        GET + 'Month';
        getFullYear =     GET + 'FullYear';
        setMilliseconds = SET + 'Milliseconds';
        setSeconds =      SET + 'Seconds';
        setMinutes =      SET + 'Minutes';
        setHours =        SET + 'Hours';
        setDate =         SET + 'Date';
        setMonth =        SET + 'Month';
        setFullYear =     SET + 'FullYear';

    }

    /**
     * Merge the default options with custom options and return the new options structure
     * @param {Object} options The new custom options
     */
    function setOptions(options) {

        // Copy in the default options
        defaultOptions = merge(true, defaultOptions, options);

        // Apply UTC
        setTimeMethods();

        return defaultOptions;
    }

    /**
     * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules
     * wasn't enough because the setOptions method created a new object.
     */
    function getOptions() {
        return defaultOptions;
    }






    // Series defaults
    var defaultPlotOptions = defaultOptions.plotOptions,
        defaultSeriesOptions = defaultPlotOptions.line;

    // set the default time methods
    setTimeMethods();


    /**
     * Handle color operations. The object methods are chainable.
     * @param {String} input The input color in either rbga or hex format
     */
    function Color(input) {
        // Backwards compatibility, allow instanciation without new
        if (!(this instanceof Color)) {
            return new Color(input);
        }
        // Initialize
        this.init(input);
    }
    Color.prototype = {

        // Collection of parsers. This can be extended from the outside by pushing parsers
        // to Highcharts.Colors.prototype.parsers.
        parsers: [{
            // RGBA color
            regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
            parse: function (result) {
                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
            }
        }, {
            // HEX color
            regex: /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/,
            parse: function (result) {
                return [pInt(result[1], 16), pInt(result[2], 16), pInt(result[3], 16), 1];
            }
        }, {
            // RGB color
            regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
            parse: function (result) {
                return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
            }
        }],

        /**
         * Parse the input color to rgba array
         * @param {String} input
         */
        init: function (input) {
            var result,
                rgba,
                i,
                parser;

            this.input = input;

            // Gradients
            if (input && input.stops) {
                this.stops = map(input.stops, function (stop) {
                    return new Color(stop[1]);
                });

            // Solid colors
            } else {
                i = this.parsers.length;
                while (i-- && !rgba) {
                    parser = this.parsers[i];
                    result = parser.regex.exec(input);
                    if (result) {
                        rgba = parser.parse(result);
                    }
                }
            }
            this.rgba = rgba || [];
        },

        /**
         * Return the color a specified format
         * @param {String} format
         */
        get: function (format) {
            var input = this.input,
                rgba = this.rgba,
                ret;

            if (this.stops) {
                ret = merge(input);
                ret.stops = [].concat(ret.stops);
                each(this.stops, function (stop, i) {
                    ret.stops[i] = [ret.stops[i][0], stop.get(format)];
                });

            // it's NaN if gradient colors on a column chart
            } else if (rgba && isNumber(rgba[0])) {
                if (format === 'rgb' || (!format && rgba[3] === 1)) {
                    ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';
                } else if (format === 'a') {
                    ret = rgba[3];
                } else {
                    ret = 'rgba(' + rgba.join(',') + ')';
                }
            } else {
                ret = input;
            }
            return ret;
        },

        /**
         * Brighten the color
         * @param {Number} alpha
         */
        brighten: function (alpha) {
            var i, 
                rgba = this.rgba;

            if (this.stops) {
                each(this.stops, function (stop) {
                    stop.brighten(alpha);
                });

            } else if (isNumber(alpha) && alpha !== 0) {
                for (i = 0; i < 3; i++) {
                    rgba[i] += pInt(alpha * 255);

                    if (rgba[i] < 0) {
                        rgba[i] = 0;
                    }
                    if (rgba[i] > 255) {
                        rgba[i] = 255;
                    }
                }
            }
            return this;
        },

        /**
         * Set the color's opacity to a given alpha value
         * @param {Number} alpha
         */
        setOpacity: function (alpha) {
            this.rgba[3] = alpha;
            return this;
        }
    };


    /**
     * A wrapper object for SVG elements
     */
    function SVGElement() {}

    SVGElement.prototype = {

        // Default base for animation
        opacity: 1,
        // For labels, these CSS properties are applied to the <text> node directly
        textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily', 'fontStyle', 'color',
            'lineHeight', 'width', 'textDecoration', 'textOverflow', 'textShadow'],

        /**
         * Initialize the SVG renderer
         * @param {Object} renderer
         * @param {String} nodeName
         */
        init: function (renderer, nodeName) {
            var wrapper = this;
            wrapper.element = nodeName === 'span' ?
                    createElement(nodeName) :
                    doc.createElementNS(SVG_NS, nodeName);
            wrapper.renderer = renderer;
        },

        /**
         * Animate a given attribute
         * @param {Object} params
         * @param {Number} options Options include duration, easing, step and complete
         * @param {Function} complete Function to perform at the end of animation
         */
        animate: function (params, options, complete) {
            var animOptions = pick(options, this.renderer.globalAnimation, true);
            stop(this); // stop regardless of animation actually running, or reverting to .attr (#607)
            if (animOptions) {
                if (complete) { // allows using a callback with the global animation without overwriting it
                    animOptions.complete = complete;
                }
                animate(this, params, animOptions);
            } else {
                this.attr(params, null, complete);
            }
            return this;
        },

        /**
         * Build an SVG gradient out of a common JavaScript configuration object
         */
        colorGradient: function (color, prop, elem) {
            var renderer = this.renderer,
                colorObject,
                gradName,
                gradAttr,
                radAttr,
                gradients,
                gradientObject,
                stops,
                stopColor,
                stopOpacity,
                radialReference,
                n,
                id,
                key = [],
                value;

            // Apply linear or radial gradients
            if (color.linearGradient) {
                gradName = 'linearGradient';
            } else if (color.radialGradient) {
                gradName = 'radialGradient';
            }

            if (gradName) {
                gradAttr = color[gradName];
                gradients = renderer.gradients;
                stops = color.stops;
                radialReference = elem.radialReference;

                // Keep < 2.2 kompatibility
                if (isArray(gradAttr)) {
                    color[gradName] = gradAttr = {
                        x1: gradAttr[0],
                        y1: gradAttr[1],
                        x2: gradAttr[2],
                        y2: gradAttr[3],
                        gradientUnits: 'userSpaceOnUse'
                    };
                }

                // Correct the radial gradient for the radial reference system
                if (gradName === 'radialGradient' && radialReference && !defined(gradAttr.gradientUnits)) {
                    radAttr = gradAttr; // Save the radial attributes for updating
                    gradAttr = merge(gradAttr,
                        renderer.getRadialAttr(radialReference, radAttr),
                        { gradientUnits: 'userSpaceOnUse' }
                        );
                }

                // Build the unique key to detect whether we need to create a new element (#1282)
                for (n in gradAttr) {
                    if (n !== 'id') {
                        key.push(n, gradAttr[n]);
                    }
                }
                for (n in stops) {
                    key.push(stops[n]);
                }
                key = key.join(',');

                // Check if a gradient object with the same config object is created within this renderer
                if (gradients[key]) {
                    id = gradients[key].attr('id');

                } else {

                    // Set the id and create the element
                    gradAttr.id = id = PREFIX + idCounter++;
                    gradients[key] = gradientObject = renderer.createElement(gradName)
                        .attr(gradAttr)
                        .add(renderer.defs);

                    gradientObject.radAttr = radAttr;

                    // The gradient needs to keep a list of stops to be able to destroy them
                    gradientObject.stops = [];
                    each(stops, function (stop) {
                        var stopObject;
                        if (stop[1].indexOf('rgba') === 0) {
                            colorObject = Color(stop[1]);
                            stopColor = colorObject.get('rgb');
                            stopOpacity = colorObject.get('a');
                        } else {
                            stopColor = stop[1];
                            stopOpacity = 1;
                        }
                        stopObject = renderer.createElement('stop').attr({
                            offset: stop[0],
                            'stop-color': stopColor,
                            'stop-opacity': stopOpacity
                        }).add(gradientObject);

                        // Add the stop element to the gradient
                        gradientObject.stops.push(stopObject);
                    });
                }

                // Set the reference to the gradient object
                value = 'url(' + renderer.url + '#' + id + ')';
                elem.setAttribute(prop, value);
                elem.gradient = key;

                // Allow the color to be concatenated into tooltips formatters etc. (#2995)
                color.toString = function () {
                    return value;
                };
            }
        },

        /**
         * Apply a polyfill to the text-stroke CSS property, by copying the text element
         * and apply strokes to the copy.
         *
         * Contrast checks at http://jsfiddle.net/highcharts/43soe9m1/2/
         */
        applyTextShadow: function (textShadow) {
            var elem = this.element,
                tspans,
                hasContrast = textShadow.indexOf('contrast') !== -1,
                styles = {},
                forExport = this.renderer.forExport,
                // IE10 and IE11 report textShadow in elem.style even though it doesn't work. Check
                // this again with new IE release. In exports, the rendering is passed to PhantomJS.
                supports = forExport || (elem.style.textShadow !== UNDEFINED && !isMS);

            // When the text shadow is set to contrast, use dark stroke for light text and vice versa
            if (hasContrast) {
                styles.textShadow = textShadow = textShadow.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
            }

            // Safari with retina displays as well as PhantomJS bug (#3974). Firefox does not tolerate this,
            // it removes the text shadows.
            if (isWebKit || forExport) {
                styles.textRendering = 'geometricPrecision';
            }

            /* Selective side-by-side testing in supported browser (http://jsfiddle.net/highcharts/73L1ptrh/)
            if (elem.textContent.indexOf('2.') === 0) {
                elem.style['text-shadow'] = 'none';
                supports = false;
            }
            // */

            // No reason to polyfill, we've got native support
            if (supports) {
                this.css(styles); // Apply altered textShadow or textRendering workaround
            } else {

                this.fakeTS = true; // Fake text shadow

                // In order to get the right y position of the clones,
                // copy over the y setter
                this.ySetter = this.xSetter;

                tspans = [].slice.call(elem.getElementsByTagName('tspan'));
                each(textShadow.split(/\s?,\s?/g), function (textShadow) {
                    var firstChild = elem.firstChild,
                        color,
                        strokeWidth;

                    textShadow = textShadow.split(' ');
                    color = textShadow[textShadow.length - 1];

                    // Approximately tune the settings to the text-shadow behaviour
                    strokeWidth = textShadow[textShadow.length - 2];

                    if (strokeWidth) {
                        each(tspans, function (tspan, y) {
                            var clone;

                            // Let the first line start at the correct X position
                            if (y === 0) {
                                tspan.setAttribute('x', elem.getAttribute('x'));
                                y = elem.getAttribute('y');
                                tspan.setAttribute('y', y || 0);
                                if (y === null) {
                                    elem.setAttribute('y', 0);
                                }
                            }

                            // Create the clone and apply shadow properties
                            clone = tspan.cloneNode(1);
                            attr(clone, {
                                'class': PREFIX + 'text-shadow',
                                'fill': color,
                                'stroke': color,
                                'stroke-opacity': 1 / mathMax(pInt(strokeWidth), 3),
                                'stroke-width': strokeWidth,
                                'stroke-linejoin': 'round'
                            });
                            elem.insertBefore(clone, firstChild);
                        });
                    }
                });
            }
        },

        /**
         * Set or get a given attribute
         * @param {Object|String} hash
         * @param {Mixed|Undefined} val
         */
        attr: function (hash, val, complete) {
            var key,
                value,
                element = this.element,
                hasSetSymbolSize,
                ret = this,
                skipAttr,
                setter;

            // single key-value pair
            if (typeof hash === 'string' && val !== UNDEFINED) {
                key = hash;
                hash = {};
                hash[key] = val;
            }

            // used as a getter: first argument is a string, second is undefined
            if (typeof hash === 'string') {
                ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);

            // setter
            } else {

                for (key in hash) {
                    value = hash[key];
                    skipAttr = false;



                    if (this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(key)) {
                        if (!hasSetSymbolSize) {
                            this.symbolAttr(hash);
                            hasSetSymbolSize = true;
                        }
                        skipAttr = true;
                    }

                    if (this.rotation && (key === 'x' || key === 'y')) {
                        this.doTransform = true;
                    }

                    if (!skipAttr) {
                        setter = this[key + 'Setter'] || this._defaultSetter;
                        setter.call(this, value, key, element);

                        // Let the shadow follow the main element
                        if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {
                            this.updateShadows(key, value, setter);
                        }
                    }
                }

                // Update transform. Do this outside the loop to prevent redundant updating for batch setting
                // of attributes.
                if (this.doTransform) {
                    this.updateTransform();
                    this.doTransform = false;
                }

            }

            // In accordance with animate, run a complete callback
            if (complete) {
                complete();
            }

            return ret;
        },

        /**
         * Update the shadow elements with new attributes
         * @param   {String}        key    The attribute name
         * @param   {String|Number} value  The value of the attribute
         * @param   {Function}      setter The setter function, inherited from the parent wrapper
         * @returns {undefined}
         */
        updateShadows: function (key, value, setter) {
            var shadows = this.shadows,
                i = shadows.length;

            while (i--) {
                setter.call(
                    shadows[i], 
                    key === 'height' ?
                        Math.max(value - (shadows[i].cutHeight || 0), 0) :
                        key === 'd' ? this.d : value, 
                    key, 
                    shadows[i]
                );
            }
        },

        /**
         * Add a class name to an element
         */
        addClass: function (className) {
            var element = this.element,
                currentClassName = attr(element, 'class') || '';

            if (currentClassName.indexOf(className) === -1) {
                attr(element, 'class', currentClassName + ' ' + className);
            }
            return this;
        },
        /* hasClass and removeClass are not (yet) needed
        hasClass: function (className) {
            return attr(this.element, 'class').indexOf(className) !== -1;
        },
        removeClass: function (className) {
            attr(this.element, 'class', attr(this.element, 'class').replace(className, ''));
            return this;
        },
        */

        /**
         * If one of the symbol size affecting parameters are changed,
         * check all the others only once for each call to an element's
         * .attr() method
         * @param {Object} hash
         */
        symbolAttr: function (hash) {
            var wrapper = this;

            each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function (key) {
                wrapper[key] = pick(hash[key], wrapper[key]);
            });

            wrapper.attr({
                d: wrapper.renderer.symbols[wrapper.symbolName](
                    wrapper.x,
                    wrapper.y,
                    wrapper.width,
                    wrapper.height,
                    wrapper
                )
            });
        },

        /**
         * Apply a clipping path to this object
         * @param {String} id
         */
        clip: function (clipRect) {
            return this.attr('clip-path', clipRect ? 'url(' + this.renderer.url + '#' + clipRect.id + ')' : NONE);
        },

        /**
         * Calculate the coordinates needed for drawing a rectangle crisply and return the
         * calculated attributes
         * @param {Number} strokeWidth
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         */
        crisp: function (rect) {

            var wrapper = this,
                key,
                attribs = {},
                normalizer,
                strokeWidth = wrapper.strokeWidth || 0;

            normalizer = mathRound(strokeWidth) % 2 / 2; // mathRound because strokeWidth can sometimes have roundoff errors

            // normalize for crisp edges
            rect.x = mathFloor(rect.x || wrapper.x || 0) + normalizer;
            rect.y = mathFloor(rect.y || wrapper.y || 0) + normalizer;
            rect.width = mathFloor((rect.width || wrapper.width || 0) - 2 * normalizer);
            rect.height = mathFloor((rect.height || wrapper.height || 0) - 2 * normalizer);
            rect.strokeWidth = strokeWidth;

            for (key in rect) {
                if (wrapper[key] !== rect[key]) { // only set attribute if changed
                    wrapper[key] = attribs[key] = rect[key];
                }
            }

            return attribs;
        },

        /**
         * Set styles for the element
         * @param {Object} styles
         */
        css: function (styles) {
            var elemWrapper = this,
                oldStyles = elemWrapper.styles,
                newStyles = {},
                elem = elemWrapper.element,
                textWidth,
                n,
                serializedCss = '',
                hyphenate,
                hasNew = !oldStyles;

            // convert legacy
            if (styles && styles.color) {
                styles.fill = styles.color;
            }

            // Filter out existing styles to increase performance (#2640)
            if (oldStyles) {
                for (n in styles) {
                    if (styles[n] !== oldStyles[n]) {
                        newStyles[n] = styles[n];
                        hasNew = true;
                    }
                }
            }
            if (hasNew) {
                textWidth = elemWrapper.textWidth =
                    (styles && styles.width && elem.nodeName.toLowerCase() === 'text' && pInt(styles.width)) ||
                    elemWrapper.textWidth; // #3501

                // Merge the new styles with the old ones
                if (oldStyles) {
                    styles = extend(
                        oldStyles,
                        newStyles
                    );
                }

                // store object
                elemWrapper.styles = styles;

                if (textWidth && (useCanVG || (!hasSVG && elemWrapper.renderer.forExport))) {
                    delete styles.width;
                }

                // serialize and set style attribute
                if (isMS && !hasSVG) {
                    css(elemWrapper.element, styles);
                } else {
                    hyphenate = function (a, b) {
                        return '-' + b.toLowerCase();
                    };
                    for (n in styles) {
                        serializedCss += n.replace(/([A-Z])/g, hyphenate) + ':' + styles[n] + ';';
                    }
                    attr(elem, 'style', serializedCss); // #1881
                }


                // re-build text
                if (textWidth && elemWrapper.added) {
                    elemWrapper.renderer.buildText(elemWrapper);
                }
            }

            return elemWrapper;
        },

        /**
         * Add an event listener
         * @param {String} eventType
         * @param {Function} handler
         */
        on: function (eventType, handler) {
            var svgElement = this,
                element = svgElement.element;

            // touch
            if (hasTouch && eventType === 'click') {
                element.ontouchstart = function (e) {
                    svgElement.touchEventFired = Date.now();
                    e.preventDefault();
                    handler.call(element, e);
                };
                element.onclick = function (e) {
                    if (userAgent.indexOf('Android') === -1 || Date.now() - (svgElement.touchEventFired || 0) > 1100) { // #2269
                        handler.call(element, e);
                    }
                };
            } else {
                // simplest possible event model for internal use
                element['on' + eventType] = handler;
            }
            return this;
        },

        /**
         * Set the coordinates needed to draw a consistent radial gradient across
         * pie slices regardless of positioning inside the chart. The format is
         * [centerX, centerY, diameter] in pixels.
         */
        setRadialReference: function (coordinates) {
            var existingGradient = this.renderer.gradients[this.element.gradient];

            this.element.radialReference = coordinates;

            // On redrawing objects with an existing gradient, the gradient needs
            // to be repositioned (#3801)
            if (existingGradient && existingGradient.radAttr) {
                existingGradient.animate(
                    this.renderer.getRadialAttr(
                        coordinates,
                        existingGradient.radAttr
                    )
                );
            }

            return this;
        },

        /**
         * Move an object and its children by x and y values
         * @param {Number} x
         * @param {Number} y
         */
        translate: function (x, y) {
            return this.attr({
                translateX: x,
                translateY: y
            });
        },

        /**
         * Invert a group, rotate and flip
         */
        invert: function () {
            var wrapper = this;
            wrapper.inverted = true;
            wrapper.updateTransform();
            return wrapper;
        },

        /**
         * Private method to update the transform attribute based on internal
         * properties
         */
        updateTransform: function () {
            var wrapper = this,
                translateX = wrapper.translateX || 0,
                translateY = wrapper.translateY || 0,
                scaleX = wrapper.scaleX,
                scaleY = wrapper.scaleY,
                inverted = wrapper.inverted,
                rotation = wrapper.rotation,
                element = wrapper.element,
                transform;

            // flipping affects translate as adjustment for flipping around the group's axis
            if (inverted) {
                translateX += wrapper.attr('width');
                translateY += wrapper.attr('height');
            }

            // Apply translate. Nearly all transformed elements have translation, so instead
            // of checking for translate = 0, do it always (#1767, #1846).
            transform = ['translate(' + translateX + ',' + translateY + ')'];

            // apply rotation
            if (inverted) {
                transform.push('rotate(90) scale(-1,1)');
            } else if (rotation) { // text rotation
                transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');

                // Delete bBox memo when the rotation changes
                //delete wrapper.bBox;
            }

            // apply scale
            if (defined(scaleX) || defined(scaleY)) {
                transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');
            }

            if (transform.length) {
                element.setAttribute('transform', transform.join(' '));
            }
        },
        /**
         * Bring the element to the front
         */
        toFront: function () {
            var element = this.element;
            element.parentNode.appendChild(element);
            return this;
        },


        /**
         * Break down alignment options like align, verticalAlign, x and y
         * to x and y relative to the chart.
         *
         * @param {Object} alignOptions
         * @param {Boolean} alignByTranslate
         * @param {String[Object} box The box to align to, needs a width and height. When the
         *        box is a string, it refers to an object in the Renderer. For example, when
         *        box is 'spacingBox', it refers to Renderer.spacingBox which holds width, height
         *        x and y properties.
         *
         */
        align: function (alignOptions, alignByTranslate, box) {
            var align,
                vAlign,
                x,
                y,
                attribs = {},
                alignTo,
                renderer = this.renderer,
                alignedObjects = renderer.alignedObjects;

            // First call on instanciate
            if (alignOptions) {
                this.alignOptions = alignOptions;
                this.alignByTranslate = alignByTranslate;
                if (!box || isString(box)) { // boxes other than renderer handle this internally
                    this.alignTo = alignTo = box || 'renderer';
                    erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize
                    alignedObjects.push(this);
                    box = null; // reassign it below
                }

            // When called on resize, no arguments are supplied
            } else {
                alignOptions = this.alignOptions;
                alignByTranslate = this.alignByTranslate;
                alignTo = this.alignTo;
            }

            box = pick(box, renderer[alignTo], renderer);

            // Assign variables
            align = alignOptions.align;
            vAlign = alignOptions.verticalAlign;
            x = (box.x || 0) + (alignOptions.x || 0); // default: left align
            y = (box.y || 0) + (alignOptions.y || 0); // default: top align

            // Align
            if (align === 'right' || align === 'center') {
                x += (box.width - (alignOptions.width || 0)) /
                        { right: 1, center: 2 }[align];
            }
            attribs[alignByTranslate ? 'translateX' : 'x'] = mathRound(x);


            // Vertical align
            if (vAlign === 'bottom' || vAlign === 'middle') {
                y += (box.height - (alignOptions.height || 0)) /
                        ({ bottom: 1, middle: 2 }[vAlign] || 1);

            }
            attribs[alignByTranslate ? 'translateY' : 'y'] = mathRound(y);

            // Animate only if already placed
            this[this.placed ? 'animate' : 'attr'](attribs);
            this.placed = true;
            this.alignAttr = attribs;

            return this;
        },

        /**
         * Get the bounding box (width, height, x and y) for the element
         */
        getBBox: function (reload, rot) {
            var wrapper = this,
                bBox, // = wrapper.bBox,
                renderer = wrapper.renderer,
                width,
                height,
                rotation,
                rad,
                element = wrapper.element,
                styles = wrapper.styles,
                textStr = wrapper.textStr,
                textShadow,
                elemStyle = element.style,
                toggleTextShadowShim,
                cache = renderer.cache,
                cacheKeys = renderer.cacheKeys,
                cacheKey;

            rotation = pick(rot, wrapper.rotation);
            rad = rotation * deg2rad;

            if (textStr !== UNDEFINED) {

                // Properties that affect bounding box
                cacheKey = ['', rotation || 0, styles && styles.fontSize, element.style.width].join(',');

                // Since numbers are monospaced, and numerical labels appear a lot in a chart,
                // we assume that a label of n characters has the same bounding box as others
                // of the same length.
                if (textStr === '' || numRegex.test(textStr)) {
                    cacheKey = 'num:' + textStr.toString().length + cacheKey;

                // Caching all strings reduces rendering time by 4-5%.
                } else {
                    cacheKey = textStr + cacheKey;
                }
            }

            if (cacheKey && !reload) {
                bBox = cache[cacheKey];
            }

            // No cache found
            if (!bBox) {

                // SVG elements
                if (element.namespaceURI === SVG_NS || renderer.forExport) {
                    try { // Fails in Firefox if the container has display: none.

                        // When the text shadow shim is used, we need to hide the fake shadows
                        // to get the correct bounding box (#3872)
                        toggleTextShadowShim = this.fakeTS && function (display) {
                            each(element.querySelectorAll('.' + PREFIX + 'text-shadow'), function (tspan) {
                                tspan.style.display = display;
                            });
                        };

                        // Workaround for #3842, Firefox reporting wrong bounding box for shadows
                        if (isFirefox && elemStyle.textShadow) {
                            textShadow = elemStyle.textShadow;
                            elemStyle.textShadow = '';
                        } else if (toggleTextShadowShim) {
                            toggleTextShadowShim(NONE);
                        }

                        bBox = element.getBBox ?
                            // SVG: use extend because IE9 is not allowed to change width and height in case
                            // of rotation (below)
                            extend({}, element.getBBox()) :
                            // Canvas renderer and legacy IE in export mode
                            {
                                width: element.offsetWidth,
                                height: element.offsetHeight
                            };

                        // #3842
                        if (textShadow) {
                            elemStyle.textShadow = textShadow;
                        } else if (toggleTextShadowShim) {
                            toggleTextShadowShim('');
                        }
                    } catch (e) {}

                    // If the bBox is not set, the try-catch block above failed. The other condition
                    // is for Opera that returns a width of -Infinity on hidden elements.
                    if (!bBox || bBox.width < 0) {
                        bBox = { width: 0, height: 0 };
                    }


                // VML Renderer or useHTML within SVG
                } else {

                    bBox = wrapper.htmlGetBBox();

                }

                // True SVG elements as well as HTML elements in modern browsers using the .useHTML option
                // need to compensated for rotation
                if (renderer.isSVG) {
                    width = bBox.width;
                    height = bBox.height;

                    // Workaround for wrong bounding box in IE9 and IE10 (#1101, #1505, #1669, #2568)
                    if (isMS && styles && styles.fontSize === '11px' && height.toPrecision(3) === '16.9') {
                        bBox.height = height = 14;
                    }

                    // Adjust for rotated text
                    if (rotation) {
                        bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
                        bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
                    }
                }

                // Cache it
                if (cacheKey) {

                    // Rotate (#4681)
                    while (cacheKeys.length > 250) {
                        delete cache[cacheKeys.shift()];
                    }

                    if (!cache[cacheKey]) {
                        cacheKeys.push(cacheKey);
                    }
                    cache[cacheKey] = bBox;
                }
            }
            return bBox;
        },

        /**
         * Show the element
         */
        show: function (inherit) {
            return this.attr({ visibility: inherit ? 'inherit' : VISIBLE });
        },

        /**
         * Hide the element
         */
        hide: function () {
            return this.attr({ visibility: HIDDEN });
        },

        fadeOut: function (duration) {
            var elemWrapper = this;
            elemWrapper.animate({
                opacity: 0
            }, {
                duration: duration || 150,
                complete: function () {
                    elemWrapper.attr({ y: -9999 }); // #3088, assuming we're only using this for tooltips
                }
            });
        },

        /**
         * Add the element
         * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
         *    to append the element to the renderer.box.
         */
        add: function (parent) {

            var renderer = this.renderer,
                element = this.element,
                inserted;

            if (parent) {
                this.parentGroup = parent;
            }

            // mark as inverted
            this.parentInverted = parent && parent.inverted;

            // build formatted text
            if (this.textStr !== undefined) {
                renderer.buildText(this);
            }

            // Mark as added
            this.added = true;

            // If we're adding to renderer root, or other elements in the group
            // have a z index, we need to handle it
            if (!parent || parent.handleZ || this.zIndex) {
                inserted = this.zIndexSetter();
            }

            // If zIndex is not handled, append at the end
            if (!inserted) {
                (parent ? parent.element : renderer.box).appendChild(element);
            }

            // fire an event for internal hooks
            if (this.onAdd) {
                this.onAdd();
            }

            return this;
        },

        /**
         * Removes a child either by removeChild or move to garbageBin.
         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
         */
        safeRemoveChild: function (element) {
            var parentNode = element.parentNode;
            if (parentNode) {
                parentNode.removeChild(element);
            }
        },

        /**
         * Destroy the element and element wrapper
         */
        destroy: function () {
            var wrapper = this,
                element = wrapper.element || {},
                shadows = wrapper.shadows,
                parentToClean = wrapper.renderer.isSVG && element.nodeName === 'SPAN' && wrapper.parentGroup,
                grandParent,
                key,
                i;

            // remove events
            element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
            stop(wrapper); // stop running animations

            if (wrapper.clipPath) {
                wrapper.clipPath = wrapper.clipPath.destroy();
            }

            // Destroy stops in case this is a gradient object
            if (wrapper.stops) {
                for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i] = wrapper.stops[i].destroy();
                }
                wrapper.stops = null;
            }

            // remove element
            wrapper.safeRemoveChild(element);

            // destroy shadows
            if (shadows) {
                each(shadows, function (shadow) {
                    wrapper.safeRemoveChild(shadow);
                });
            }

            // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).
            while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
                grandParent = parentToClean.parentGroup;
                wrapper.safeRemoveChild(parentToClean.div);
                delete parentToClean.div;
                parentToClean = grandParent;
            }

            // remove from alignObjects
            if (wrapper.alignTo) {
                erase(wrapper.renderer.alignedObjects, wrapper);
            }

            for (key in wrapper) {
                delete wrapper[key];
            }

            return null;
        },

        /**
         * Add a shadow to the element. Must be done after the element is added to the DOM
         * @param {Boolean|Object} shadowOptions
         */
        shadow: function (shadowOptions, group, cutOff) {
            var shadows = [],
                i,
                shadow,
                element = this.element,
                strokeWidth,
                shadowWidth,
                shadowElementOpacity,

                // compensate for inverted plot area
                transform;


            if (shadowOptions) {
                shadowWidth = pick(shadowOptions.width, 3);
                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                transform = this.parentInverted ?
                        '(-1,-1)' :
                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';
                for (i = 1; i <= shadowWidth; i++) {
                    shadow = element.cloneNode(0);
                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);
                    attr(shadow, {
                        'isShadow': 'true',
                        'stroke': shadowOptions.color || 'black',
                        'stroke-opacity': shadowElementOpacity * i,
                        'stroke-width': strokeWidth,
                        'transform': 'translate' + transform,
                        'fill': NONE
                    });
                    if (cutOff) {
                        attr(shadow, 'height', mathMax(attr(shadow, 'height') - strokeWidth, 0));
                        shadow.cutHeight = strokeWidth;
                    }

                    if (group) {
                        group.element.appendChild(shadow);
                    } else {
                        element.parentNode.insertBefore(shadow, element);
                    }

                    shadows.push(shadow);
                }

                this.shadows = shadows;
            }
            return this;

        },

        xGetter: function (key) {
            if (this.element.nodeName === 'circle') {
                key = { x: 'cx', y: 'cy' }[key] || key;
            }
            return this._defaultGetter(key);
        },

        /**
         * Get the current value of an attribute or pseudo attribute, used mainly
         * for animation.
         */
        _defaultGetter: function (key) {
            var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);

            if (/^[\-0-9\.]+$/.test(ret)) { // is numerical
                ret = parseFloat(ret);
            }
            return ret;
        },


        dSetter: function (value, key, element) {
            if (value && value.join) { // join path
                value = value.join(' ');
            }
            if (/(NaN| {2}|^$)/.test(value)) {
                value = 'M 0 0';
            }
            element.setAttribute(key, value);

            this[key] = value;
        },
        dashstyleSetter: function (value) {
            var i,
                strokeWidth = this['stroke-width'];
        
            // If "inherit", like maps in IE, assume 1 (#4981). With HC5 and the new strokeWidth 
            // function, we should be able to use that instead.
            if (strokeWidth === 'inherit') {
                strokeWidth = 1;
            }
            value = value && value.toLowerCase();
            if (value) {
                value = value
                    .replace('shortdashdotdot', '3,1,1,1,1,1,')
                    .replace('shortdashdot', '3,1,1,1')
                    .replace('shortdot', '1,1,')
                    .replace('shortdash', '3,1,')
                    .replace('longdash', '8,3,')
                    .replace(/dot/g, '1,3,')
                    .replace('dash', '4,3,')
                    .replace(/,$/, '')
                    .split(','); // ending comma

                i = value.length;
                while (i--) {
                    value[i] = pInt(value[i]) * strokeWidth;
                }
                value = value.join(',')
                    .replace(/NaN/g, 'none'); // #3226
                this.element.setAttribute('stroke-dasharray', value);
            }
        },
        alignSetter: function (value) {
            this.element.setAttribute('text-anchor', { left: 'start', center: 'middle', right: 'end' }[value]);
        },
        opacitySetter: function (value, key, element) {
            this[key] = value;
            element.setAttribute(key, value);
        },
        titleSetter: function (value) {
            var titleNode = this.element.getElementsByTagName('title')[0];
            if (!titleNode) {
                titleNode = doc.createElementNS(SVG_NS, 'title');
                this.element.appendChild(titleNode);
            }

            // Remove text content if it exists
            if (titleNode.firstChild) {
                titleNode.removeChild(titleNode.firstChild);
            }

            titleNode.appendChild(
                doc.createTextNode(
                    (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895
                )
            );
        },
        textSetter: function (value) {
            if (value !== this.textStr) {
                // Delete bBox memo when the text changes
                delete this.bBox;

                this.textStr = value;
                if (this.added) {
                    this.renderer.buildText(this);
                }
            }
        },
        fillSetter: function (value, key, element) {
            if (typeof value === 'string') {
                element.setAttribute(key, value);
            } else if (value) {
                this.colorGradient(value, key, element);
            }
        },
        visibilitySetter: function (value, key, element) {
            // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)
            if (value === 'inherit') {
                element.removeAttribute(key);
            } else {
                element.setAttribute(key, value);
            }
        },
        zIndexSetter: function (value, key) {
            var renderer = this.renderer,
                parentGroup = this.parentGroup,
                parentWrapper = parentGroup || renderer,
                parentNode = parentWrapper.element || renderer.box,
                childNodes,
                otherElement,
                otherZIndex,
                element = this.element,
                inserted,
                run = this.added,
                i;

            if (defined(value)) {
                element.zIndex = value; // So we can read it for other elements in the group
                value = +value;
                if (this[key] === value) { // Only update when needed (#3865)
                    run = false;
                }
                this[key] = value;
            }

            // Insert according to this and other elements' zIndex. Before .add() is called,
            // nothing is done. Then on add, or by later calls to zIndexSetter, the node
            // is placed on the right place in the DOM.
            if (run) {
                value = this.zIndex;

                if (value && parentGroup) {
                    parentGroup.handleZ = true;
                }

                childNodes = parentNode.childNodes;
                for (i = 0; i < childNodes.length && !inserted; i++) {
                    otherElement = childNodes[i];
                    otherZIndex = otherElement.zIndex;
                    if (otherElement !== element && (
                            // Insert before the first element with a higher zIndex
                            pInt(otherZIndex) > value ||
                            // If no zIndex given, insert before the first element with a zIndex
                            (!defined(value) && defined(otherZIndex))

                        )) {
                        parentNode.insertBefore(element, otherElement);
                        inserted = true;
                    }
                }
                if (!inserted) {
                    parentNode.appendChild(element);
                }
            }
            return inserted;
        },
        _defaultSetter: function (value, key, element) {
            element.setAttribute(key, value);
        }
    };

    // Some shared setters and getters
    SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
    SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function (value, key) {
                this[key] = value;
                this.doTransform = true;
            };

    // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the
    // stroke attribute altogether. #1270, #1369, #3065, #3072.
    SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function (value, key, element) {
        this[key] = value;
        // Only apply the stroke attribute if the stroke width is defined and larger than 0
        if (this.stroke && this['stroke-width']) {
            this.strokeWidth = this['stroke-width'];
            SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden
            element.setAttribute('stroke-width', this['stroke-width']);
            this.hasStroke = true;
        } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {
            element.removeAttribute('stroke');
            this.hasStroke = false;
        }
    };


    /**
     * The default SVG renderer
     */
    var SVGRenderer = function () {
        this.init.apply(this, arguments);
    };
    SVGRenderer.prototype = {
        Element: SVGElement,

        /**
         * Initialize the SVGRenderer
         * @param {Object} container
         * @param {Number} width
         * @param {Number} height
         * @param {Boolean} forExport
         */
        init: function (container, width, height, style, forExport, allowHTML) {
            var renderer = this,
                boxWrapper,
                element,
                desc;

            boxWrapper = renderer.createElement('svg')
                .attr({
                    version: '1.1'
                })
                .css(this.getStyle(style));
            element = boxWrapper.element;
            container.appendChild(element);

            // For browsers other than IE, add the namespace attribute (#1978)
            if (container.innerHTML.indexOf('xmlns') === -1) {
                attr(element, 'xmlns', SVG_NS);
            }

            // object properties
            renderer.isSVG = true;
            renderer.box = element;
            renderer.boxWrapper = boxWrapper;
            renderer.alignedObjects = [];

            // Page url used for internal references. #24, #672, #1070
            renderer.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?
                    win.location.href
                        .replace(/#.*?$/, '') // remove the hash
                        .replace(/([\('\)])/g, '\\$1') // escape parantheses and quotes
                        .replace(/ /g, '%20') : // replace spaces (needed for Safari only)
                    '';

            // Add description
            desc = this.createElement('desc').add();
            desc.element.appendChild(doc.createTextNode('Created with ' + PRODUCT + ' ' + VERSION));


            renderer.defs = this.createElement('defs').add();
            renderer.allowHTML = allowHTML;
            renderer.forExport = forExport;
            renderer.gradients = {}; // Object where gradient SvgElements are stored
            renderer.cache = {}; // Cache for numerical bounding boxes
            renderer.cacheKeys = [];
            renderer.imgCount = 0;

            renderer.setSize(width, height, false);



            // Issue 110 workaround:
            // In Firefox, if a div is positioned by percentage, its pixel position may land
            // between pixels. The container itself doesn't display this, but an SVG element
            // inside this container will be drawn at subpixel precision. In order to draw
            // sharp lines, this must be compensated for. This doesn't seem to work inside
            // iframes though (like in jsFiddle).
            var subPixelFix, rect;
            if (isFirefox && container.getBoundingClientRect) {
                renderer.subPixelFix = subPixelFix = function () {
                    css(container, { left: 0, top: 0 });
                    rect = container.getBoundingClientRect();
                    css(container, {
                        left: (mathCeil(rect.left) - rect.left) + PX,
                        top: (mathCeil(rect.top) - rect.top) + PX
                    });
                };

                // run the fix now
                subPixelFix();

                // run it on resize
                addEvent(win, 'resize', subPixelFix);
            }
        },

        getStyle: function (style) {
            this.style = extend({
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', // default font
                fontSize: '12px'
            }, style);
            return this.style;
        },

        /**
         * Detect whether the renderer is hidden. This happens when one of the parent elements
         * has display: none. #608.
         */
        isHidden: function () {
            return !this.boxWrapper.getBBox().width;
        },

        /**
         * Destroys the renderer and its allocated members.
         */
        destroy: function () {
            var renderer = this,
                rendererDefs = renderer.defs;
            renderer.box = null;
            renderer.boxWrapper = renderer.boxWrapper.destroy();

            // Call destroy on all gradient elements
            destroyObjectProperties(renderer.gradients || {});
            renderer.gradients = null;

            // Defs are null in VMLRenderer
            // Otherwise, destroy them here.
            if (rendererDefs) {
                renderer.defs = rendererDefs.destroy();
            }

            // Remove sub pixel fix handler
            // We need to check that there is a handler, otherwise all functions that are registered for event 'resize' are removed
            // See issue #982
            if (renderer.subPixelFix) {
                removeEvent(win, 'resize', renderer.subPixelFix);
            }

            renderer.alignedObjects = null;

            return null;
        },

        /**
         * Create a wrapper for an SVG element
         * @param {Object} nodeName
         */
        createElement: function (nodeName) {
            var wrapper = new this.Element();
            wrapper.init(this, nodeName);
            return wrapper;
        },

        /**
         * Dummy function for use in canvas renderer
         */
        draw: function () {},

        /**
         * Get converted radial gradient attributes
         */
        getRadialAttr: function (radialReference, gradAttr) {
            return {
                cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],
                cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],
                r: gradAttr.r * radialReference[2]
            };
        },

        /**
         * Parse a simple HTML string into SVG tspans
         *
         * @param {Object} textNode The parent text SVG node
         */
        buildText: function (wrapper) {
            var textNode = wrapper.element,
                renderer = this,
                forExport = renderer.forExport,
                textStr = pick(wrapper.textStr, '').toString(),
                hasMarkup = textStr.indexOf('<') !== -1,
                lines,
                childNodes = textNode.childNodes,
                styleRegex,
                hrefRegex,
                wasTooLong,
                parentX = attr(textNode, 'x'),
                textStyles = wrapper.styles,
                width = wrapper.textWidth,
                textLineHeight = textStyles && textStyles.lineHeight,
                textShadow = textStyles && textStyles.textShadow,
                ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',
                i = childNodes.length,
                tempParent = width && !wrapper.added && this.box,
                getLineHeight = function (tspan) {
                    return textLineHeight ?
                            pInt(textLineHeight) :
                            renderer.fontMetrics(
                                /(px|em)$/.test(tspan && tspan.style.fontSize) ?
                                        tspan.style.fontSize :
                                        ((textStyles && textStyles.fontSize) || renderer.style.fontSize || 12),
                                tspan
                            ).h;
                },
                unescapeAngleBrackets = function (inputStr) {
                    return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                };

            /// remove old text
            while (i--) {
                textNode.removeChild(childNodes[i]);
            }

            // Skip tspans, add text directly to text node. The forceTSpan is a hook
            // used in text outline hack.
            if (!hasMarkup && !textShadow && !ellipsis && !width && textStr.indexOf(' ') === -1) {
                textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));

            // Complex strings, add more logic
            } else {

                styleRegex = /<.*style="([^"]+)".*>/;
                hrefRegex = /<.*href="(http[^"]+)".*>/;

                if (tempParent) {
                    tempParent.appendChild(textNode); // attach it to the DOM to read offset width
                }

                if (hasMarkup) {
                    lines = textStr
                        .replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
                        .replace(/<(i|em)>/g, '<span style="font-style:italic">')
                        .replace(/<a/g, '<span')
                        .replace(/<\/(b|strong|i|em|a)>/g, '</span>')
                        .split(/<br.*?>/g);

                } else {
                    lines = [textStr];
                }


                // Trim empty lines (#5261)
                lines = grep(lines, function (line) {
                    return line !== '';
                });


                // build the lines
                each(lines, function buildTextLines(line, lineNo) {
                    var spans,
                        spanNo = 0;
                    line = line
                        .replace(/^\s+|\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)
                        .replace(/<span/g, '|||<span')
                        .replace(/<\/span>/g, '</span>|||');
                    spans = line.split('|||');

                    each(spans, function buildTextSpans(span) {
                        if (span !== '' || spans.length === 1) {
                            var attributes = {},
                                tspan = doc.createElementNS(SVG_NS, 'tspan'),
                                spanStyle; // #390
                            if (styleRegex.test(span)) {
                                spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');
                                attr(tspan, 'style', spanStyle);
                            }
                            if (hrefRegex.test(span) && !forExport) { // Not for export - #1529
                                attr(tspan, 'onclick', 'location.href=\"' + span.match(hrefRegex)[1] + '\"');
                                css(tspan, { cursor: 'pointer' });
                            }

                            span = unescapeAngleBrackets(span.replace(/<(.|\n)*?>/g, '') || ' ');

                            // Nested tags aren't supported, and cause crash in Safari (#1596)
                            if (span !== ' ') {

                                // add the text node
                                tspan.appendChild(doc.createTextNode(span));

                                if (!spanNo) { // first span in a line, align it to the left
                                    if (lineNo && parentX !== null) {
                                        attributes.x = parentX;
                                    }
                                } else {
                                    attributes.dx = 0; // #16
                                }

                                // add attributes
                                attr(tspan, attributes);

                                // Append it
                                textNode.appendChild(tspan);

                                // first span on subsequent line, add the line height
                                if (!spanNo && lineNo) {

                                    // allow getting the right offset height in exporting in IE
                                    if (!hasSVG && forExport) {
                                        css(tspan, { display: 'block' });
                                    }

                                    // Set the line height based on the font size of either
                                    // the text element or the tspan element
                                    attr(
                                        tspan,
                                        'dy',
                                        getLineHeight(tspan)
                                    );
                                }

                                /*if (width) {
                                    renderer.breakText(wrapper, width);
                                }*/

                                // Check width and apply soft breaks or ellipsis
                                if (width) {
                                    var words = span.replace(/([^\^])-/g, '$1- ').split(' '), // #1273
                                        hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && textStyles.whiteSpace !== 'nowrap'),
                                        tooLong,
                                        actualWidth,
                                        rest = [],
                                        dy = getLineHeight(tspan),
                                        softLineNo = 1,
                                        rotation = wrapper.rotation,
                                        wordStr = span, // for ellipsis
                                        cursor = wordStr.length, // binary search cursor
                                        bBox;

                                    while ((hasWhiteSpace || ellipsis) && (words.length || rest.length)) {
                                        wrapper.rotation = 0; // discard rotation when computing box
                                        bBox = wrapper.getBBox(true);
                                        actualWidth = bBox.width;

                                        // Old IE cannot measure the actualWidth for SVG elements (#2314)
                                        if (!hasSVG && renderer.forExport) {
                                            actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
                                        }

                                        tooLong = actualWidth > width;

                                        // For ellipsis, do a binary search for the correct string length
                                        if (wasTooLong === undefined) {
                                            wasTooLong = tooLong; // First time
                                        }
                                        if (ellipsis && wasTooLong) {
                                            cursor /= 2;

                                            if (wordStr === '' || (!tooLong && cursor < 0.5)) {
                                                words = []; // All ok, break out
                                            } else {
                                                wordStr = span.substring(0, wordStr.length + (tooLong ? -1 : 1) * mathCeil(cursor));
                                                words = [wordStr + (width > 3 ? '\u2026' : '')];
                                                tspan.removeChild(tspan.firstChild);
                                            }

                                        // Looping down, this is the first word sequence that is not too long,
                                        // so we can move on to build the next line.
                                        } else if (!tooLong || words.length === 1) {
                                            words = rest;
                                            rest = [];

                                            if (words.length) {
                                                softLineNo++;

                                                tspan = doc.createElementNS(SVG_NS, 'tspan');
                                                attr(tspan, {
                                                    dy: dy,
                                                    x: parentX
                                                });
                                                if (spanStyle) { // #390
                                                    attr(tspan, 'style', spanStyle);
                                                }
                                                textNode.appendChild(tspan);
                                            }
                                            if (actualWidth > width) { // a single word is pressing it out
                                                width = actualWidth;
                                            }
                                        } else { // append to existing line tspan
                                            tspan.removeChild(tspan.firstChild);
                                            rest.unshift(words.pop());
                                        }
                                        if (words.length) {
                                            tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));
                                        }
                                    }
                                    wrapper.rotation = rotation;
                                }

                                spanNo++;
                            }
                        }
                    });
                });

                if (wasTooLong) {
                    wrapper.attr('title', wrapper.textStr);
                }
                if (tempParent) {
                    tempParent.removeChild(textNode); // attach it to the DOM to read offset width
                }

                // Apply the text shadow
                if (textShadow && wrapper.applyTextShadow) {
                    wrapper.applyTextShadow(textShadow);
                }
            }
        },



        /*
        breakText: function (wrapper, width) {
            var bBox = wrapper.getBBox(),
                node = wrapper.element,
                textLength = node.textContent.length,
                pos = mathRound(width * textLength / bBox.width), // try this position first, based on average character width
                increment = 0,
                finalPos;

            if (bBox.width > width) {
                while (finalPos === undefined) {
                    textLength = node.getSubStringLength(0, pos);

                    if (textLength <= width) {
                        if (increment === -1) {
                            finalPos = pos;
                        } else {
                            increment = 1;
                        }
                    } else {
                        if (increment === 1) {
                            finalPos = pos - 1;
                        } else {
                            increment = -1;
                        }
                    }
                    pos += increment;
                }
            }
            console.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))
        },
        */

        /**
         * Returns white for dark colors and black for bright colors
         */
        getContrast: function (color) {
            color = Color(color).rgba;
            return color[0] + color[1] + color[2] > 384 ? '#000000' : '#FFFFFF';
        },

        /**
         * Create a button with preset states
         * @param {String} text
         * @param {Number} x
         * @param {Number} y
         * @param {Function} callback
         * @param {Object} normalState
         * @param {Object} hoverState
         * @param {Object} pressedState
         */
        button: function (text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {
            var label = this.label(text, x, y, shape, null, null, null, null, 'button'),
                curState = 0,
                stateOptions,
                stateStyle,
                normalStyle,
                hoverStyle,
                pressedStyle,
                disabledStyle,
                verticalGradient = { x1: 0, y1: 0, x2: 0, y2: 1 };

            // Normal state - prepare the attributes
            normalState = merge({
                'stroke-width': 1,
                stroke: '#CCCCCC',
                fill: {
                    linearGradient: verticalGradient,
                    stops: [
                        [0, '#FEFEFE'],
                        [1, '#F6F6F6']
                    ]
                },
                r: 2,
                padding: 5,
                style: {
                    color: 'black'
                }
            }, normalState);
            normalStyle = normalState.style;
            delete normalState.style;

            // Hover state
            hoverState = merge(normalState, {
                stroke: '#68A',
                fill: {
                    linearGradient: verticalGradient,
                    stops: [
                        [0, '#FFF'],
                        [1, '#ACF']
                    ]
                }
            }, hoverState);
            hoverStyle = hoverState.style;
            delete hoverState.style;

            // Pressed state
            pressedState = merge(normalState, {
                stroke: '#68A',
                fill: {
                    linearGradient: verticalGradient,
                    stops: [
                        [0, '#9BD'],
                        [1, '#CDF']
                    ]
                }
            }, pressedState);
            pressedStyle = pressedState.style;
            delete pressedState.style;

            // Disabled state
            disabledState = merge(normalState, {
                style: {
                    color: '#CCC'
                }
            }, disabledState);
            disabledStyle = disabledState.style;
            delete disabledState.style;

            // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).
            addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {
                if (curState !== 3) {
                    label.attr(hoverState)
                        .css(hoverStyle);
                }
            });
            addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {
                if (curState !== 3) {
                    stateOptions = [normalState, hoverState, pressedState][curState];
                    stateStyle = [normalStyle, hoverStyle, pressedStyle][curState];
                    label.attr(stateOptions)
                        .css(stateStyle);
                }
            });

            label.setState = function (state) {
                label.state = curState = state;
                if (!state) {
                    label.attr(normalState)
                        .css(normalStyle);
                } else if (state === 2) {
                    label.attr(pressedState)
                        .css(pressedStyle);
                } else if (state === 3) {
                    label.attr(disabledState)
                        .css(disabledStyle);
                }
            };

            return label
                .on('click', function (e) {
                    if (curState !== 3) {
                        callback.call(label, e);
                    }
                })
                .attr(normalState)
                .css(extend({ cursor: 'default' }, normalStyle));
        },

        /**
         * Make a straight line crisper by not spilling out to neighbour pixels
         * @param {Array} points
         * @param {Number} width
         */
        crispLine: function (points, width) {
            // points format: [M, 0, 0, L, 100, 0]
            // normalize to a crisp line
            if (points[1] === points[4]) {
                // Substract due to #1129. Now bottom and left axis gridlines behave the same.
                points[1] = points[4] = mathRound(points[1]) - (width % 2 / 2);
            }
            if (points[2] === points[5]) {
                points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
            }
            return points;
        },


        /**
         * Draw a path
         * @param {Array} path An SVG path in array form
         */
        path: function (path) {
            var attr = {
                fill: NONE
            };
            if (isArray(path)) {
                attr.d = path;
            } else if (isObject(path)) { // attributes
                extend(attr, path);
            }
            return this.createElement('path').attr(attr);
        },

        /**
         * Draw and return an SVG circle
         * @param {Number} x The x position
         * @param {Number} y The y position
         * @param {Number} r The radius
         */
        circle: function (x, y, r) {
            var attr = isObject(x) ? x : { x: x, y: y, r: r },
                wrapper = this.createElement('circle');

            // Setting x or y translates to cx and cy
            wrapper.xSetter = wrapper.ySetter = function (value, key, element) {
                element.setAttribute('c' + key, value);
            };

            return wrapper.attr(attr);
        },

        /**
         * Draw and return an arc
         * @param {Number} x X position
         * @param {Number} y Y position
         * @param {Number} r Radius
         * @param {Number} innerR Inner radius like used in donut charts
         * @param {Number} start Starting angle
         * @param {Number} end Ending angle
         */
        arc: function (x, y, r, innerR, start, end) {
            var arc;

            if (isObject(x)) {
                y = x.y;
                r = x.r;
                innerR = x.innerR;
                start = x.start;
                end = x.end;
                x = x.x;
            }

            // Arcs are defined as symbols for the ability to set
            // attributes in attr and animate
            arc = this.symbol('arc', x || 0, y || 0, r || 0, r || 0, {
                innerR: innerR || 0,
                start: start || 0,
                end: end || 0
            });
            arc.r = r; // #959
            return arc;
        },

        /**
         * Draw and return a rectangle
         * @param {Number} x Left position
         * @param {Number} y Top position
         * @param {Number} width
         * @param {Number} height
         * @param {Number} r Border corner radius
         * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
         */
        rect: function (x, y, width, height, r, strokeWidth) {

            r = isObject(x) ? x.r : r;

            var wrapper = this.createElement('rect'),
                attribs = isObject(x) ? x : x === UNDEFINED ? {} : {
                    x: x,
                    y: y,
                    width: mathMax(width, 0),
                    height: mathMax(height, 0)
                };

            if (strokeWidth !== UNDEFINED) {
                wrapper.strokeWidth = strokeWidth;
                attribs = wrapper.crisp(attribs);
            }

            if (r) {
                attribs.r = r;
            }

            wrapper.rSetter = function (value, key, element) {
                attr(element, {
                    rx: value,
                    ry: value
                });
            };

            return wrapper.attr(attribs);
        },

        /**
         * Resize the box and re-align all aligned elements
         * @param {Object} width
         * @param {Object} height
         * @param {Boolean} animate
         *
         */
        setSize: function (width, height, animate) {
            var renderer = this,
                alignedObjects = renderer.alignedObjects,
                i = alignedObjects.length;

            renderer.width = width;
            renderer.height = height;

            renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
                width: width,
                height: height
            });

            while (i--) {
                alignedObjects[i].align();
            }
        },

        /**
         * Create a group
         * @param {String} name The group will be given a class name of 'highcharts-{name}'.
         *     This can be used for styling and scripting.
         */
        g: function (name) {
            var elem = this.createElement('g');
            return defined(name) ? elem.attr({ 'class': PREFIX + name }) : elem;
        },

        /**
         * Display an image
         * @param {String} src
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         */
        image: function (src, x, y, width, height) {
            var attribs = {
                    preserveAspectRatio: NONE
                },
                elemWrapper;

            // optional properties
            if (arguments.length > 1) {
                extend(attribs, {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            }

            elemWrapper = this.createElement('image').attr(attribs);

            // set the href in the xlink namespace
            if (elemWrapper.element.setAttributeNS) {
                elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',
                    'href', src);
            } else {
                // could be exporting in IE
                // using href throws "not supported" in ie7 and under, requries regex shim to fix later
                elemWrapper.element.setAttribute('hc-svg-href', src);
            }
            return elemWrapper;
        },

        /**
         * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
         *
         * @param {Object} symbol
         * @param {Object} x
         * @param {Object} y
         * @param {Object} radius
         * @param {Object} options
         */
        symbol: function (symbol, x, y, width, height, options) {

            var ren = this,
                obj,

                // get the symbol definition function
                symbolFn = this.symbols[symbol],

                // check if there's a path defined for this symbol
                path = symbolFn && symbolFn(
                    mathRound(x),
                    mathRound(y),
                    width,
                    height,
                    options
                ),

                imageRegex = /^url\((.*?)\)$/,
                imageSrc,
                imageSize,
                centerImage;

            if (path) {

                obj = this.path(path);
                // expando properties for use in animate and attr
                extend(obj, {
                    symbolName: symbol,
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
                if (options) {
                    extend(obj, options);
                }


            // image symbols
            } else if (imageRegex.test(symbol)) {

                // On image load, set the size and position
                centerImage = function (img, size) {
                    if (img.element) { // it may be destroyed in the meantime (#1390)
                        img.attr({
                            width: size[0],
                            height: size[1]
                        });

                        if (!img.alignByTranslate) { // #185
                            img.translate(
                                mathRound((width - size[0]) / 2), // #1378
                                mathRound((height - size[1]) / 2)
                            );
                        }
                    }
                };

                imageSrc = symbol.match(imageRegex)[1];
                imageSize = symbolSizes[imageSrc] || (options && options.width && options.height && [options.width, options.height]);

                // Ireate the image synchronously, add attribs async
                obj = this.image(imageSrc)
                    .attr({
                        x: x,
                        y: y
                    });
                obj.isImg = true;

                if (imageSize) {
                    centerImage(obj, imageSize);
                } else {
                    // Initialize image to be 0 size so export will still function if there's no cached sizes.
                    obj.attr({ width: 0, height: 0 });

                    // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,
                    // the created element must be assigned to a variable in order to load (#292).
                    createElement('img', {
                        onload: function () {

                            // Special case for SVGs on IE11, the width is not accessible until the image is
                            // part of the DOM (#2854).
                            if (this.width === 0) {
                                css(this, {
                                    position: ABSOLUTE,
                                    top: '-999em'
                                });
                                doc.body.appendChild(this);
                            }

                            // Center the image
                            centerImage(obj, symbolSizes[imageSrc] = [this.width, this.height]);

                            // Clean up after #2854 workaround.
                            if (this.parentNode) {
                                this.parentNode.removeChild(this);
                            }

                            // Fire the load event when all external images are loaded
                            ren.imgCount--;
                            if (!ren.imgCount && charts[ren.chartIndex].onload) {
                                charts[ren.chartIndex].onload();
                            }
                        },
                        src: imageSrc
                    });
                    this.imgCount++;
                }
            }

            return obj;
        },

        /**
         * An extendable collection of functions for defining symbol paths.
         */
        symbols: {
            'circle': function (x, y, w, h) {
                var cpw = 0.166 * w;
                return [
                    M, x + w / 2, y,
                    'C', x + w + cpw, y, x + w + cpw, y + h, x + w / 2, y + h,
                    'C', x - cpw, y + h, x - cpw, y, x + w / 2, y,
                    'Z'
                ];
            },

            'square': function (x, y, w, h) {
                return [
                    M, x, y,
                    L, x + w, y,
                    x + w, y + h,
                    x, y + h,
                    'Z'
                ];
            },

            'triangle': function (x, y, w, h) {
                return [
                    M, x + w / 2, y,
                    L, x + w, y + h,
                    x, y + h,
                    'Z'
                ];
            },

            'triangle-down': function (x, y, w, h) {
                return [
                    M, x, y,
                    L, x + w, y,
                    x + w / 2, y + h,
                    'Z'
                ];
            },
            'diamond': function (x, y, w, h) {
                return [
                    M, x + w / 2, y,
                    L, x + w, y + h / 2,
                    x + w / 2, y + h,
                    x, y + h / 2,
                    'Z'
                ];
            },
            'arc': function (x, y, w, h, options) {
                var start = options.start,
                    radius = options.r || w || h,
                    end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)
                    innerRadius = options.innerR,
                    open = options.open,
                    cosStart = mathCos(start),
                    sinStart = mathSin(start),
                    cosEnd = mathCos(end),
                    sinEnd = mathSin(end),
                    longArc = options.end - start < mathPI ? 0 : 1;

                return [
                    M,
                    x + radius * cosStart,
                    y + radius * sinStart,
                    'A', // arcTo
                    radius, // x radius
                    radius, // y radius
                    0, // slanting
                    longArc, // long or short arc
                    1, // clockwise
                    x + radius * cosEnd,
                    y + radius * sinEnd,
                    open ? M : L,
                    x + innerRadius * cosEnd,
                    y + innerRadius * sinEnd,
                    'A', // arcTo
                    innerRadius, // x radius
                    innerRadius, // y radius
                    0, // slanting
                    longArc, // long or short arc
                    0, // clockwise
                    x + innerRadius * cosStart,
                    y + innerRadius * sinStart,

                    open ? '' : 'Z' // close
                ];
            },

            /**
             * Callout shape used for default tooltips, also used for rounded rectangles in VML
             */
            callout: function (x, y, w, h, options) {
                var arrowLength = 6,
                    halfDistance = 6,
                    r = mathMin((options && options.r) || 0, w, h),
                    safeDistance = r + halfDistance,
                    anchorX = options && options.anchorX,
                    anchorY = options && options.anchorY,
                    path;

                path = [
                    'M', x + r, y,
                    'L', x + w - r, y, // top side
                    'C', x + w, y, x + w, y, x + w, y + r, // top-right corner
                    'L', x + w, y + h - r, // right side
                    'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner
                    'L', x + r, y + h, // bottom side
                    'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner
                    'L', x, y + r, // left side
                    'C', x, y, x, y, x + r, y // top-right corner
                ];

                if (anchorX && anchorX > w && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace right side
                    path.splice(13, 3,
                        'L', x + w, anchorY - halfDistance,
                        x + w + arrowLength, anchorY,
                        x + w, anchorY + halfDistance,
                        x + w, y + h - r
                        );
                } else if (anchorX && anchorX < 0 && anchorY > y + safeDistance && anchorY < y + h - safeDistance) { // replace left side
                    path.splice(33, 3,
                        'L', x, anchorY + halfDistance,
                        x - arrowLength, anchorY,
                        x, anchorY - halfDistance,
                        x, y + r
                        );
                } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom
                    path.splice(23, 3,
                        'L', anchorX + halfDistance, y + h,
                        anchorX, y + h + arrowLength,
                        anchorX - halfDistance, y + h,
                        x + r, y + h
                        );
                } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top
                    path.splice(3, 3,
                        'L', anchorX - halfDistance, y,
                        anchorX, y - arrowLength,
                        anchorX + halfDistance, y,
                        w - r, y
                        );
                }
                return path;
            }
        },

        /**
         * Define a clipping rectangle
         * @param {String} id
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         */
        clipRect: function (x, y, width, height) {
            var wrapper,
                id = PREFIX + idCounter++,

                clipPath = this.createElement('clipPath').attr({
                    id: id
                }).add(this.defs);

            wrapper = this.rect(x, y, width, height, 0).add(clipPath);
            wrapper.id = id;
            wrapper.clipPath = clipPath;
            wrapper.count = 0;

            return wrapper;
        },





        /**
         * Add text to the SVG object
         * @param {String} str
         * @param {Number} x Left position
         * @param {Number} y Top position
         * @param {Boolean} useHTML Use HTML to render the text
         */
        text: function (str, x, y, useHTML) {

            // declare variables
            var renderer = this,
                fakeSVG = useCanVG || (!hasSVG && renderer.forExport),
                wrapper,
                attr = {};

            if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
                return renderer.html(str, x, y);
            }

            attr.x = Math.round(x || 0); // X is always needed for line-wrap logic
            if (y) {
                attr.y = Math.round(y);
            }
            if (str || str === 0) {
                attr.text = str;
            }

            wrapper = renderer.createElement('text')
                .attr(attr);

            // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)
            if (fakeSVG) {
                wrapper.css({
                    position: ABSOLUTE
                });
            }

            if (!useHTML) {
                wrapper.xSetter = function (value, key, element) {
                    var tspans = element.getElementsByTagName('tspan'),
                        tspan,
                        parentVal = element.getAttribute(key),
                        i;
                    for (i = 0; i < tspans.length; i++) {
                        tspan = tspans[i];
                        // If the x values are equal, the tspan represents a linebreak
                        if (tspan.getAttribute(key) === parentVal) {
                            tspan.setAttribute(key, value);
                        }
                    }
                    element.setAttribute(key, value);
                };
            }

            return wrapper;
        },

        /**
         * Utility to return the baseline offset and total line height from the font size
         */
        fontMetrics: function (fontSize, elem) {
            var lineHeight,
                baseline,
                style;

            fontSize = fontSize || this.style.fontSize;
            if (!fontSize && elem && win.getComputedStyle) {
                elem = elem.element || elem; // SVGElement
                style = win.getComputedStyle(elem, '');
                fontSize = style && style.fontSize; // #4309, the style doesn't exist inside a hidden iframe in Firefox
            }
            fontSize = /px/.test(fontSize) ? pInt(fontSize) : /em/.test(fontSize) ? parseFloat(fontSize) * 12 : 12;

            // Empirical values found by comparing font size and bounding box height.
            // Applies to the default font family. http://jsfiddle.net/highcharts/7xvn7/
            lineHeight = fontSize < 24 ? fontSize + 3 : mathRound(fontSize * 1.2);
            baseline = mathRound(lineHeight * 0.8);

            return {
                h: lineHeight,
                b: baseline,
                f: fontSize
            };
        },

        /**
         * Correct X and Y positioning of a label for rotation (#1764)
         */
        rotCorr: function (baseline, rotation, alterY) {
            var y = baseline;
            if (rotation && alterY) {
                y = mathMax(y * mathCos(rotation * deg2rad), 4);
            }
            return {
                x: (-baseline / 3) * mathSin(rotation * deg2rad),
                y: y
            };
        },

        /**
         * Add a label, a text item that can hold a colored or gradient background
         * as well as a border and shadow.
         * @param {string} str
         * @param {Number} x
         * @param {Number} y
         * @param {String} shape
         * @param {Number} anchorX In case the shape has a pointer, like a flag, this is the
         *    coordinates it should be pinned to
         * @param {Number} anchorY
         * @param {Boolean} baseline Whether to position the label relative to the text baseline,
         *    like renderer.text, or to the upper border of the rectangle.
         * @param {String} className Class name for the group
         */
        label: function (str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {

            var renderer = this,
                wrapper = renderer.g(className),
                text = renderer.text('', 0, 0, useHTML)
                    .attr({
                        zIndex: 1
                    }),
                    //.add(wrapper),
                box,
                bBox,
                alignFactor = 0,
                padding = 3,
                paddingLeft = 0,
                width,
                height,
                wrapperX,
                wrapperY,
                crispAdjust = 0,
                deferredAttr = {},
                baselineOffset,
                needsBox,
                updateBoxSize,
                updateTextPadding,
                boxAttr;

            /**
             * This function runs after the label is added to the DOM (when the bounding box is
             * available), and after the text of the label is updated to detect the new bounding
             * box and reflect it in the border box.
             */
            updateBoxSize = function () {
                var boxX,
                    boxY,
                    style = text.element.style;

                bBox = (width === undefined || height === undefined || wrapper.styles.textAlign) && defined(text.textStr) &&
                    text.getBBox(); //#3295 && 3514 box failure when string equals 0
                wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;
                wrapper.height = (height || bBox.height || 0) + 2 * padding;

                // update the label-scoped y offset
                baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;


                if (needsBox) {

                    if (!box) {
                        // create the border box if it is not already present
                        boxX = crispAdjust;
                        boxY = (baseline ? -baselineOffset : 0) + crispAdjust;
                        wrapper.box = box = renderer.symbols[shape] ? // Symbol definition exists (#5324)
                                renderer.symbol(shape, boxX, boxY, wrapper.width, wrapper.height, deferredAttr) :
                                renderer.rect(boxX, boxY, wrapper.width, wrapper.height, 0, deferredAttr[STROKE_WIDTH]);

                        if (!box.isImg) { // #4324, fill "none" causes it to be ignored by mouse events in IE
                            box.attr('fill', NONE);
                        }
                        box.add(wrapper);
                    }

                    // apply the box attributes
                    if (!box.isImg) { // #1630
                        box.attr(extend({
                            width: mathRound(wrapper.width),
                            height: mathRound(wrapper.height)
                        }, deferredAttr));
                    }
                    deferredAttr = null;
                }
            };

            /**
             * This function runs after setting text or padding, but only if padding is changed
             */
            updateTextPadding = function () {
                var styles = wrapper.styles,
                    textAlign = styles && styles.textAlign,
                    x = paddingLeft + padding,
                    y;

                // determin y based on the baseline
                y = baseline ? 0 : baselineOffset;

                // compensate for alignment
                if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {
                    x += { center: 0.5, right: 1 }[textAlign] * (width - bBox.width);
                }

                // update if anything changed
                if (x !== text.x || y !== text.y) {
                    text.attr('x', x);
                    if (y !== UNDEFINED) {
                        text.attr('y', y);
                    }
                }

                // record current values
                text.x = x;
                text.y = y;
            };

            /**
             * Set a box attribute, or defer it if the box is not yet created
             * @param {Object} key
             * @param {Object} value
             */
            boxAttr = function (key, value) {
                if (box) {
                    box.attr(key, value);
                } else {
                    deferredAttr[key] = value;
                }
            };

            /**
             * After the text element is added, get the desired size of the border box
             * and add it before the text in the DOM.
             */
            wrapper.onAdd = function () {
                text.add(wrapper);
                wrapper.attr({
                    text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value
                    x: x,
                    y: y
                });

                if (box && defined(anchorX)) {
                    wrapper.attr({
                        anchorX: anchorX,
                        anchorY: anchorY
                    });
                }
            };

            /*
             * Add specific attribute setters.
             */

            // only change local variables
            wrapper.widthSetter = function (value) {
                width = value;
            };
            wrapper.heightSetter = function (value) {
                height = value;
            };
            wrapper.paddingSetter =  function (value) {
                if (defined(value) && value !== padding) {
                    padding = wrapper.padding = value;
                    updateTextPadding();
                }
            };
            wrapper.paddingLeftSetter =  function (value) {
                if (defined(value) && value !== paddingLeft) {
                    paddingLeft = value;
                    updateTextPadding();
                }
            };


            // change local variable and prevent setting attribute on the group
            wrapper.alignSetter = function (value) {
                value = { left: 0, center: 0.5, right: 1 }[value];
                if (value !== alignFactor) {
                    alignFactor = value;
                    if (bBox) { // Bounding box exists, means we're dynamically changing
                        wrapper.attr({ x: wrapperX }); // #5134
                    }
                }
            };

            // apply these to the box and the text alike
            wrapper.textSetter = function (value) {
                if (value !== UNDEFINED) {
                    text.textSetter(value);
                }
                updateBoxSize();
                updateTextPadding();
            };

            // apply these to the box but not to the text
            wrapper['stroke-widthSetter'] = function (value, key) {
                if (value) {
                    needsBox = true;
                }
                crispAdjust = value % 2 / 2;
                boxAttr(key, value);
            };
            wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function (value, key) {
                if (key === 'fill' && value) {
                    needsBox = true;
                }
                boxAttr(key, value);
            };
            wrapper.anchorXSetter = function (value, key) {
                anchorX = value;
                boxAttr(key, mathRound(value) - crispAdjust - wrapperX);
            };
            wrapper.anchorYSetter = function (value, key) {
                anchorY = value;
                boxAttr(key, value - wrapperY);
            };

            // rename attributes
            wrapper.xSetter = function (value) {
                wrapper.x = value; // for animation getter
                if (alignFactor) {
                    value -= alignFactor * ((width || bBox.width) + 2 * padding);
                }
                wrapperX = mathRound(value);
                wrapper.attr('translateX', wrapperX);
            };
            wrapper.ySetter = function (value) {
                wrapperY = wrapper.y = mathRound(value);
                wrapper.attr('translateY', wrapperY);
            };

            // Redirect certain methods to either the box or the text
            var baseCss = wrapper.css;
            return extend(wrapper, {
                /**
                 * Pick up some properties and apply them to the text instead of the wrapper
                 */
                css: function (styles) {
                    if (styles) {
                        var textStyles = {};
                        styles = merge(styles); // create a copy to avoid altering the original object (#537)
                        each(wrapper.textProps, function (prop) {
                            if (styles[prop] !== UNDEFINED) {
                                textStyles[prop] = styles[prop];
                                delete styles[prop];
                            }
                        });
                        text.css(textStyles);
                    }
                    return baseCss.call(wrapper, styles);
                },
                /**
                 * Return the bounding box of the box, not the group
                 */
                getBBox: function () {
                    return {
                        width: bBox.width + 2 * padding,
                        height: bBox.height + 2 * padding,
                        x: bBox.x - padding,
                        y: bBox.y - padding
                    };
                },
                /**
                 * Apply the shadow to the box
                 */
                shadow: function (b) {
                    if (box) {
                        box.shadow(b);
                    }
                    return wrapper;
                },
                /**
                 * Destroy and release memory.
                 */
                destroy: function () {

                    // Added by button implementation
                    removeEvent(wrapper.element, 'mouseenter');
                    removeEvent(wrapper.element, 'mouseleave');

                    if (text) {
                        text = text.destroy();
                    }
                    if (box) {
                        box = box.destroy();
                    }
                    // Call base implementation to destroy the rest
                    SVGElement.prototype.destroy.call(wrapper);

                    // Release local pointers (#1298)
                    wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;
                }
            });
        }
    }; // end SVGRenderer


    // general renderer
    Renderer = SVGRenderer;
    // extend SvgElement for useHTML option
    extend(SVGElement.prototype, {
        /**
         * Apply CSS to HTML elements. This is used in text within SVG rendering and
         * by the VML renderer
         */
        htmlCss: function (styles) {
            var wrapper = this,
                element = wrapper.element,
                textWidth = styles && element.tagName === 'SPAN' && styles.width;

            if (textWidth) {
                delete styles.width;
                wrapper.textWidth = textWidth;
                wrapper.updateTransform();
            }
            if (styles && styles.textOverflow === 'ellipsis') {
                styles.whiteSpace = 'nowrap';
                styles.overflow = 'hidden';
            }
            wrapper.styles = extend(wrapper.styles, styles);
            css(wrapper.element, styles);

            return wrapper;
        },

        /**
         * VML and useHTML method for calculating the bounding box based on offsets
         * @param {Boolean} refresh Whether to force a fresh value from the DOM or to
         * use the cached value
         *
         * @return {Object} A hash containing values for x, y, width and height
         */

        htmlGetBBox: function () {
            var wrapper = this,
                element = wrapper.element;

            // faking getBBox in exported SVG in legacy IE
            // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)
            if (element.nodeName === 'text') {
                element.style.position = ABSOLUTE;
            }

            return {
                x: element.offsetLeft,
                y: element.offsetTop,
                width: element.offsetWidth,
                height: element.offsetHeight
            };
        },

        /**
         * VML override private method to update elements based on internal
         * properties based on SVG transform
         */
        htmlUpdateTransform: function () {
            // aligning non added elements is expensive
            if (!this.added) {
                this.alignOnAdd = true;
                return;
            }

            var wrapper = this,
                renderer = wrapper.renderer,
                elem = wrapper.element,
                translateX = wrapper.translateX || 0,
                translateY = wrapper.translateY || 0,
                x = wrapper.x || 0,
                y = wrapper.y || 0,
                align = wrapper.textAlign || 'left',
                alignCorrection = { left: 0, center: 0.5, right: 1 }[align],
                shadows = wrapper.shadows,
                styles = wrapper.styles;

            // apply translate
            css(elem, {
                marginLeft: translateX,
                marginTop: translateY
            });
            if (shadows) { // used in labels/tooltip
                each(shadows, function (shadow) {
                    css(shadow, {
                        marginLeft: translateX + 1,
                        marginTop: translateY + 1
                    });
                });
            }

            // apply inversion
            if (wrapper.inverted) { // wrapper is a group
                each(elem.childNodes, function (child) {
                    renderer.invertChild(child, elem);
                });
            }

            if (elem.tagName === 'SPAN') {

                var rotation = wrapper.rotation,
                    baseline,
                    textWidth = pInt(wrapper.textWidth),
                    whiteSpace = styles && styles.whiteSpace,
                    currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');

                if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed


                    baseline = renderer.fontMetrics(elem.style.fontSize).b;

                    // Renderer specific handling of span rotation
                    if (defined(rotation)) {
                        wrapper.setSpanRotation(rotation, alignCorrection, baseline);
                    }

                    // Reset multiline/ellipsis in order to read width (#4928, #5417)
                    css(elem, {
                        width: '',
                        whiteSpace: whiteSpace || 'nowrap'
                    });

                    // Update textWidth
                    if (elem.offsetWidth > textWidth && /[ \-]/.test(elem.textContent || elem.innerText)) { // #983, #1254
                        css(elem, {
                            width: textWidth + PX,
                            display: 'block',
                            whiteSpace: whiteSpace || 'normal' // #3331
                        });
                    }


                    wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);
                }

                // apply position with correction
                css(elem, {
                    left: (x + (wrapper.xCorr || 0)) + PX,
                    top: (y + (wrapper.yCorr || 0)) + PX
                });

                // force reflow in webkit to apply the left and top on useHTML element (#1249)
                if (isWebKit) {
                    baseline = elem.offsetHeight; // assigned to baseline for lint purpose
                }

                // record current text transform
                wrapper.cTT = currentTextTransform;
            }
        },

        /**
         * Set the rotation of an individual HTML span
         */
        setSpanRotation: function (rotation, alignCorrection, baseline) {
            var rotationStyle = {},
                cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : isOpera ? '-o-transform' : '';

            rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';
            rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';
            css(this.element, rotationStyle);
        },

        /**
         * Get the correction in X and Y positioning as the element is rotated.
         */
        getSpanCorrection: function (width, baseline, alignCorrection) {
            this.xCorr = -width * alignCorrection;
            this.yCorr = -baseline;
        }
    });

    // Extend SvgRenderer for useHTML option.
    extend(SVGRenderer.prototype, {
        /**
         * Create HTML text node. This is used by the VML renderer as well as the SVG
         * renderer through the useHTML option.
         *
         * @param {String} str
         * @param {Number} x
         * @param {Number} y
         */
        html: function (str, x, y) {
            var wrapper = this.createElement('span'),
                element = wrapper.element,
                renderer = wrapper.renderer,
                isSVG = renderer.isSVG,
                addSetters = function (element, style) {
                    // These properties are set as attributes on the SVG group, and as
                    // identical CSS properties on the div. (#3542)
                    each(['opacity', 'visibility'], function (prop) {
                        wrap(element, prop + 'Setter', function (proceed, value, key, elem) {
                            proceed.call(this, value, key, elem);
                            style[key] = value;
                        });
                    });            
                };

            // Text setter
            wrapper.textSetter = function (value) {
                if (value !== element.innerHTML) {
                    delete this.bBox;
                }
                element.innerHTML = this.textStr = value;
                wrapper.htmlUpdateTransform();
            };

            // Add setters for the element itself (#4938)
            if (isSVG) { // #4938, only for HTML within SVG
                addSetters(wrapper, wrapper.element.style);
            }

            // Various setters which rely on update transform
            wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function (value, key) {
                if (key === 'align') {
                    key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.
                }
                wrapper[key] = value;
                wrapper.htmlUpdateTransform();
            };

            // Set the default attributes
            wrapper
                .attr({
                    text: str,
                    x: mathRound(x),
                    y: mathRound(y)
                })
                .css({
                    position: ABSOLUTE,
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize
                });

            // Keep the whiteSpace style outside the wrapper.styles collection
            element.style.whiteSpace = 'nowrap';

            // Use the HTML specific .css method
            wrapper.css = wrapper.htmlCss;

            // This is specific for HTML within SVG
            if (isSVG) {
                wrapper.add = function (svgGroupWrapper) {

                    var htmlGroup,
                        container = renderer.box.parentNode,
                        parentGroup,
                        parents = [];

                    this.parentGroup = svgGroupWrapper;

                    // Create a mock group to hold the HTML elements
                    if (svgGroupWrapper) {
                        htmlGroup = svgGroupWrapper.div;
                        if (!htmlGroup) {

                            // Read the parent chain into an array and read from top down
                            parentGroup = svgGroupWrapper;
                            while (parentGroup) {

                                parents.push(parentGroup);

                                // Move up to the next parent group
                                parentGroup = parentGroup.parentGroup;
                            }

                            // Ensure dynamically updating position when any parent is translated
                            each(parents.reverse(), function (parentGroup) {
                                var htmlGroupStyle,
                                    cls = attr(parentGroup.element, 'class');

                                if (cls) {
                                    cls = { className: cls };
                                } // else null

                                // Create a HTML div and append it to the parent div to emulate
                                // the SVG group structure
                                htmlGroup = parentGroup.div = parentGroup.div || createElement(DIV, cls, {
                                    position: ABSOLUTE,
                                    left: (parentGroup.translateX || 0) + PX,
                                    top: (parentGroup.translateY || 0) + PX,
                                    opacity: parentGroup.opacity // #5075
                                }, htmlGroup || container); // the top group is appended to container

                                // Shortcut
                                htmlGroupStyle = htmlGroup.style;

                                // Set listeners to update the HTML div's position whenever the SVG group
                                // position is changed
                                extend(parentGroup, {
                                    translateXSetter: function (value, key) {
                                        htmlGroupStyle.left = value + PX;
                                        parentGroup[key] = value;
                                        parentGroup.doTransform = true;
                                    },
                                    translateYSetter: function (value, key) {
                                        htmlGroupStyle.top = value + PX;
                                        parentGroup[key] = value;
                                        parentGroup.doTransform = true;
                                    }
                                });
                                addSetters(parentGroup, htmlGroupStyle);
                            });

                        }
                    } else {
                        htmlGroup = container;
                    }

                    htmlGroup.appendChild(element);

                    // Shared with VML:
                    wrapper.added = true;
                    if (wrapper.alignOnAdd) {
                        wrapper.htmlUpdateTransform();
                    }

                    return wrapper;
                };
            }
            return wrapper;
        }
    });


    /* ****************************************************************************
     *                                                                            *
     * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
     *                                                                            *
     * For applications and websites that don't need IE support, like platform    *
     * targeted mobile apps and web apps, this code can be removed.               *
     *                                                                            *
     *****************************************************************************/

    /**
     * @constructor
     */
    var VMLRenderer, VMLElement;
    if (!hasSVG && !useCanVG) {

    /**
     * The VML element wrapper.
     */
    VMLElement = {

        /**
         * Initialize a new VML element wrapper. It builds the markup as a string
         * to minimize DOM traffic.
         * @param {Object} renderer
         * @param {Object} nodeName
         */
        init: function (renderer, nodeName) {
            var wrapper = this,
                markup =  ['<', nodeName, ' filled="f" stroked="f"'],
                style = ['position: ', ABSOLUTE, ';'],
                isDiv = nodeName === DIV;

            // divs and shapes need size
            if (nodeName === 'shape' || isDiv) {
                style.push('left:0;top:0;width:1px;height:1px;');
            }
            style.push('visibility: ', isDiv ? HIDDEN : VISIBLE);

            markup.push(' style="', style.join(''), '"/>');

            // create element with default attributes and style
            if (nodeName) {
                markup = isDiv || nodeName === 'span' || nodeName === 'img' ?
                    markup.join('')    :
                    renderer.prepVML(markup);
                wrapper.element = createElement(markup);
            }

            wrapper.renderer = renderer;
        },

        /**
         * Add the node to the given parent
         * @param {Object} parent
         */
        add: function (parent) {
            var wrapper = this,
                renderer = wrapper.renderer,
                element = wrapper.element,
                box = renderer.box,
                inverted = parent && parent.inverted,

                // get the parent node
                parentNode = parent ?
                    parent.element || parent :
                    box;

            if (parent) {
                this.parentGroup = parent;
            }

            // if the parent group is inverted, apply inversion on all children
            if (inverted) { // only on groups
                renderer.invertChild(element, parentNode);
            }

            // append it
            parentNode.appendChild(element);

            // align text after adding to be able to read offset
            wrapper.added = true;
            if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {
                wrapper.updateTransform();
            }

            // fire an event for internal hooks
            if (wrapper.onAdd) {
                wrapper.onAdd();
            }

            return wrapper;
        },

        /**
         * VML always uses htmlUpdateTransform
         */
        updateTransform: SVGElement.prototype.htmlUpdateTransform,

        /**
         * Set the rotation of a span with oldIE's filter
         */
        setSpanRotation: function () {
            // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented
            // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+
            // has support for CSS3 transform. The getBBox method also needs to be updated
            // to compensate for the rotation, like it currently does for SVG.
            // Test case: http://jsfiddle.net/highcharts/Ybt44/

            var rotation = this.rotation,
                costheta = mathCos(rotation * deg2rad),
                sintheta = mathSin(rotation * deg2rad);

            css(this.element, {
                filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,
                    ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,
                    ', sizingMethod=\'auto expand\')'].join('') : NONE
            });
        },

        /**
         * Get the positioning correction for the span after rotating.
         */
        getSpanCorrection: function (width, baseline, alignCorrection, rotation, align) {

            var costheta = rotation ? mathCos(rotation * deg2rad) : 1,
                sintheta = rotation ? mathSin(rotation * deg2rad) : 0,
                height = pick(this.elemHeight, this.element.offsetHeight),
                quad,
                nonLeft = align && align !== 'left';

            // correct x and y
            this.xCorr = costheta < 0 && -width;
            this.yCorr = sintheta < 0 && -height;

            // correct for baseline and corners spilling out after rotation
            quad = costheta * sintheta < 0;
            this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);
            this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);
            // correct for the length/height of the text
            if (nonLeft) {
                this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);
                if (rotation) {
                    this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);
                }
                css(this.element, {
                    textAlign: align
                });
            }
        },

        /**
         * Converts a subset of an SVG path definition to its VML counterpart. Takes an array
         * as the parameter and returns a string.
         */
        pathToVML: function (value) {
            // convert paths
            var i = value.length,
                path = [];

            while (i--) {

                // Multiply by 10 to allow subpixel precision.
                // Substracting half a pixel seems to make the coordinates
                // align with SVG, but this hasn't been tested thoroughly
                if (isNumber(value[i])) {
                    path[i] = mathRound(value[i] * 10) - 5;
                } else if (value[i] === 'Z') { // close the path
                    path[i] = 'x';
                } else {
                    path[i] = value[i];

                    // When the start X and end X coordinates of an arc are too close,
                    // they are rounded to the same value above. In this case, substract or
                    // add 1 from the end X and Y positions. #186, #760, #1371, #1410.
                    if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {
                        // Start and end X
                        if (path[i + 5] === path[i + 7]) {
                            path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;
                        }
                        // Start and end Y
                        if (path[i + 6] === path[i + 8]) {
                            path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;
                        }
                    }
                }
            }


            // Loop up again to handle path shortcuts (#2132)
            /*while (i++ < path.length) {
                if (path[i] === 'H') { // horizontal line to
                    path[i] = 'L';
                    path.splice(i + 2, 0, path[i - 1]);
                } else if (path[i] === 'V') { // vertical line to
                    path[i] = 'L';
                    path.splice(i + 1, 0, path[i - 2]);
                }
            }*/
            return path.join(' ') || 'x';
        },

        /**
         * Set the element's clipping to a predefined rectangle
         *
         * @param {String} id The id of the clip rectangle
         */
        clip: function (clipRect) {
            var wrapper = this,
                clipMembers,
                cssRet;

            if (clipRect) {
                clipMembers = clipRect.members;
                erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)
                clipMembers.push(wrapper);
                wrapper.destroyClip = function () {
                    erase(clipMembers, wrapper);
                };
                cssRet = clipRect.getCSS(wrapper);

            } else {
                if (wrapper.destroyClip) {
                    wrapper.destroyClip();
                }
                cssRet = { clip: docMode8 ? 'inherit' : 'rect(auto)' }; // #1214
            }

            return wrapper.css(cssRet);

        },

        /**
         * Set styles for the element
         * @param {Object} styles
         */
        css: SVGElement.prototype.htmlCss,

        /**
         * Removes a child either by removeChild or move to garbageBin.
         * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.
         */
        safeRemoveChild: function (element) {
            // discardElement will detach the node from its parent before attaching it
            // to the garbage bin. Therefore it is important that the node is attached and have parent.
            if (element.parentNode) {
                discardElement(element);
            }
        },

        /**
         * Extend element.destroy by removing it from the clip members array
         */
        destroy: function () {
            if (this.destroyClip) {
                this.destroyClip();
            }

            return SVGElement.prototype.destroy.apply(this);
        },

        /**
         * Add an event listener. VML override for normalizing event parameters.
         * @param {String} eventType
         * @param {Function} handler
         */
        on: function (eventType, handler) {
            // simplest possible event model for internal use
            this.element['on' + eventType] = function () {
                var evt = win.event;
                evt.target = evt.srcElement;
                handler(evt);
            };
            return this;
        },

        /**
         * In stacked columns, cut off the shadows so that they don't overlap
         */
        cutOffPath: function (path, length) {

            var len;

            path = path.split(/[ ,]/);
            len = path.length;

            if (len === 9 || len === 11) {
                path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;
            }
            return path.join(' ');
        },

        /**
         * Apply a drop shadow by copying elements and giving them different strokes
         * @param {Boolean|Object} shadowOptions
         */
        shadow: function (shadowOptions, group, cutOff) {
            var shadows = [],
                i,
                element = this.element,
                renderer = this.renderer,
                shadow,
                elemStyle = element.style,
                markup,
                path = element.path,
                strokeWidth,
                modifiedPath,
                shadowWidth,
                shadowElementOpacity;

            // some times empty paths are not strings
            if (path && typeof path.value !== 'string') {
                path = 'x';
            }
            modifiedPath = path;

            if (shadowOptions) {
                shadowWidth = pick(shadowOptions.width, 3);
                shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;
                for (i = 1; i <= 3; i++) {

                    strokeWidth = (shadowWidth * 2) + 1 - (2 * i);

                    // Cut off shadows for stacked column items
                    if (cutOff) {
                        modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);
                    }

                    markup = ['<shape isShadow="true" strokeweight="', strokeWidth,
                        '" filled="false" path="', modifiedPath,
                        '" coordsize="10 10" style="', element.style.cssText, '" />'];

                    shadow = createElement(renderer.prepVML(markup),
                        null, {
                            left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),
                            top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)
                        }
                    );
                    if (cutOff) {
                        shadow.cutOff = strokeWidth + 1;
                    }

                    // apply the opacity
                    markup = ['<stroke color="', shadowOptions.color || 'black', '" opacity="', shadowElementOpacity * i, '"/>'];
                    createElement(renderer.prepVML(markup), null, null, shadow);


                    // insert it
                    if (group) {
                        group.element.appendChild(shadow);
                    } else {
                        element.parentNode.insertBefore(shadow, element);
                    }

                    // record it
                    shadows.push(shadow);

                }

                this.shadows = shadows;
            }
            return this;
        },
        updateShadows: noop, // Used in SVG only

        setAttr: function (key, value) {
            if (docMode8) { // IE8 setAttribute bug
                this.element[key] = value;
            } else {
                this.element.setAttribute(key, value);
            }
        },
        classSetter: function (value) {
            // IE8 Standards mode has problems retrieving the className unless set like this
            this.element.className = value;
        },
        dashstyleSetter: function (value, key, element) {
            var strokeElem = element.getElementsByTagName('stroke')[0] ||
                createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);
            strokeElem[key] = value || 'solid';
            this[key] = value; /* because changing stroke-width will change the dash length
                and cause an epileptic effect */
        },
        dSetter: function (value, key, element) {
            var i,
                shadows = this.shadows;
            value = value || [];
            this.d = value.join && value.join(' '); // used in getter for animation

            element.path = value = this.pathToVML(value);

            // update shadows
            if (shadows) {
                i = shadows.length;
                while (i--) {
                    shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;
                }
            }
            this.setAttr(key, value);
        },
        fillSetter: function (value, key, element) {
            var nodeName = element.nodeName;
            if (nodeName === 'SPAN') { // text color
                element.style.color = value;
            } else if (nodeName !== 'IMG') { // #1336
                element.filled = value !== NONE;
                this.setAttr('fillcolor', this.renderer.color(value, element, key, this));
            }
        },
        'fill-opacitySetter': function (value, key, element) {
            createElement(
                this.renderer.prepVML(['<', key.split('-')[0], ' opacity="', value, '"/>']),
                null,
                null,
                element
            );
        },
        opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts
        rotationSetter: function (value, key, element) {
            var style = element.style;
            this[key] = style[key] = value; // style is for #1873

            // Correction for the 1x1 size of the shape container. Used in gauge needles.
            style.left = -mathRound(mathSin(value * deg2rad) + 1) + PX;
            style.top = mathRound(mathCos(value * deg2rad)) + PX;
        },
        strokeSetter: function (value, key, element) {
            this.setAttr('strokecolor', this.renderer.color(value, element, key, this));
        },
        'stroke-widthSetter': function (value, key, element) {
            element.stroked = !!value; // VML "stroked" attribute
            this[key] = value; // used in getter, issue #113
            if (isNumber(value)) {
                value += PX;
            }
            this.setAttr('strokeweight', value);
        },
        titleSetter: function (value, key) {
            this.setAttr(key, value);
        },
        visibilitySetter: function (value, key, element) {

            // Handle inherited visibility
            if (value === 'inherit') {
                value = VISIBLE;
            }

            // Let the shadow follow the main element
            if (this.shadows) {
                each(this.shadows, function (shadow) {
                    shadow.style[key] = value;
                });
            }

            // Instead of toggling the visibility CSS property, move the div out of the viewport.
            // This works around #61 and #586
            if (element.nodeName === 'DIV') {
                value = value === HIDDEN ? '-999em' : 0;

                // In order to redraw, IE7 needs the div to be visible when tucked away
                // outside the viewport. So the visibility is actually opposite of
                // the expected value. This applies to the tooltip only.
                if (!docMode8) {
                    element.style[key] = value ? VISIBLE : HIDDEN;
                }
                key = 'top';
            }
            element.style[key] = value;
        },
        xSetter: function (value, key, element) {
            this[key] = value; // used in getter

            if (key === 'x') {
                key = 'left';
            } else if (key === 'y') {
                key = 'top';
            }/* else {
                value = mathMax(0, value); // don't set width or height below zero (#311)
            }*/

            // clipping rectangle special
            if (this.updateClipping) {
                this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'
                this.updateClipping();
            } else {
                // normal
                element.style[key] = value;
            }
        },
        zIndexSetter: function (value, key, element) {
            element.style[key] = value;
        }
    };
    VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];

    Highcharts.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);

    // Some shared setters
    VMLElement.prototype.ySetter =
        VMLElement.prototype.widthSetter =
        VMLElement.prototype.heightSetter =
        VMLElement.prototype.xSetter;


    /**
     * The VML renderer
     */
    var VMLRendererExtension = { // inherit SVGRenderer

        Element: VMLElement,
        isIE8: userAgent.indexOf('MSIE 8.0') > -1,


        /**
         * Initialize the VMLRenderer
         * @param {Object} container
         * @param {Number} width
         * @param {Number} height
         */
        init: function (container, width, height, style) {
            var renderer = this,
                boxWrapper,
                box,
                css;

            renderer.alignedObjects = [];

            boxWrapper = renderer.createElement(DIV)
                .css(extend(this.getStyle(style), { position: 'relative' }));
            box = boxWrapper.element;
            container.appendChild(boxWrapper.element);


            // generate the containing box
            renderer.isVML = true;
            renderer.box = box;
            renderer.boxWrapper = boxWrapper;
            renderer.gradients = {};
            renderer.cache = {}; // Cache for numerical bounding boxes
            renderer.cacheKeys = [];
            renderer.imgCount = 0;


            renderer.setSize(width, height, false);

            // The only way to make IE6 and IE7 print is to use a global namespace. However,
            // with IE8 the only way to make the dynamic shapes visible in screen and print mode
            // seems to be to add the xmlns attribute and the behaviour style inline.
            if (!doc.namespaces.hcv) {

                doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

                // Setup default CSS (#2153, #2368, #2384)
                css = 'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke' +
                    '{ behavior:url(#default#VML); display: inline-block; } ';
                try {
                    doc.createStyleSheet().cssText = css;
                } catch (e) {
                    doc.styleSheets[0].cssText += css;
                }

            }
        },


        /**
         * Detect whether the renderer is hidden. This happens when one of the parent elements
         * has display: none
         */
        isHidden: function () {
            return !this.box.offsetWidth;
        },

        /**
         * Define a clipping rectangle. In VML it is accomplished by storing the values
         * for setting the CSS style to all associated members.
         *
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         */
        clipRect: function (x, y, width, height) {

            // create a dummy element
            var clipRect = this.createElement(),
                isObj = isObject(x);

            // mimic a rectangle with its style object for automatic updating in attr
            return extend(clipRect, {
                members: [],
                count: 0,
                left: (isObj ? x.x : x) + 1,
                top: (isObj ? x.y : y) + 1,
                width: (isObj ? x.width : width) - 1,
                height: (isObj ? x.height : height) - 1,
                getCSS: function (wrapper) {
                    var element = wrapper.element,
                        nodeName = element.nodeName,
                        isShape = nodeName === 'shape',
                        inverted = wrapper.inverted,
                        rect = this,
                        top = rect.top - (isShape ? element.offsetTop : 0),
                        left = rect.left,
                        right = left + rect.width,
                        bottom = top + rect.height,
                        ret = {
                            clip: 'rect(' +
                                mathRound(inverted ? left : top) + 'px,' +
                                mathRound(inverted ? bottom : right) + 'px,' +
                                mathRound(inverted ? right : bottom) + 'px,' +
                                mathRound(inverted ? top : left) + 'px)'
                        };

                    // issue 74 workaround
                    if (!inverted && docMode8 && nodeName === 'DIV') {
                        extend(ret, {
                            width: right + PX,
                            height: bottom + PX
                        });
                    }
                    return ret;
                },

                // used in attr and animation to update the clipping of all members
                updateClipping: function () {
                    each(clipRect.members, function (member) {
                        if (member.element) { // Deleted series, like in stock/members/series-remove demo. Should be removed from members, but this will do.
                            member.css(clipRect.getCSS(member));
                        }
                    });
                }
            });

        },


        /**
         * Take a color and return it if it's a string, make it a gradient if it's a
         * gradient configuration object, and apply opacity.
         *
         * @param {Object} color The color or config object
         */
        color: function (color, elem, prop, wrapper) {
            var renderer = this,
                colorObject,
                regexRgba = /^rgba/,
                markup,
                fillType,
                ret = NONE;

            // Check for linear or radial gradient
            if (color && color.linearGradient) {
                fillType = 'gradient';
            } else if (color && color.radialGradient) {
                fillType = 'pattern';
            }


            if (fillType) {

                var stopColor,
                    stopOpacity,
                    gradient = color.linearGradient || color.radialGradient,
                    x1,
                    y1,
                    x2,
                    y2,
                    opacity1,
                    opacity2,
                    color1,
                    color2,
                    fillAttr = '',
                    stops = color.stops,
                    firstStop,
                    lastStop,
                    colors = [],
                    addFillNode = function () {
                        // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2
                        // are reversed.
                        markup = ['<fill colors="' + colors.join(',') + '" opacity="', opacity2, '" o:opacity2="', opacity1,
                            '" type="', fillType, '" ', fillAttr, 'focus="100%" method="any" />'];
                        createElement(renderer.prepVML(markup), null, null, elem);
                    };

                // Extend from 0 to 1
                firstStop = stops[0];
                lastStop = stops[stops.length - 1];
                if (firstStop[0] > 0) {
                    stops.unshift([
                        0,
                        firstStop[1]
                    ]);
                }
                if (lastStop[0] < 1) {
                    stops.push([
                        1,
                        lastStop[1]
                    ]);
                }

                // Compute the stops
                each(stops, function (stop, i) {
                    if (regexRgba.test(stop[1])) {
                        colorObject = Color(stop[1]);
                        stopColor = colorObject.get('rgb');
                        stopOpacity = colorObject.get('a');
                    } else {
                        stopColor = stop[1];
                        stopOpacity = 1;
                    }

                    // Build the color attribute
                    colors.push((stop[0] * 100) + '% ' + stopColor);

                    // Only start and end opacities are allowed, so we use the first and the last
                    if (!i) {
                        opacity1 = stopOpacity;
                        color2 = stopColor;
                    } else {
                        opacity2 = stopOpacity;
                        color1 = stopColor;
                    }
                });

                // Apply the gradient to fills only.
                if (prop === 'fill') {

                    // Handle linear gradient angle
                    if (fillType === 'gradient') {
                        x1 = gradient.x1 || gradient[0] || 0;
                        y1 = gradient.y1 || gradient[1] || 0;
                        x2 = gradient.x2 || gradient[2] || 0;
                        y2 = gradient.y2 || gradient[3] || 0;
                        fillAttr = 'angle="' + (90  - math.atan(
                            (y2 - y1) / // y vector
                            (x2 - x1) // x vector
                            ) * 180 / mathPI) + '"';

                        addFillNode();

                    // Radial (circular) gradient
                    } else {

                        var r = gradient.r,
                            sizex = r * 2,
                            sizey = r * 2,
                            cx = gradient.cx,
                            cy = gradient.cy,
                            radialReference = elem.radialReference,
                            bBox,
                            applyRadialGradient = function () {
                                if (radialReference) {
                                    bBox = wrapper.getBBox();
                                    cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;
                                    cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;
                                    sizex *= radialReference[2] / bBox.width;
                                    sizey *= radialReference[2] / bBox.height;
                                }
                                fillAttr = 'src="' + defaultOptions.global.VMLRadialGradientURL + '" ' +
                                    'size="' + sizex + ',' + sizey + '" ' +
                                    'origin="0.5,0.5" ' +
                                    'position="' + cx + ',' + cy + '" ' +
                                    'color2="' + color2 + '" ';

                                addFillNode();
                            };

                        // Apply radial gradient
                        if (wrapper.added) {
                            applyRadialGradient();
                        } else {
                            // We need to know the bounding box to get the size and position right
                            wrapper.onAdd = applyRadialGradient;
                        }

                        // The fill element's color attribute is broken in IE8 standards mode, so we
                        // need to set the parent shape's fillcolor attribute instead.
                        ret = color1;
                    }

                // Gradients are not supported for VML stroke, return the first color. #722.
                } else {
                    ret = stopColor;
                }

            // If the color is an rgba color, split it and add a fill node
            // to hold the opacity component
            } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {

                colorObject = Color(color);

                wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);

                ret = colorObject.get('rgb');


            } else {
                var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node
                if (propNodes.length) {
                    propNodes[0].opacity = 1;
                    propNodes[0].type = 'solid';
                }
                ret = color;
            }

            return ret;
        },

        /**
         * Take a VML string and prepare it for either IE8 or IE6/IE7.
         * @param {Array} markup A string array of the VML markup to prepare
         */
        prepVML: function (markup) {
            var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
                isIE8 = this.isIE8;

            markup = markup.join('');

            if (isIE8) { // add xmlns and style inline
                markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
                if (markup.indexOf('style="') === -1) {
                    markup = markup.replace('/>', ' style="' + vmlStyle + '" />');
                } else {
                    markup = markup.replace('style="', 'style="' + vmlStyle);
                }

            } else { // add namespace
                markup = markup.replace('<', '<hcv:');
            }

            return markup;
        },

        /**
         * Create rotated and aligned text
         * @param {String} str
         * @param {Number} x
         * @param {Number} y
         */
        text: SVGRenderer.prototype.html,

        /**
         * Create and return a path element
         * @param {Array} path
         */
        path: function (path) {
            var attr = {
                // subpixel precision down to 0.1 (width and height = 1px)
                coordsize: '10 10'
            };
            if (isArray(path)) {
                attr.d = path;
            } else if (isObject(path)) { // attributes
                extend(attr, path);
            }
            // create the shape
            return this.createElement('shape').attr(attr);
        },

        /**
         * Create and return a circle element. In VML circles are implemented as
         * shapes, which is faster than v:oval
         * @param {Number} x
         * @param {Number} y
         * @param {Number} r
         */
        circle: function (x, y, r) {
            var circle = this.symbol('circle');
            if (isObject(x)) {
                r = x.r;
                y = x.y;
                x = x.x;
            }
            circle.isCircle = true; // Causes x and y to mean center (#1682)
            circle.r = r;
            return circle.attr({ x: x, y: y });
        },

        /**
         * Create a group using an outer div and an inner v:group to allow rotating
         * and flipping. A simple v:group would have problems with positioning
         * child HTML elements and CSS clip.
         *
         * @param {String} name The name of the group
         */
        g: function (name) {
            var wrapper,
                attribs;

            // set the class name
            if (name) {
                attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
            }

            // the div to hold HTML and clipping
            wrapper = this.createElement(DIV).attr(attribs);

            return wrapper;
        },

        /**
         * VML override to create a regular HTML image
         * @param {String} src
         * @param {Number} x
         * @param {Number} y
         * @param {Number} width
         * @param {Number} height
         */
        image: function (src, x, y, width, height) {
            var obj = this.createElement('img')
                .attr({ src: src });

            if (arguments.length > 1) {
                obj.attr({
                    x: x,
                    y: y,
                    width: width,
                    height: height
                });
            }
            return obj;
        },

        /**
         * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems
         */
        createElement: function (nodeName) {
            return nodeName === 'rect' ? this.symbol(nodeName) : SVGRenderer.prototype.createElement.call(this, nodeName);
        },

        /**
         * In the VML renderer, each child of an inverted div (group) is inverted
         * @param {Object} element
         * @param {Object} parentNode
         */
        invertChild: function (element, parentNode) {
            var ren = this,
                parentStyle = parentNode.style,
                imgStyle = element.tagName === 'IMG' && element.style; // #1111

            css(element, {
                flip: 'x',
                left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),
                top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),
                rotation: -90
            });

            // Recursively invert child elements, needed for nested composite shapes like box plots and error bars. #1680, #1806.
            each(element.childNodes, function (child) {
                ren.invertChild(child, element);
            });
        },

        /**
         * Symbol definitions that override the parent SVG renderer's symbols
         *
         */
        symbols: {
            // VML specific arc function
            arc: function (x, y, w, h, options) {
                var start = options.start,
                    end = options.end,
                    radius = options.r || w || h,
                    innerRadius = options.innerR,
                    cosStart = mathCos(start),
                    sinStart = mathSin(start),
                    cosEnd = mathCos(end),
                    sinEnd = mathSin(end),
                    ret;

                if (end - start === 0) { // no angle, don't show it.
                    return ['x'];
                }

                ret = [
                    'wa', // clockwise arc to
                    x - radius, // left
                    y - radius, // top
                    x + radius, // right
                    y + radius, // bottom
                    x + radius * cosStart, // start x
                    y + radius * sinStart, // start y
                    x + radius * cosEnd, // end x
                    y + radius * sinEnd  // end y
                ];

                if (options.open && !innerRadius) {
                    ret.push(
                        'e',
                        M,
                        x, // - innerRadius,
                        y// - innerRadius
                    );
                }

                ret.push(
                    'at', // anti clockwise arc to
                    x - innerRadius, // left
                    y - innerRadius, // top
                    x + innerRadius, // right
                    y + innerRadius, // bottom
                    x + innerRadius * cosEnd, // start x
                    y + innerRadius * sinEnd, // start y
                    x + innerRadius * cosStart, // end x
                    y + innerRadius * sinStart, // end y
                    'x', // finish path
                    'e' // close
                );

                ret.isArc = true;
                return ret;

            },
            // Add circle symbol path. This performs significantly faster than v:oval.
            circle: function (x, y, w, h, wrapper) {

                if (wrapper) {
                    w = h = 2 * wrapper.r;
                }

                // Center correction, #1682
                if (wrapper && wrapper.isCircle) {
                    x -= w / 2;
                    y -= h / 2;
                }

                // Return the path
                return [
                    'wa', // clockwisearcto
                    x, // left
                    y, // top
                    x + w, // right
                    y + h, // bottom
                    x + w, // start x
                    y + h / 2,     // start y
                    x + w, // end x
                    y + h / 2,     // end y
                    //'x', // finish path
                    'e' // close
                ];
            },
            /**
             * Add rectangle symbol path which eases rotation and omits arcsize problems
             * compared to the built-in VML roundrect shape. When borders are not rounded,
             * use the simpler square path, else use the callout path without the arrow.
             */
            rect: function (x, y, w, h, options) {
                return SVGRenderer.prototype.symbols[
                    !defined(options) || !options.r ? 'square' : 'callout'
                ].call(0, x, y, w, h, options);
            }
        }
    };
    Highcharts.VMLRenderer = VMLRenderer = function () {
        this.init.apply(this, arguments);
    };
    VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);

        // general renderer
        Renderer = VMLRenderer;
    }

    // This method is used with exporting in old IE, when emulating SVG (see #2314)
    SVGRenderer.prototype.measureSpanWidth = function (text, styles) {
        var measuringSpan = doc.createElement('span'),
            offsetWidth,
            textNode = doc.createTextNode(text);

        measuringSpan.appendChild(textNode);
        css(measuringSpan, styles);
        this.box.appendChild(measuringSpan);
        offsetWidth = measuringSpan.offsetWidth;
        discardElement(measuringSpan); // #2463
        return offsetWidth;
    };


    /* ****************************************************************************
     *                                                                            *
     * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
     *                                                                            *
     *****************************************************************************/
    /* ****************************************************************************
     *                                                                            *
     * START OF ANDROID < 3 SPECIFIC CODE. THIS CAN BE REMOVED IF YOU'RE NOT      *
     * TARGETING THAT SYSTEM.                                                     *
     *                                                                            *
     *****************************************************************************/
    var CanVGRenderer,
        CanVGController;

    /**
     * Downloads a script and executes a callback when done.
     * @param {String} scriptLocation
     * @param {Function} callback
     */
    function getScript(scriptLocation, callback) {
        var head = doc.getElementsByTagName('head')[0],
            script = doc.createElement('script');

        script.type = 'text/javascript';
        script.src = scriptLocation;
        script.onload = callback;

        head.appendChild(script);
    }

    if (useCanVG) {
        /**
         * The CanVGRenderer is empty from start to keep the source footprint small.
         * When requested, the CanVGController downloads the rest of the source packaged
         * together with the canvg library.
         */
        Highcharts.CanVGRenderer = CanVGRenderer = function () {
            // Override the global SVG namespace to fake SVG/HTML that accepts CSS
            SVG_NS = 'http://www.w3.org/1999/xhtml';
        };

        /**
         * Start with an empty symbols object. This is needed when exporting is used (exporting.src.js will add a few symbols), but
         * the implementation from SvgRenderer will not be merged in until first render.
         */
        CanVGRenderer.prototype.symbols = {};

        /**
         * Handles on demand download of canvg rendering support.
         */
        CanVGController = (function () {
            // List of renderering calls
            var deferredRenderCalls = [];

            /**
             * When downloaded, we are ready to draw deferred charts.
             */
            function drawDeferred() {
                var callLength = deferredRenderCalls.length,
                    callIndex;

                // Draw all pending render calls
                for (callIndex = 0; callIndex < callLength; callIndex++) {
                    deferredRenderCalls[callIndex]();
                }
                // Clear the list
                deferredRenderCalls = [];
            }

            return {
                push: function (func, scriptLocation) {
                    // Only get the script once
                    if (deferredRenderCalls.length === 0) {
                        getScript(scriptLocation, drawDeferred);
                    }
                    // Register render call
                    deferredRenderCalls.push(func);
                }
            };
        }());

        Renderer = CanVGRenderer;
    } // end CanVGRenderer

    /* ****************************************************************************
     *                                                                            *
     * END OF ANDROID < 3 SPECIFIC CODE                                           *
     *                                                                            *
     *****************************************************************************/

    /**
     * The Tick class
     */
    function Tick(axis, pos, type, noLabel) {
        this.axis = axis;
        this.pos = pos;
        this.type = type || '';
        this.isNew = true;

        if (!type && !noLabel) {
            this.addLabel();
        }
    }

    Tick.prototype = {
        /**
         * Write the tick label
         */
        addLabel: function () {
            var tick = this,
                axis = tick.axis,
                options = axis.options,
                chart = axis.chart,
                categories = axis.categories,
                names = axis.names,
                pos = tick.pos,
                labelOptions = options.labels,
                str,
                tickPositions = axis.tickPositions,
                isFirst = pos === tickPositions[0],
                isLast = pos === tickPositions[tickPositions.length - 1],
                value = categories ?
                    pick(categories[pos], names[pos], pos) :
                    pos,
                label = tick.label,
                tickPositionInfo = tickPositions.info,
                dateTimeLabelFormat;

            // Set the datetime label format. If a higher rank is set for this position, use that. If not,
            // use the general format.
            if (axis.isDatetimeAxis && tickPositionInfo) {
                dateTimeLabelFormat = options.dateTimeLabelFormats[tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName];
            }
            // set properties for access in render method
            tick.isFirst = isFirst;
            tick.isLast = isLast;

            // get the string
            str = axis.labelFormatter.call({
                axis: axis,
                chart: chart,
                isFirst: isFirst,
                isLast: isLast,
                dateTimeLabelFormat: dateTimeLabelFormat,
                value: axis.isLog ? correctFloat(axis.lin2log(value)) : value
            });

            // prepare CSS
            //css = width && { width: mathMax(1, mathRound(width - 2 * (labelOptions.padding || 10))) + PX };

            // first call
            if (!defined(label)) {

                tick.label = label =
                    defined(str) && labelOptions.enabled ?
                        chart.renderer.text(
                                str,
                                0,
                                0,
                                labelOptions.useHTML
                            )
                            //.attr(attr)
                            // without position absolute, IE export sometimes is wrong
                            .css(merge(labelOptions.style))
                            .add(axis.labelGroup) :
                        null;
                tick.labelLength = label && label.getBBox().width; // Un-rotated length
                tick.rotation = 0; // Base value to detect change for new calls to getBBox

            // update
            } else if (label) {
                label.attr({ text: str });
            }
        },

        /**
         * Get the offset height or width of the label
         */
        getLabelSize: function () {
            return this.label ?
                this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :
                0;
        },

        /**
         * Handle the label overflow by adjusting the labels to the left and right edge, or
         * hide them if they collide into the neighbour label.
         */
        handleOverflow: function (xy) {
            var axis = this.axis,
                pxPos = xy.x,
                chartWidth = axis.chart.chartWidth,
                spacing = axis.chart.spacing,
                leftBound = pick(axis.labelLeft, mathMin(axis.pos, spacing[3])),
                rightBound = pick(axis.labelRight, mathMax(axis.pos + axis.len, chartWidth - spacing[1])),
                label = this.label,
                rotation = this.rotation,
                factor = { left: 0, center: 0.5, right: 1 }[axis.labelAlign],
                labelWidth = label.getBBox().width,
                slotWidth = axis.getSlotWidth(),
                modifiedSlotWidth = slotWidth,
                xCorrection = factor,
                goRight = 1,
                leftPos,
                rightPos,
                textWidth,
                css = {};

            // Check if the label overshoots the chart spacing box. If it does, move it.
            // If it now overshoots the slotWidth, add ellipsis.
            if (!rotation) {
                leftPos = pxPos - factor * labelWidth;
                rightPos = pxPos + (1 - factor) * labelWidth;

                if (leftPos < leftBound) {
                    modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
                } else if (rightPos > rightBound) {
                    modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
                    goRight = -1;
                }

                modifiedSlotWidth = mathMin(slotWidth, modifiedSlotWidth); // #4177
                if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {
                    xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - mathMin(labelWidth, modifiedSlotWidth)));
                }
                // If the label width exceeds the available space, set a text width to be
                // picked up below. Also, if a width has been set before, we need to set a new
                // one because the reported labelWidth will be limited by the box (#3938).
                if (labelWidth > modifiedSlotWidth || (axis.autoRotation && label.styles.width)) {
                    textWidth = modifiedSlotWidth;
                }

            // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart
            } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
                textWidth = mathRound(pxPos / mathCos(rotation * deg2rad) - leftBound);
            } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
                textWidth = mathRound((chartWidth - pxPos) / mathCos(rotation * deg2rad));
            }

            if (textWidth) {
                css.width = textWidth;
                if (!axis.options.labels.style.textOverflow) {
                    css.textOverflow = 'ellipsis';
                }
                label.css(css);
            }
        },

        /**
         * Get the x and y position for ticks and labels
         */
        getPosition: function (horiz, pos, tickmarkOffset, old) {
            var axis = this.axis,
                chart = axis.chart,
                cHeight = (old && chart.oldChartHeight) || chart.chartHeight;

            return {
                x: horiz ?
                    axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB :
                    axis.left + axis.offset + (axis.opposite ? ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left : 0),

                y: horiz ?
                    cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) :
                    cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB
            };

        },

        /**
         * Get the x, y position of the tick label
         */
        getLabelPosition: function (x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
            var axis = this.axis,
                transA = axis.transA,
                reversed = axis.reversed,
                staggerLines = axis.staggerLines,
                rotCorr = axis.tickRotCorr || { x: 0, y: 0 },
                yOffset = labelOptions.y,
                line;

            if (!defined(yOffset)) {
                if (axis.side === 0) {
                    yOffset = label.rotation ? -8 : -label.getBBox().height;
                } else if (axis.side === 2) {
                    yOffset = rotCorr.y + 8;
                } else {
                    // #3140, #3140
                    yOffset = mathCos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
                }
            }

            x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?
                tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
            y = y + yOffset - (tickmarkOffset && !horiz ?
                tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

            // Correct for staggered labels
            if (staggerLines) {
                line = (index / (step || 1) % staggerLines);
                if (axis.opposite) {
                    line = staggerLines - line - 1;
                }
                y += line * (axis.labelOffset / staggerLines);
            }

            return {
                x: x,
                y: mathRound(y)
            };
        },

        /**
         * Extendible method to return the path of the marker
         */
        getMarkPath: function (x, y, tickLength, tickWidth, horiz, renderer) {
            return renderer.crispLine([
                M,
                x,
                y,
                L,
                x + (horiz ? 0 : -tickLength),
                y + (horiz ? tickLength : 0)
            ], tickWidth);
        },

        /**
         * Put everything in place
         *
         * @param index {Number}
         * @param old {Boolean} Use old coordinates to prepare an animation into new position
         */
        render: function (index, old, opacity) {
            var tick = this,
                axis = tick.axis,
                options = axis.options,
                chart = axis.chart,
                renderer = chart.renderer,
                horiz = axis.horiz,
                type = tick.type,
                label = tick.label,
                pos = tick.pos,
                labelOptions = options.labels,
                gridLine = tick.gridLine,
                gridPrefix = type ? type + 'Grid' : 'grid',
                tickPrefix = type ? type + 'Tick' : 'tick',
                gridLineWidth = options[gridPrefix + 'LineWidth'],
                gridLineColor = options[gridPrefix + 'LineColor'],
                dashStyle = options[gridPrefix + 'LineDashStyle'],
                tickSize = axis.tickSize(tickPrefix),
                tickColor = options[tickPrefix + 'Color'],
                gridLinePath,
                mark = tick.mark,
                markPath,
                step = /*axis.labelStep || */labelOptions.step,
                attribs,
                show = true,
                tickmarkOffset = axis.tickmarkOffset,
                xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
                x = xy.x,
                y = xy.y,
                reverseCrisp = ((horiz && x === axis.pos + axis.len) || (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687

            opacity = pick(opacity, 1);
            this.isActive = true;

            // create the grid line
            if (gridLineWidth) {
                gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLineWidth * reverseCrisp, old, true);

                if (gridLine === UNDEFINED) {
                    attribs = {
                        stroke: gridLineColor,
                        'stroke-width': gridLineWidth
                    };
                    if (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    if (!type) {
                        attribs.zIndex = 1;
                    }
                    if (old) {
                        attribs.opacity = 0;
                    }
                    tick.gridLine = gridLine =
                        gridLineWidth ?
                            renderer.path(gridLinePath)
                                .attr(attribs).add(axis.gridGroup) :
                            null;
                }

                // If the parameter 'old' is set, the current call will be followed
                // by another call, therefore do not do any animations this time
                if (!old && gridLine && gridLinePath) {
                    gridLine[tick.isNew ? 'attr' : 'animate']({
                        d: gridLinePath,
                        opacity: opacity
                    });
                }
            }

            // create the tick mark
            if (tickSize) {
                if (axis.opposite) {
                    tickSize[0] = -tickSize[0];
                }
                markPath = tick.getMarkPath(x, y, tickSize[0], tickSize[1] * reverseCrisp, horiz, renderer);
                if (mark) { // updating
                    mark.animate({
                        d: markPath,
                        opacity: opacity
                    });
                } else { // first time
                    tick.mark = renderer.path(
                        markPath
                    ).attr({
                        stroke: tickColor,
                        'stroke-width': tickSize[1],
                        opacity: opacity
                    }).add(axis.axisGroup);
                }
            }

            // the label is created on init - now move it into place
            if (label && isNumber(x)) {
                label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);

                // Apply show first and show last. If the tick is both first and last, it is
                // a single centered tick, in which case we show the label anyway (#2100).
                if ((tick.isFirst && !tick.isLast && !pick(options.showFirstLabel, 1)) ||
                        (tick.isLast && !tick.isFirst && !pick(options.showLastLabel, 1))) {
                    show = false;

                // Handle label overflow and show or hide accordingly
                } else if (horiz && !axis.isRadial && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
                    tick.handleOverflow(xy);
                }

                // apply step
                if (step && index % step) {
                    // show those indices dividable by step
                    show = false;
                }

                // Set the new position, and show or hide
                if (show && isNumber(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNew ? 'attr' : 'animate'](xy);
                } else {
                    stop(label); // #5332
                    label.attr('y', -9999); // #1338
                }
                tick.isNew = false;
            }
        },

        /**
         * Destructor for the tick prototype
         */
        destroy: function () {
            destroyObjectProperties(this, this.axis);
        }
    };

    /**
     * The object wrapper for plot lines and plot bands
     * @param {Object} options
     */
    Highcharts.PlotLineOrBand = function (axis, options) {
        this.axis = axis;

        if (options) {
            this.options = options;
            this.id = options.id;
        }
    };

    Highcharts.PlotLineOrBand.prototype = {

        /**
         * Render the plot line or plot band. If it is already existing,
         * move it.
         */
        render: function () {
            var plotLine = this,
                axis = plotLine.axis,
                horiz = axis.horiz,
                options = plotLine.options,
                optionsLabel = options.label,
                label = plotLine.label,
                width = options.width,
                to = options.to,
                from = options.from,
                isBand = defined(from) && defined(to),
                value = options.value,
                dashStyle = options.dashStyle,
                svgElem = plotLine.svgElem,
                path = [],
                addEvent,
                eventType,
                color = options.color,
                zIndex = pick(options.zIndex, 0),
                events = options.events,
                attribs = {},
                renderer = axis.chart.renderer,
                log2lin = axis.log2lin;

            // logarithmic conversion
            if (axis.isLog) {
                from = log2lin(from);
                to = log2lin(to);
                value = log2lin(value);
            }

            // plot line
            if (width) {
                path = axis.getPlotLinePath(value, width);
                attribs = {
                    stroke: color,
                    'stroke-width': width
                };
                if (dashStyle) {
                    attribs.dashstyle = dashStyle;
                }
            } else if (isBand) { // plot band

                path = axis.getPlotBandPath(from, to, options);
                if (color) {
                    attribs.fill = color;
                }
                if (options.borderWidth) {
                    attribs.stroke = options.borderColor;
                    attribs['stroke-width'] = options.borderWidth;
                }
            } else {
                return;
            }
            // zIndex
            attribs.zIndex = zIndex;

            // common for lines and bands
            if (svgElem) {
                if (path) {
                    svgElem.show();
                    svgElem.animate({ d: path });
                } else {
                    svgElem.hide();
                    if (label) {
                        plotLine.label = label = label.destroy();
                    }
                }
            } else if (path && path.length) {
                plotLine.svgElem = svgElem = renderer.path(path)
                    .attr(attribs).add();

                // events
                if (events) {
                    addEvent = function (eventType) {
                        svgElem.on(eventType, function (e) {
                            events[eventType].apply(plotLine, [e]);
                        });
                    };
                    for (eventType in events) {
                        addEvent(eventType);
                    }
                }
            }

            // the plot band/line label
            if (optionsLabel && defined(optionsLabel.text) && path && path.length && 
                    axis.width > 0 && axis.height > 0 && !path.flat) {
                // apply defaults
                optionsLabel = merge({
                    align: horiz && isBand && 'center',
                    x: horiz ? !isBand && 4 : 10,
                    verticalAlign: !horiz && isBand && 'middle',
                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                    rotation: horiz && !isBand && 90
                }, optionsLabel);

                this.renderLabel(optionsLabel, path, isBand, zIndex);

            } else if (label) { // move out of sight
                label.hide();
            }

            // chainable
            return plotLine;
        },

        /**
         * Render and align label for plot line or band.
         */
        renderLabel: function (optionsLabel, path, isBand, zIndex) {
            var plotLine = this,
                label = plotLine.label,
                renderer = plotLine.axis.chart.renderer,
                attribs,
                xs,
                ys,
                x,
                y;

            // add the SVG element
            if (!label) {
                attribs = {
                    align: optionsLabel.textAlign || optionsLabel.align,
                    rotation: optionsLabel.rotation
                };
            
                attribs.zIndex = zIndex;
            
                plotLine.label = label = renderer.text(
                        optionsLabel.text,
                        0,
                        0,
                        optionsLabel.useHTML
                    )
                    .attr(attribs)
                    .css(optionsLabel.style)
                    .add();
            }

            // get the bounding box and align the label
            // #3000 changed to better handle choice between plotband or plotline
            xs = [path[1], path[4], (isBand ? path[6] : path[1])];
            ys = [path[2], path[5], (isBand ? path[7] : path[2])];
            x = arrayMin(xs);
            y = arrayMin(ys);

            label.align(optionsLabel, false, {
                x: x,
                y: y,
                width: arrayMax(xs) - x,
                height: arrayMax(ys) - y
            });
            label.show();
        },

        /**
         * Remove the plot line or band
         */
        destroy: function () {
            // remove it from the lookup
            erase(this.axis.plotLinesAndBands, this);

            delete this.axis;
            destroyObjectProperties(this);
        }
    };

    /**
     * Object with members for extending the Axis prototype
     */

    AxisPlotLineOrBandExtension = {

        /**
         * Create the path for a plot band
         */
        getPlotBandPath: function (from, to) {
            var toPath = this.getPlotLinePath(to, null, null, true),
                path = this.getPlotLinePath(from, null, null, true);

            if (path && toPath) {

                // Flat paths don't need labels (#3836)
                path.flat = path.toString() === toPath.toString();

                path.push(
                    toPath[4],
                    toPath[5],
                    toPath[1],
                    toPath[2]
                );
            } else { // outside the axis area
                path = null;
            }

            return path;
        },

        addPlotBand: function (options) {
            return this.addPlotBandOrLine(options, 'plotBands');
        },

        addPlotLine: function (options) {
            return this.addPlotBandOrLine(options, 'plotLines');
        },

        /**
         * Add a plot band or plot line after render time
         *
         * @param options {Object} The plotBand or plotLine configuration object
         */
        addPlotBandOrLine: function (options, coll) {
            var obj = new Highcharts.PlotLineOrBand(this, options).render(),
                userOptions = this.userOptions;

            if (obj) { // #2189
                // Add it to the user options for exporting and Axis.update
                if (coll) {
                    userOptions[coll] = userOptions[coll] || [];
                    userOptions[coll].push(options);
                }
                this.plotLinesAndBands.push(obj);
            }

            return obj;
        },

        /**
         * Remove a plot band or plot line from the chart by id
         * @param {Object} id
         */
        removePlotBandOrLine: function (id) {
            var plotLinesAndBands = this.plotLinesAndBands,
                options = this.options,
                userOptions = this.userOptions,
                i = plotLinesAndBands.length;
            while (i--) {
                if (plotLinesAndBands[i].id === id) {
                    plotLinesAndBands[i].destroy();
                }
            }
            each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], function (arr) {
                i = arr.length;
                while (i--) {
                    if (arr[i].id === id) {
                        erase(arr, arr[i]);
                    }
                }
            });
        }
    };

    /**
     * Create a new axis object
     * @param {Object} chart
     * @param {Object} options
     */
    var Axis = Highcharts.Axis = function () {
        this.init.apply(this, arguments);
    };

    Axis.prototype = {

        /**
         * Default options for the X axis - the Y axis has extended defaults
         */
        defaultOptions: {
            // allowDecimals: null,
            // alternateGridColor: null,
            // categories: [],
            dateTimeLabelFormats: {
                millisecond: '%H:%M:%S.%L',
                second: '%H:%M:%S',
                minute: '%H:%M',
                hour: '%H:%M',
                day: '%e. %b',
                week: '%e. %b',
                month: '%b \'%y',
                year: '%Y'
            },
            endOnTick: false,
            gridLineColor: '#D8D8D8',
            // gridLineDashStyle: 'solid',
            // gridLineWidth: 0,
            // reversed: false,

            labels: {
                enabled: true,
                // rotation: 0,
                // align: 'center',
                // step: null,
                style: {
                    color: '#606060',
                    cursor: 'default',
                    fontSize: '11px'
                },
                x: 0
                //y: undefined
                /*formatter: function () {
                    return this.value;
                },*/
            },
            lineColor: '#C0D0E0',
            lineWidth: 1,
            //linkedTo: null,
            //max: undefined,
            //min: undefined,
            minPadding: 0.01,
            maxPadding: 0.01,
            //minRange: null,
            minorGridLineColor: '#E0E0E0',
            // minorGridLineDashStyle: null,
            minorGridLineWidth: 1,
            minorTickColor: '#A0A0A0',
            //minorTickInterval: null,
            minorTickLength: 2,
            minorTickPosition: 'outside', // inside or outside
            //minorTickWidth: 0,
            //opposite: false,
            //offset: 0,
            //plotBands: [{
            //    events: {},
            //    zIndex: 1,
            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }
            //}],
            //plotLines: [{
            //    events: {}
            //  dashStyle: {}
            //    zIndex:
            //    labels: { align, x, verticalAlign, y, style, rotation, textAlign }
            //}],
            //reversed: false,
            // showFirstLabel: true,
            // showLastLabel: true,
            startOfWeek: 1,
            startOnTick: false,
            tickColor: '#C0D0E0',
            //tickInterval: null,
            tickLength: 10,
            tickmarkPlacement: 'between', // on or between
            tickPixelInterval: 100,
            tickPosition: 'outside',
            //tickWidth: 1,
            title: {
                //text: null,
                align: 'middle', // low, middle or high
                //margin: 0 for horizontal, 10 for vertical axes,
                //rotation: 0,
                //side: 'outside',
                style: {
                    color: '#707070'
                }
                //x: 0,
                //y: 0
            },
            type: 'linear' // linear, logarithmic or datetime
            //visible: true
        },

        /**
         * This options set extends the defaultOptions for Y axes
         */
        defaultYAxisOptions: {
            endOnTick: true,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: true,
            labels: {
                x: -8
            },
            lineWidth: 0,
            maxPadding: 0.05,
            minPadding: 0.05,
            startOnTick: true,
            //tickWidth: 0,
            title: {
                rotation: 270,
                text: 'Values'
            },
            stackLabels: {
                enabled: false,
                //align: dynamic,
                //y: dynamic,
                //x: dynamic,
                //verticalAlign: dynamic,
                //textAlign: dynamic,
                //rotation: 0,
                formatter: function () {
                    return Highcharts.numberFormat(this.total, -1);
                },
                style: merge(defaultPlotOptions.line.dataLabels.style, { color: '#000000' })
            }
        },

        /**
         * These options extend the defaultOptions for left axes
         */
        defaultLeftAxisOptions: {
            labels: {
                x: -15
            },
            title: {
                rotation: 270
            }
        },

        /**
         * These options extend the defaultOptions for right axes
         */
        defaultRightAxisOptions: {
            labels: {
                x: 15
            },
            title: {
                rotation: 90
            }
        },

        /**
         * These options extend the defaultOptions for bottom axes
         */
        defaultBottomAxisOptions: {
            labels: {
                autoRotation: [-45],
                x: 0
                // overflow: undefined,
                // staggerLines: null
            },
            title: {
                rotation: 0
            }
        },
        /**
         * These options extend the defaultOptions for top axes
         */
        defaultTopAxisOptions: {
            labels: {
                autoRotation: [-45],
                x: 0
                // overflow: undefined
                // staggerLines: null
            },
            title: {
                rotation: 0
            }
        },

        /**
         * Initialize the axis
         */
        init: function (chart, userOptions) {


            var isXAxis = userOptions.isX,
                axis = this;

            axis.chart = chart;

            // Flag, is the axis horizontal
            axis.horiz = chart.inverted ? !isXAxis : isXAxis;

            // Flag, isXAxis
            axis.isXAxis = isXAxis;
            axis.coll = isXAxis ? 'xAxis' : 'yAxis';

            axis.opposite = userOptions.opposite; // needed in setOptions
            axis.side = userOptions.side || (axis.horiz ?
                    (axis.opposite ? 0 : 2) : // top : bottom
                    (axis.opposite ? 1 : 3));  // right : left

            axis.setOptions(userOptions);


            var options = this.options,
                type = options.type,
                isDatetimeAxis = type === 'datetime';

            axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter; // can be overwritten by dynamic format


            // Flag, stagger lines or not
            axis.userOptions = userOptions;

            //axis.axisTitleMargin = UNDEFINED,// = options.title.margin,
            axis.minPixelPadding = 0;

            axis.reversed = options.reversed;
            axis.visible = options.visible !== false;
            axis.zoomEnabled = options.zoomEnabled !== false;

            // Initial categories
            axis.categories = options.categories || type === 'category';
            axis.names = axis.names || []; // Preserve on update (#3830)

            // Elements
            //axis.axisGroup = UNDEFINED;
            //axis.gridGroup = UNDEFINED;
            //axis.axisTitle = UNDEFINED;
            //axis.axisLine = UNDEFINED;

            // Shorthand types
            axis.isLog = type === 'logarithmic';
            axis.isDatetimeAxis = isDatetimeAxis;

            // Flag, if axis is linked to another axis
            axis.isLinked = defined(options.linkedTo);
            // Linked axis.
            //axis.linkedParent = UNDEFINED;

            // Tick positions
            //axis.tickPositions = UNDEFINED; // array containing predefined positions
            // Tick intervals
            //axis.tickInterval = UNDEFINED;
            //axis.minorTickInterval = UNDEFINED;


            // Major ticks
            axis.ticks = {};
            axis.labelEdge = [];
            // Minor ticks
            axis.minorTicks = {};

            // List of plotLines/Bands
            axis.plotLinesAndBands = [];

            // Alternate bands
            axis.alternateBands = {};

            // Axis metrics
            //axis.left = UNDEFINED;
            //axis.top = UNDEFINED;
            //axis.width = UNDEFINED;
            //axis.height = UNDEFINED;
            //axis.bottom = UNDEFINED;
            //axis.right = UNDEFINED;
            //axis.transA = UNDEFINED;
            //axis.transB = UNDEFINED;
            //axis.oldTransA = UNDEFINED;
            axis.len = 0;
            //axis.oldMin = UNDEFINED;
            //axis.oldMax = UNDEFINED;
            //axis.oldUserMin = UNDEFINED;
            //axis.oldUserMax = UNDEFINED;
            //axis.oldAxisLength = UNDEFINED;
            axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
            axis.range = options.range;
            axis.offset = options.offset || 0;


            // Dictionary for stacks
            axis.stacks = {};
            axis.oldStacks = {};
            axis.stacksTouched = 0;

            // Min and max in the data
            //axis.dataMin = UNDEFINED,
            //axis.dataMax = UNDEFINED,

            // The axis range
            axis.max = null;
            axis.min = null;

            // User set min and max
            //axis.userMin = UNDEFINED,
            //axis.userMax = UNDEFINED,

            // Crosshair options
            axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1], false);
            // Run Axis

            var eventType,
                events = axis.options.events;

            // Register
            if (inArray(axis, chart.axes) === -1) { // don't add it again on Axis.update()
                if (isXAxis && !this.isColorAxis) { // #2713
                    chart.axes.splice(chart.xAxis.length, 0, axis);
                } else {
                    chart.axes.push(axis);
                }

                chart[axis.coll].push(axis);
            }

            axis.series = axis.series || []; // populated by Series

            // inverted charts have reversed xAxes as default
            if (chart.inverted && isXAxis && axis.reversed === UNDEFINED) {
                axis.reversed = true;
            }

            axis.removePlotBand = axis.removePlotBandOrLine;
            axis.removePlotLine = axis.removePlotBandOrLine;


            // register event listeners
            for (eventType in events) {
                addEvent(axis, eventType, events[eventType]);
            }

            // extend logarithmic axis
            if (axis.isLog) {
                axis.val2lin = axis.log2lin;
                axis.lin2val = axis.lin2log;
            }
        },

        /**
         * Merge and set options
         */
        setOptions: function (userOptions) {
            this.options = merge(
                this.defaultOptions,
                this.isXAxis ? {} : this.defaultYAxisOptions,
                [this.defaultTopAxisOptions, this.defaultRightAxisOptions,
                    this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side],
                merge(
                    defaultOptions[this.coll], // if set in setOptions (#1053)
                    userOptions
                )
            );
        },

        /**
         * The default label formatter. The context is a special config object for the label.
         */
        defaultLabelFormatter: function () {
            var axis = this.axis,
                value = this.value,
                categories = axis.categories,
                dateTimeLabelFormat = this.dateTimeLabelFormat,
                numericSymbols = defaultOptions.lang.numericSymbols,
                i = numericSymbols && numericSymbols.length,
                multi,
                ret,
                formatOption = axis.options.labels.format,

                // make sure the same symbol is added for all labels on a linear axis
                numericSymbolDetector = axis.isLog ? value : axis.tickInterval;

            if (formatOption) {
                ret = format(formatOption, this);

            } else if (categories) {
                ret = value;

            } else if (dateTimeLabelFormat) { // datetime axis
                ret = dateFormat(dateTimeLabelFormat, value);

            } else if (i && numericSymbolDetector >= 1000) {
                // Decide whether we should add a numeric symbol like k (thousands) or M (millions).
                // If we are to enable this in tooltip or other places as well, we can move this
                // logic to the numberFormatter and enable it by a parameter.
                while (i-- && ret === UNDEFINED) {
                    multi = Math.pow(1000, i + 1);
                    if (numericSymbolDetector >= multi && (value * 10) % multi === 0 && numericSymbols[i] !== null && value !== 0) { // #5480
                        ret = Highcharts.numberFormat(value / multi, -1) + numericSymbols[i];
                    }
                }
            }

            if (ret === UNDEFINED) {
                if (mathAbs(value) >= 10000) { // add thousands separators
                    ret = Highcharts.numberFormat(value, -1);

                } else { // small numbers
                    ret = Highcharts.numberFormat(value, -1, UNDEFINED, ''); // #2466
                }
            }

            return ret;
        },

        /**
         * Get the minimum and maximum for the series of each axis
         */
        getSeriesExtremes: function () {
            var axis = this,
                chart = axis.chart;

            axis.hasVisibleSeries = false;

            // Reset properties in case we're redrawing (#3353)
            axis.dataMin = axis.dataMax = axis.threshold = null;
            axis.softThreshold = !axis.isXAxis;

            if (axis.buildStacks) {
                axis.buildStacks();
            }

            // loop through this axis' series
            each(axis.series, function (series) {

                if (series.visible || !chart.options.chart.ignoreHiddenSeries) {

                    var seriesOptions = series.options,
                        xData,
                        threshold = seriesOptions.threshold,
                        seriesDataMin,
                        seriesDataMax;

                    axis.hasVisibleSeries = true;

                    // Validate threshold in logarithmic axes
                    if (axis.isLog && threshold <= 0) {
                        threshold = null;
                    }

                    // Get dataMin and dataMax for X axes
                    if (axis.isXAxis) {
                        xData = series.xData;
                        if (xData.length) {
                            // If xData contains values which is not numbers, then filter them out.
                            // To prevent performance hit, we only do this after we have already
                            // found seriesDataMin because in most cases all data is valid. #5234.
                            seriesDataMin = arrayMin(xData);
                            if (!isNumber(seriesDataMin) && !(seriesDataMin instanceof Date)) { // Date for #5010
                                xData = grep(xData, function (x) {
                                    return isNumber(x);
                                });
                                seriesDataMin = arrayMin(xData); // Do it again with valid data
                            }

                            axis.dataMin = mathMin(pick(axis.dataMin, xData[0]), seriesDataMin);
                            axis.dataMax = mathMax(pick(axis.dataMax, xData[0]), arrayMax(xData));
                        
                        }

                    // Get dataMin and dataMax for Y axes, as well as handle stacking and processed data
                    } else {

                        // Get this particular series extremes
                        series.getExtremes();
                        seriesDataMax = series.dataMax;
                        seriesDataMin = series.dataMin;

                        // Get the dataMin and dataMax so far. If percentage is used, the min and max are
                        // always 0 and 100. If seriesDataMin and seriesDataMax is null, then series
                        // doesn't have active y data, we continue with nulls
                        if (defined(seriesDataMin) && defined(seriesDataMax)) {
                            axis.dataMin = mathMin(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                            axis.dataMax = mathMax(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                        }

                        // Adjust to threshold
                        if (defined(threshold)) {
                            axis.threshold = threshold;
                        }
                        // If any series has a hard threshold, it takes precedence
                        if (!seriesOptions.softThreshold || axis.isLog) {
                            axis.softThreshold = false;
                        }
                    }
                }
            });
        },

        /**
         * Translate from axis value to pixel position on the chart, or back
         *
         */
        translate: function (val, backwards, cvsCoord, old, handleLog, pointPlacement) {
            var axis = this.linkedParent || this, // #1417
                sign = 1,
                cvsOffset = 0,
                localA = old ? axis.oldTransA : axis.transA,
                localMin = old ? axis.oldMin : axis.min,
                returnValue,
                minPixelPadding = axis.minPixelPadding,
                doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;

            if (!localA) {
                localA = axis.transA;
            }

            // In vertical axes, the canvas coordinates start from 0 at the top like in
            // SVG.
            if (cvsCoord) {
                sign *= -1; // canvas coordinates inverts the value
                cvsOffset = axis.len;
            }

            // Handle reversed axis
            if (axis.reversed) {
                sign *= -1;
                cvsOffset -= sign * (axis.sector || axis.len);
            }

            // From pixels to value
            if (backwards) { // reverse translation

                val = val * sign + cvsOffset;
                val -= minPixelPadding;
                returnValue = val / localA + localMin; // from chart pixel to value
                if (doPostTranslate) { // log and ordinal axes
                    returnValue = axis.lin2val(returnValue);
                }

            // From value to pixels
            } else {
                if (doPostTranslate) { // log and ordinal axes
                    val = axis.val2lin(val);
                }
                if (pointPlacement === 'between') {
                    pointPlacement = 0.5;
                }
                returnValue = sign * (val - localMin) * localA + cvsOffset + (sign * minPixelPadding) +
                    (isNumber(pointPlacement) ? localA * pointPlacement * axis.pointRange : 0);
            }

            return returnValue;
        },

        /**
         * Utility method to translate an axis value to pixel position.
         * @param {Number} value A value in terms of axis units
         * @param {Boolean} paneCoordinates Whether to return the pixel coordinate relative to the chart
         *        or just the axis/pane itself.
         */
        toPixels: function (value, paneCoordinates) {
            return this.translate(value, false, !this.horiz, null, true) + (paneCoordinates ? 0 : this.pos);
        },

        /*
         * Utility method to translate a pixel position in to an axis value
         * @param {Number} pixel The pixel value coordinate
         * @param {Boolean} paneCoordiantes Whether the input pixel is relative to the chart or just the
         *        axis/pane itself.
         */
        toValue: function (pixel, paneCoordinates) {
            return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, null, true);
        },

        /**
         * Create the path for a plot line that goes from the given value on
         * this axis, across the plot to the opposite side
         * @param {Number} value
         * @param {Number} lineWidth Used for calculation crisp line
         * @param {Number] old Use old coordinates (for resizing and rescaling)
         */
        getPlotLinePath: function (value, lineWidth, old, force, translatedValue) {
            var axis = this,
                chart = axis.chart,
                axisLeft = axis.left,
                axisTop = axis.top,
                x1,
                y1,
                x2,
                y2,
                cHeight = (old && chart.oldChartHeight) || chart.chartHeight,
                cWidth = (old && chart.oldChartWidth) || chart.chartWidth,
                skip,
                transB = axis.transB,
                /**
                 * Check if x is between a and b. If not, either move to a/b or skip,
                 * depending on the force parameter.
                 */
                between = function (x, a, b) {
                    if (x < a || x > b) {
                        if (force) {
                            x = mathMin(mathMax(a, x), b);
                        } else {
                            skip = true;
                        }
                    }
                    return x;
                };

            translatedValue = pick(translatedValue, axis.translate(value, null, null, old));
            x1 = x2 = mathRound(translatedValue + transB);
            y1 = y2 = mathRound(cHeight - translatedValue - transB);
            if (!isNumber(translatedValue)) { // no min or max
                skip = true;

            } else if (axis.horiz) {
                y1 = axisTop;
                y2 = cHeight - axis.bottom;
                x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
            } else {
                x1 = axisLeft;
                x2 = cWidth - axis.right;
                y1 = y2 = between(y1, axisTop, axisTop + axis.height);
            }
            return skip && !force ?
                null :
                chart.renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 1);
        },

        /**
         * Set the tick positions of a linear axis to round values like whole tens or every five.
         */
        getLinearTickPositions: function (tickInterval, min, max) {
            var pos,
                lastPos,
                roundedMin = correctFloat(mathFloor(min / tickInterval) * tickInterval),
                roundedMax = correctFloat(mathCeil(max / tickInterval) * tickInterval),
                tickPositions = [];

            // For single points, add a tick regardless of the relative position (#2662)
            if (min === max && isNumber(min)) {
                return [min];
            }

            // Populate the intermediate values
            pos = roundedMin;
            while (pos <= roundedMax) {

                // Place the tick on the rounded value
                tickPositions.push(pos);

                // Always add the raw tickInterval, not the corrected one.
                pos = correctFloat(pos + tickInterval);

                // If the interval is not big enough in the current min - max range to actually increase
                // the loop variable, we need to break out to prevent endless loop. Issue #619
                if (pos === lastPos) {
                    break;
                }

                // Record the last value
                lastPos = pos;
            }
            return tickPositions;
        },

        /**
         * Return the minor tick positions. For logarithmic axes, reuse the same logic
         * as for major ticks.
         */
        getMinorTickPositions: function () {
            var axis = this,
                options = axis.options,
                tickPositions = axis.tickPositions,
                minorTickInterval = axis.minorTickInterval,
                minorTickPositions = [],
                pos,
                i,
                pointRangePadding = axis.pointRangePadding || 0,
                min = axis.min - pointRangePadding, // #1498
                max = axis.max + pointRangePadding, // #1498
                range = max - min,
                len;

            // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.
            if (range && range / minorTickInterval < axis.len / 3) { // #3875

                if (axis.isLog) {
                    len = tickPositions.length;
                    for (i = 1; i < len; i++) {
                        minorTickPositions = minorTickPositions.concat(
                            axis.getLogTickPositions(minorTickInterval, tickPositions[i - 1], tickPositions[i], true)
                        );
                    }
                } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314
                    minorTickPositions = minorTickPositions.concat(
                        axis.getTimeTicks(
                            axis.normalizeTimeTickInterval(minorTickInterval),
                            min,
                            max,
                            options.startOfWeek
                        )
                    );
                } else {
                    for (pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval) {
                        minorTickPositions.push(pos);
                    }
                }
            }

            if (minorTickPositions.length !== 0) { // don't change the extremes, when there is no minor ticks
                axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick); // #3652 #3743 #1498
            }
            return minorTickPositions;
        },

        /**
         * Adjust the min and max for the minimum range. Keep in mind that the series data is
         * not yet processed, so we don't have information on data cropping and grouping, or
         * updated axis.pointRange or series.pointRange. The data can't be processed until
         * we have finally established min and max.
         */
        adjustForMinRange: function () {
            var axis = this,
                options = axis.options,
                min = axis.min,
                max = axis.max,
                zoomOffset,
                spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange,
                closestDataRange,
                i,
                distance,
                xData,
                loopLength,
                minArgs,
                maxArgs,
                minRange;

            // Set the automatic minimum range based on the closest point distance
            if (axis.isXAxis && axis.minRange === UNDEFINED && !axis.isLog) {

                if (defined(options.min) || defined(options.max)) {
                    axis.minRange = null; // don't do this again

                } else {

                    // Find the closest distance between raw data points, as opposed to
                    // closestPointRange that applies to processed points (cropped and grouped)
                    each(axis.series, function (series) {
                        xData = series.xData;
                        loopLength = series.xIncrement ? 1 : xData.length - 1;
                        for (i = loopLength; i > 0; i--) {
                            distance = xData[i] - xData[i - 1];
                            if (closestDataRange === UNDEFINED || distance < closestDataRange) {
                                closestDataRange = distance;
                            }
                        }
                    });
                    axis.minRange = mathMin(closestDataRange * 5, axis.dataMax - axis.dataMin);
                }
            }

            // if minRange is exceeded, adjust
            if (max - min < axis.minRange) {
                minRange = axis.minRange;
                zoomOffset = (minRange - max + min) / 2;

                // if min and max options have been set, don't go beyond it
                minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
                if (spaceAvailable) { // if space is available, stay within the data range
                    minArgs[2] = axis.dataMin;
                }
                min = arrayMax(minArgs);

                maxArgs = [min + minRange, pick(options.max, min + minRange)];
                if (spaceAvailable) { // if space is availabe, stay within the data range
                    maxArgs[2] = axis.dataMax;
                }

                max = arrayMin(maxArgs);

                // now if the max is adjusted, adjust the min back
                if (max - min < minRange) {
                    minArgs[0] = max - minRange;
                    minArgs[1] = pick(options.min, max - minRange);
                    min = arrayMax(minArgs);
                }
            }

            // Record modified extremes
            axis.min = min;
            axis.max = max;
        },

        /**
         * Find the closestPointRange across all series
         */
        getClosest: function () {
            var ret;

            if (this.categories) {
                ret = 1;
            } else {
                each(this.series, function (series) {
                    var seriesClosest = series.closestPointRange;
                    if (!series.noSharedTooltip && defined(seriesClosest)) {
                        ret = defined(ret) ?
                            mathMin(ret, seriesClosest) :
                            seriesClosest;
                    }
                });
            }
            return ret;
        },

        /**
         * Update translation information
         */
        setAxisTranslation: function (saveOld) {
            var axis = this,
                range = axis.max - axis.min,
                pointRange = axis.axisPointRange || 0,
                closestPointRange,
                minPointOffset = 0,
                pointRangePadding = 0,
                linkedParent = axis.linkedParent,
                ordinalCorrection,
                hasCategories = !!axis.categories,
                transA = axis.transA,
                isXAxis = axis.isXAxis;

            // Adjust translation for padding. Y axis with categories need to go through the same (#1784).
            if (isXAxis || hasCategories || pointRange) {
                if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;

                } else {
                
                    // Get the closest points
                    closestPointRange = axis.getClosest();

                    each(axis.series, function (series) {
                        var seriesPointRange = hasCategories ? 
                            1 : 
                            (isXAxis ? 
                                pick(series.options.pointRange, closestPointRange, 0) : 
                                (axis.axisPointRange || 0)), // #2806
                            pointPlacement = series.options.pointPlacement;

                        pointRange = mathMax(pointRange, seriesPointRange);

                        if (!axis.single) {
                            // minPointOffset is the value padding to the left of the axis in order to make
                            // room for points with a pointRange, typically columns. When the pointPlacement option
                            // is 'between' or 'on', this padding does not apply.
                            minPointOffset = mathMax(
                                minPointOffset,
                                isString(pointPlacement) ? 0 : seriesPointRange / 2
                            );

                            // Determine the total padding needed to the length of the axis to make room for the
                            // pointRange. If the series' pointPlacement is 'on', no padding is added.
                            pointRangePadding = mathMax(
                                pointRangePadding,
                                pointPlacement === 'on' ? 0 : seriesPointRange
                            );
                        }
                    });
                }

                // Record minPointOffset and pointRangePadding
                ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853
                axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;

                // pointRange means the width reserved for each point, like in a column chart
                axis.pointRange = mathMin(pointRange, range);

                // closestPointRange means the closest distance between points. In columns
                // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange
                // is some other value
                if (isXAxis) {
                    axis.closestPointRange = closestPointRange;
                }
            }

            // Secondary values
            if (saveOld) {
                axis.oldTransA = transA;
            }
            axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || 1);
            axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend
            axis.minPixelPadding = transA * minPointOffset;
        },

        minFromRange: function () {
            return this.max - this.range;
        },

        /**
         * Set the tick positions to round values and optionally extend the extremes
         * to the nearest tick
         */
        setTickInterval: function (secondPass) {
            var axis = this,
                chart = axis.chart,
                options = axis.options,
                isLog = axis.isLog,
                log2lin = axis.log2lin,
                isDatetimeAxis = axis.isDatetimeAxis,
                isXAxis = axis.isXAxis,
                isLinked = axis.isLinked,
                maxPadding = options.maxPadding,
                minPadding = options.minPadding,
                length,
                linkedParentExtremes,
                tickIntervalOption = options.tickInterval,
                minTickInterval,
                tickPixelIntervalOption = options.tickPixelInterval,
                categories = axis.categories,
                threshold = axis.threshold,
                softThreshold = axis.softThreshold,
                thresholdMin,
                thresholdMax,
                hardMin,
                hardMax;

            if (!isDatetimeAxis && !categories && !isLinked) {
                this.getTickAmount();
            }

            // Min or max set either by zooming/setExtremes or initial options
            hardMin = pick(axis.userMin, options.min);
            hardMax = pick(axis.userMax, options.max);

            // Linked axis gets the extremes from the parent axis
            if (isLinked) {
                axis.linkedParent = chart[axis.coll][options.linkedTo];
                linkedParentExtremes = axis.linkedParent.getExtremes();
                axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                if (options.type !== axis.linkedParent.options.type) {
                    error(11, 1); // Can't link axes of different type
                }

            // Initial min and max from the extreme data values
            } else {

                // Adjust to hard threshold
                if (!softThreshold && defined(threshold)) {
                    if (axis.dataMin >= threshold) {
                        thresholdMin = threshold;
                        minPadding = 0;
                    } else if (axis.dataMax <= threshold) {
                        thresholdMax = threshold;
                        maxPadding = 0;
                    }
                }

                axis.min = pick(hardMin, thresholdMin, axis.dataMin);
                axis.max = pick(hardMax, thresholdMax, axis.dataMax);

            }

            if (isLog) {
                if (!secondPass && mathMin(axis.min, pick(axis.dataMin, axis.min)) <= 0) { // #978
                    error(10, 1); // Can't plot negative values on log axis
                }
                // The correctFloat cures #934, float errors on full tens. But it
                // was too aggressive for #4360 because of conversion back to lin,
                // therefore use precision 15.
                axis.min = correctFloat(log2lin(axis.min), 15);
                axis.max = correctFloat(log2lin(axis.max), 15);
            }

            // handle zoomed range
            if (axis.range && defined(axis.max)) {
                axis.userMin = axis.min = hardMin = mathMax(axis.min, axis.minFromRange()); // #618
                axis.userMax = hardMax = axis.max;

                axis.range = null;  // don't use it when running setExtremes
            }

            // Hook for Highstock Scroller. Consider combining with beforePadding.
            fireEvent(axis, 'foundExtremes');

            // Hook for adjusting this.min and this.max. Used by bubble series.
            if (axis.beforePadding) {
                axis.beforePadding();
            }

            // adjust min and max for the minimum range
            axis.adjustForMinRange();

            // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding
            // into account, we do this after computing tick interval (#1337).
            if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {
                length = axis.max - axis.min;
                if (length) {
                    if (!defined(hardMin) && minPadding) {
                        axis.min -= length * minPadding;
                    }
                    if (!defined(hardMax)  && maxPadding) {
                        axis.max += length * maxPadding;
                    }
                }
            }

            // Stay within floor and ceiling
            if (isNumber(options.floor)) {
                axis.min = mathMax(axis.min, options.floor);
            }
            if (isNumber(options.ceiling)) {
                axis.max = mathMin(axis.max, options.ceiling);
            }

            // When the threshold is soft, adjust the extreme value only if
            // the data extreme and the padded extreme land on either side of the threshold. For example,
            // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the
            // default minPadding and startOnTick options. This is prevented by the softThreshold
            // option.
            if (softThreshold && defined(axis.dataMin)) {
                threshold = threshold || 0;
                if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
                    axis.min = threshold;
                } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
                    axis.max = threshold;
                }
            }


            // get tickInterval
            if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {
                axis.tickInterval = 1;
            } else if (isLinked && !tickIntervalOption &&
                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
            } else {
                axis.tickInterval = pick(
                    tickIntervalOption,
                    this.tickAmount ? ((axis.max - axis.min) / mathMax(this.tickAmount - 1, 1)) : undefined,
                    categories ? // for categoried axis, 1 is default, for linear axis use tickPix
                        1 :
                        // don't let it be more than the data range
                        (axis.max - axis.min) * tickPixelIntervalOption / mathMax(axis.len, tickPixelIntervalOption)
                );
            }

            // Now we're finished detecting min and max, crop and group series data. This
            // is in turn needed in order to find tick positions in ordinal axes.
            if (isXAxis && !secondPass) {
                each(axis.series, function (series) {
                    series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                });
            }

            // set the translation factor used in translate function
            axis.setAxisTranslation(true);

            // hook for ordinal axes and radial axes
            if (axis.beforeSetTickPositions) {
                axis.beforeSetTickPositions();
            }

            // hook for extensions, used in Highstock ordinal axes
            if (axis.postProcessTickInterval) {
                axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
            }

            // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)
            if (axis.pointRange && !tickIntervalOption) {
                axis.tickInterval = mathMax(axis.pointRange, axis.tickInterval);
            }

            // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.
            minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);
            if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                axis.tickInterval = minTickInterval;
            }

            // for linear axes, get magnitude and normalize the interval
            if (!isDatetimeAxis && !isLog && !tickIntervalOption) {
                axis.tickInterval = normalizeTickInterval(
                    axis.tickInterval,
                    null,
                    getMagnitude(axis.tickInterval),
                    // If the tick interval is between 0.5 and 5 and the axis max is in the order of
                    // thousands, chances are we are dealing with years. Don't allow decimals. #3363.
                    pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)),
                    !!this.tickAmount
                );
            }

            // Prevent ticks from getting so close that we can't draw the labels
            if (!this.tickAmount && this.len) { // Color axis with disabled legend has no length
                axis.tickInterval = axis.unsquish();
            }

            this.setTickPositions();
        },

        /**
         * Now we have computed the normalized tickInterval, get the tick positions
         */
        setTickPositions: function () {

            var options = this.options,
                tickPositions,
                tickPositionsOption = options.tickPositions,
                tickPositioner = options.tickPositioner,
                startOnTick = options.startOnTick,
                endOnTick = options.endOnTick,
                single;

            // Set the tickmarkOffset
            this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&
                this.tickInterval === 1) ? 0.5 : 0; // #3202


            // get minorTickInterval
            this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?
                this.tickInterval / 5 : options.minorTickInterval;

            // Find the tick positions
            this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)
            if (!tickPositions) {

                if (this.isDatetimeAxis) {
                    tickPositions = this.getTimeTicks(
                        this.normalizeTimeTickInterval(this.tickInterval, options.units),
                        this.min,
                        this.max,
                        options.startOfWeek,
                        this.ordinalPositions,
                        this.closestPointRange,
                        true
                    );
                } else if (this.isLog) {
                    tickPositions = this.getLogTickPositions(this.tickInterval, this.min, this.max);
                } else {
                    tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                }

                // Too dense ticks, keep only the first and last (#4477)
                if (tickPositions.length > this.len) {
                    tickPositions = [tickPositions[0], tickPositions.pop()];
                }

                this.tickPositions = tickPositions;

                // Run the tick positioner callback, that allows modifying auto tick positions.
                if (tickPositioner) {
                    tickPositioner = tickPositioner.apply(this, [this.min, this.max]);
                    if (tickPositioner) {
                        this.tickPositions = tickPositions = tickPositioner;
                    }
                }

            }

            if (!this.isLinked) {

                // reset min/max or remove extremes based on start/end on tick
                this.trimTicks(tickPositions, startOnTick, endOnTick);

                // When there is only one point, or all points have the same value on this axis, then min
                // and max are equal and tickPositions.length is 0 or 1. In this case, add some padding
                // in order to center the point, but leave it with one tick. #1337.
                if (this.min === this.max && defined(this.min) && !this.tickAmount) {
                    // Substract half a unit (#2619, #2846, #2515, #3390)
                    single = true;
                    this.min -= 0.5;
                    this.max += 0.5;
                }
                this.single = single;

                if (!tickPositionsOption && !tickPositioner) {
                    this.adjustTickAmount();
                }
            }
        },

        /**
         * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max
         */
        trimTicks: function (tickPositions, startOnTick, endOnTick) {
            var roundedMin = tickPositions[0],
                roundedMax = tickPositions[tickPositions.length - 1],
                minPointOffset = this.minPointOffset || 0;

            if (startOnTick) {
                this.min = roundedMin;
            } else {
                while (this.min - minPointOffset > tickPositions[0]) {
                    tickPositions.shift();
                }
            }

            if (endOnTick) {
                this.max = roundedMax;
            } else {
                while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
                    tickPositions.pop();
                }
            }

            // If no tick are left, set one tick in the middle (#3195)
            if (tickPositions.length === 0 && defined(roundedMin)) {
                tickPositions.push((roundedMax + roundedMin) / 2);
            }
        },

        /**
         * Check if there are multiple axes in the same pane
         * @returns {Boolean} There are other axes
         */
        alignToOthers: function () {
            var others = {}, // Whether there is another axis to pair with this one
                hasOther,
                options = this.options;

            if (this.chart.options.chart.alignTicks !== false && options.alignTicks !== false) {
                each(this.chart[this.coll], function (axis) {
                    var otherOptions = axis.options,
                        horiz = axis.horiz,
                        key = [
                            horiz ? otherOptions.left : otherOptions.top, 
                            otherOptions.width,
                            otherOptions.height, 
                            otherOptions.pane
                        ].join(',');


                    if (axis.series.length) { // #4442
                        if (others[key]) {
                            hasOther = true; // #4201
                        } else {
                            others[key] = 1;
                        }
                    }
                });
            }
            return hasOther;
        },

        /**
         * Set the max ticks of either the x and y axis collection
         */
        getTickAmount: function () {
            var options = this.options,
                tickAmount = options.tickAmount,
                tickPixelInterval = options.tickPixelInterval;

            if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&
                    !this.isLog && options.startOnTick && options.endOnTick) {
                tickAmount = 2;
            }

            if (!tickAmount && this.alignToOthers()) {
                // Add 1 because 4 tick intervals require 5 ticks (including first and last)
                tickAmount = mathCeil(this.len / tickPixelInterval) + 1;
            }

            // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This
            // prevents the axis from adding ticks that are too far away from the data extremes.
            if (tickAmount < 4) {
                this.finalTickAmt = tickAmount;
                tickAmount = 5;
            }

            this.tickAmount = tickAmount;
        },

        /**
         * When using multiple axes, adjust the number of ticks to match the highest
         * number of ticks in that group
         */
        adjustTickAmount: function () {
            var tickInterval = this.tickInterval,
                tickPositions = this.tickPositions,
                tickAmount = this.tickAmount,
                finalTickAmt = this.finalTickAmt,
                currentTickAmount = tickPositions && tickPositions.length,
                i,
                len;

            if (currentTickAmount < tickAmount) {
                while (tickPositions.length < tickAmount) {
                    tickPositions.push(correctFloat(
                        tickPositions[tickPositions.length - 1] + tickInterval
                    ));
                }
                this.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                this.max = tickPositions[tickPositions.length - 1];

            // We have too many ticks, run second pass to try to reduce ticks
            } else if (currentTickAmount > tickAmount) {
                this.tickInterval *= 2;
                this.setTickPositions();
            }

            // The finalTickAmt property is set in getTickAmount
            if (defined(finalTickAmt)) {
                i = len = tickPositions.length;
                while (i--) {
                    if (
                        (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick
                        (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last
                    ) {
                        tickPositions.splice(i, 1);
                    }
                }
                this.finalTickAmt = UNDEFINED;
            }
        },

        /**
         * Set the scale based on data min and max, user set min and max or options
         *
         */
        setScale: function () {
            var axis = this,
                isDirtyData,
                isDirtyAxisLength;

            axis.oldMin = axis.min;
            axis.oldMax = axis.max;
            axis.oldAxisLength = axis.len;

            // set the new axisLength
            axis.setAxisSize();
            //axisLength = horiz ? axisWidth : axisHeight;
            isDirtyAxisLength = axis.len !== axis.oldAxisLength;

            // is there new data?
            each(axis.series, function (series) {
                if (series.isDirtyData || series.isDirty ||
                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well
                    isDirtyData = true;
                }
            });

            // do we really need to go through all this?
            if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
                axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {

                if (axis.resetStacks) {
                    axis.resetStacks();
                }

                axis.forceRedraw = false;

                // get data extremes if needed
                axis.getSeriesExtremes();

                // get fixed positions based on tickInterval
                axis.setTickInterval();

                // record old values to decide whether a rescale is necessary later on (#540)
                axis.oldUserMin = axis.userMin;
                axis.oldUserMax = axis.userMax;

                // Mark as dirty if it is not already set to dirty and extremes have changed. #595.
                if (!axis.isDirty) {
                    axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                }
            } else if (axis.cleanStacks) {
                axis.cleanStacks();
            }
        },

        /**
         * Set the extremes and optionally redraw
         * @param {Number} newMin
         * @param {Number} newMax
         * @param {Boolean} redraw
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         * @param {Object} eventArguments
         *
         */
        setExtremes: function (newMin, newMax, redraw, animation, eventArguments) {
            var axis = this,
                chart = axis.chart;

            redraw = pick(redraw, true); // defaults to true

            each(axis.series, function (serie) {
                delete serie.kdTree;
            });

            // Extend the arguments with min and max
            eventArguments = extend(eventArguments, {
                min: newMin,
                max: newMax
            });

            // Fire the event
            fireEvent(axis, 'setExtremes', eventArguments, function () { // the default event handler

                axis.userMin = newMin;
                axis.userMax = newMax;
                axis.eventArgs = eventArguments;

                if (redraw) {
                    chart.redraw(animation);
                }
            });
        },

        /**
         * Overridable method for zooming chart. Pulled out in a separate method to allow overriding
         * in stock charts.
         */
        zoom: function (newMin, newMax) {
            var dataMin = this.dataMin,
                dataMax = this.dataMax,
                options = this.options,
                min = mathMin(dataMin, pick(options.min, dataMin)),
                max = mathMax(dataMax, pick(options.max, dataMax));

            // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.
            if (!this.allowZoomOutside) {
                if (defined(dataMin) && newMin <= min) {
                    newMin = min;
                }
                if (defined(dataMax) && newMax >= max) {
                    newMax = max;
                }
            }

            // In full view, displaying the reset zoom button is not required
            this.displayBtn = newMin !== UNDEFINED || newMax !== UNDEFINED;

            // Do it
            this.setExtremes(
                newMin,
                newMax,
                false,
                UNDEFINED,
                { trigger: 'zoom' }
            );
            return true;
        },

        /**
         * Update the axis metrics
         */
        setAxisSize: function () {
            var chart = this.chart,
                options = this.options,
                offsetLeft = options.offsetLeft || 0,
                offsetRight = options.offsetRight || 0,
                horiz = this.horiz,
                width = pick(options.width, chart.plotWidth - offsetLeft + offsetRight),
                height = pick(options.height, chart.plotHeight),
                top = pick(options.top, chart.plotTop),
                left = pick(options.left, chart.plotLeft + offsetLeft),
                percentRegex = /%$/;

            // Check for percentage based input values. Rounding fixes problems with
            // column overflow and plot line filtering (#4898, #4899)
            if (percentRegex.test(height)) {
                height = Math.round(parseFloat(height) / 100 * chart.plotHeight);
            }
            if (percentRegex.test(top)) {
                top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);
            }

            // Expose basic values to use in Series object and navigator
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
            this.bottom = chart.chartHeight - height - top;
            this.right = chart.chartWidth - width - left;

            // Direction agnostic properties
            this.len = mathMax(horiz ? width : height, 0); // mathMax fixes #905
            this.pos = horiz ? left : top; // distance from SVG origin
        },

        /**
         * Get the actual axis extremes
         */
        getExtremes: function () {
            var axis = this,
                isLog = axis.isLog,
                lin2log = axis.lin2log;

            return {
                min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                dataMin: axis.dataMin,
                dataMax: axis.dataMax,
                userMin: axis.userMin,
                userMax: axis.userMax
            };
        },

        /**
         * Get the zero plane either based on zero or on the min or max value.
         * Used in bar and area plots
         */
        getThreshold: function (threshold) {
            var axis = this,
                isLog = axis.isLog,
                lin2log = axis.lin2log,
                realMin = isLog ? lin2log(axis.min) : axis.min,
                realMax = isLog ? lin2log(axis.max) : axis.max;

            if (threshold === null) {
                threshold = realMin;
            } else if (realMin > threshold) {
                threshold = realMin;
            } else if (realMax < threshold) {
                threshold = realMax;
            }

            return axis.translate(threshold, 0, 1, 0, 1);
        },

        /**
         * Compute auto alignment for the axis label based on which side the axis is on
         * and the given rotation for the label
         */
        autoLabelAlign: function (rotation) {
            var ret,
                angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;

            if (angle > 15 && angle < 165) {
                ret = 'right';
            } else if (angle > 195 && angle < 345) {
                ret = 'left';
            } else {
                ret = 'center';
            }
            return ret;
        },

        /**
         * Get the tick length and width for the axis.
         * @param   {String} prefix 'tick' or 'minorTick'
         * @returns {Array}        An array of tickLength and tickWidth
         */
        tickSize: function (prefix) {
            var options = this.options,
                tickLength = options[prefix + 'Length'],
                tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1

            if (tickWidth && tickLength) {
                // Negate the length
                if (options[prefix + 'Position'] === 'inside') {
                    tickLength = -tickLength;
                }
                return [tickLength, tickWidth];
            }
            
        },

        /**
         * Return the size of the labels
         */
        labelMetrics: function () {
            return this.chart.renderer.fontMetrics(
                this.options.labels.style.fontSize, 
                this.ticks[0] && this.ticks[0].label
            );
        },

        /**
         * Prevent the ticks from getting so close we can't draw the labels. On a horizontal
         * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.
         * On a vertical axis remove ticks and add ellipsis.
         */
        unsquish: function () {
            var labelOptions = this.options.labels,
                horiz = this.horiz,
                tickInterval = this.tickInterval,
                newTickInterval = tickInterval,
                slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),
                rotation,
                rotationOption = labelOptions.rotation,
                labelMetrics = this.labelMetrics(),
                step,
                bestScore = Number.MAX_VALUE,
                autoRotation,
                // Return the multiple of tickInterval that is needed to avoid collision
                getStep = function (spaceNeeded) {
                    var step = spaceNeeded / (slotSize || 1);
                    step = step > 1 ? mathCeil(step) : 1;
                    return step * tickInterval;
                };

            if (horiz) {
                autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971
                    defined(rotationOption) ?
                        [rotationOption] :
                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation
                );

                if (autoRotation) {

                    // Loop over the given autoRotation options, and determine which gives the best score. The
                    // best score is that with the lowest number of steps and a rotation closest to horizontal.
                    each(autoRotation, function (rot) {
                        var score;

                        if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891

                            step = getStep(mathAbs(labelMetrics.h / mathSin(deg2rad * rot)));

                            score = step + mathAbs(rot / 360);

                            if (score < bestScore) {
                                bestScore = score;
                                rotation = rot;
                                newTickInterval = step;
                            }
                        }
                    });
                }

            } else if (!labelOptions.step) { // #4411
                newTickInterval = getStep(labelMetrics.h);
            }

            this.autoRotation = autoRotation;
            this.labelRotation = pick(rotation, rotationOption);

            return newTickInterval;
        },

        /**
         * Get the general slot width for this axis. This may change between the pre-render (from Axis.getOffset) 
         * and the final tick rendering and placement (#5086).
         */
        getSlotWidth: function () {
            var chart = this.chart,
                horiz = this.horiz,
                labelOptions = this.options.labels,
                slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
                marginLeft = chart.margin[3];

            return (horiz && (labelOptions.step || 0) < 2 && !labelOptions.rotation && // #4415
                ((this.staggerLines || 1) * chart.plotWidth) / slotCount) ||
                (!horiz && ((marginLeft && (marginLeft - chart.spacing[3])) || chart.chartWidth * 0.33)); // #1580, #1931

        },

        /**
         * Render the axis labels and determine whether ellipsis or rotation need to be applied
         */
        renderUnsquish: function () {
            var chart = this.chart,
                renderer = chart.renderer,
                tickPositions = this.tickPositions,
                ticks = this.ticks,
                labelOptions = this.options.labels,
                horiz = this.horiz,
                slotWidth = this.getSlotWidth(),
                innerWidth = mathMax(1, mathRound(slotWidth - 2 * (labelOptions.padding || 5))),
                attr = {},
                labelMetrics = this.labelMetrics(),
                textOverflowOption = labelOptions.style.textOverflow,
                css,
                labelLength = 0,
                label,
                i,
                pos;

            // Set rotation option unless it is "auto", like in gauges
            if (!isString(labelOptions.rotation)) {
                attr.rotation = labelOptions.rotation || 0; // #4443
            }

            // Handle auto rotation on horizontal axis
            if (this.autoRotation) {

                // Get the longest label length
                each(tickPositions, function (tick) {
                    tick = ticks[tick];
                    if (tick && tick.labelLength > labelLength) {
                        labelLength = tick.labelLength;
                    }
                });

                // Apply rotation only if the label is too wide for the slot, and
                // the label is wider than its height.
                if (labelLength > innerWidth && labelLength > labelMetrics.h) {
                    attr.rotation = this.labelRotation;
                } else {
                    this.labelRotation = 0;
                }

            // Handle word-wrap or ellipsis on vertical axis
            } else if (slotWidth) {
                // For word-wrap or ellipsis
                css = { width: innerWidth + PX };

                if (!textOverflowOption) {
                    css.textOverflow = 'clip';

                    // On vertical axis, only allow word wrap if there is room for more lines.
                    i = tickPositions.length;
                    while (!horiz && i--) {
                        pos = tickPositions[i];
                        label = ticks[pos].label;
                        if (label) {
                            // Reset ellipsis in order to get the correct bounding box (#4070)
                            if (label.styles.textOverflow === 'ellipsis') {
                                label.css({ textOverflow: 'clip' });

                            // Set the correct width in order to read the bounding box height (#4678, #5034)
                            } else if (ticks[pos].labelLength > slotWidth) {
                                label.css({ width: slotWidth + 'px' });
                            }

                            if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                                label.specCss = { textOverflow: 'ellipsis' };
                            }
                        }
                    }
                }
            }


            // Add ellipsis if the label length is significantly longer than ideal
            if (attr.rotation) {
                css = {
                    width: (labelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + PX
                };
                if (!textOverflowOption) {
                    css.textOverflow = 'ellipsis';
                }
            }

            // Set the explicit or automatic label alignment
            this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
            if (this.labelAlign) {
                attr.align = this.labelAlign;
            }

            // Apply general and specific CSS
            each(tickPositions, function (pos) {
                var tick = ticks[pos],
                    label = tick && tick.label;
                if (label) {
                    label.attr(attr); // This needs to go before the CSS in old IE (#4502)
                    if (css) {
                        label.css(merge(css, label.specCss));
                    }
                    delete label.specCss;
                    tick.rotation = attr.rotation;
                }
            });

            // Note: Why is this not part of getLabelPosition?
            this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
        },

        /**
         * Return true if the axis has associated data
         */
        hasData: function () {
            return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);
        },

        /**
         * Render the tick labels to a preliminary position to get their sizes
         */
        getOffset: function () {
            var axis = this,
                chart = axis.chart,
                renderer = chart.renderer,
                options = axis.options,
                tickPositions = axis.tickPositions,
                ticks = axis.ticks,
                horiz = axis.horiz,
                side = axis.side,
                invertedSide = chart.inverted ? [1, 0, 3, 2][side] : side,
                hasData,
                showAxis,
                titleOffset = 0,
                titleOffsetOption,
                titleMargin = 0,
                axisTitleOptions = options.title,
                labelOptions = options.labels,
                labelOffset = 0, // reset
                labelOffsetPadded,
                opposite = axis.opposite,
                axisOffset = chart.axisOffset,
                clipOffset = chart.clipOffset,
                clip,
                directionFactor = [-1, 1, 1, -1][side],
                n,
                textAlign,
                axisParent = axis.axisParent, // Used in color axis
                lineHeightCorrection,
                tickSize = this.tickSize('tick');

            // For reuse in Axis.render
            hasData = axis.hasData();
            axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);

            // Set/reset staggerLines
            axis.staggerLines = axis.horiz && labelOptions.staggerLines;

            // Create the axisGroup and gridGroup elements on first iteration
            if (!axis.axisGroup) {
                axis.gridGroup = renderer.g('grid')
                    .attr({ zIndex: options.gridZIndex || 1 })
                    .add(axisParent);
                axis.axisGroup = renderer.g('axis')
                    .attr({ zIndex: options.zIndex || 2 })
                    .add(axisParent);
                axis.labelGroup = renderer.g('axis-labels')
                    .attr({ zIndex: labelOptions.zIndex || 7 })
                    .addClass(PREFIX + axis.coll.toLowerCase() + '-labels')
                    .add(axisParent);
            }

            if (hasData || axis.isLinked) {

                // Generate ticks
                each(tickPositions, function (pos) {
                    if (!ticks[pos]) {
                        ticks[pos] = new Tick(axis, pos);
                    } else {
                        ticks[pos].addLabel(); // update labels depending on tick interval
                    }
                });

                axis.renderUnsquish();


                // Left side must be align: right and right side must have align: left for labels
                if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 ||
                        { 1: 'left', 3: 'right' }[side] === axis.labelAlign || axis.labelAlign === 'center')) {
                    each(tickPositions, function (pos) {

                        // get the highest offset
                        labelOffset = mathMax(
                            ticks[pos].getLabelSize(),
                            labelOffset
                        );
                    });
                }

                if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                    axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
                }


            } else { // doesn't have data
                for (n in ticks) {
                    ticks[n].destroy();
                    delete ticks[n];
                }
            }

            if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
                if (!axis.axisTitle) {
                    textAlign = axisTitleOptions.textAlign;
                    if (!textAlign) {
                        textAlign = (horiz ? { 
                            low: 'left',
                            middle: 'center',
                            high: 'right'
                        } : { 
                            low: opposite ? 'right' : 'left',
                            middle: 'center',
                            high: opposite ? 'left' : 'right'
                        })[axisTitleOptions.align];
                    }
                    axis.axisTitle = renderer.text(
                        axisTitleOptions.text,
                        0,
                        0,
                        axisTitleOptions.useHTML
                    )
                    .attr({
                        zIndex: 7,
                        rotation: axisTitleOptions.rotation || 0,
                        align: textAlign
                    })
                    .addClass(PREFIX + this.coll.toLowerCase() + '-title')
                    .css(axisTitleOptions.style)
                    .add(axis.axisGroup);
                    axis.axisTitle.isNew = true;
                }

                if (showAxis) {
                    titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
                    titleOffsetOption = axisTitleOptions.offset;
                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
                }

                // hide or show the title depending on whether showEmpty is set
                axis.axisTitle[showAxis ? 'show' : 'hide'](true);
            }

            // handle automatic or user set offset
            axis.offset = directionFactor * pick(options.offset, axisOffset[side]);

            axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 }; // polar
            if (side === 0) {
                lineHeightCorrection = -axis.labelMetrics().h;
            } else if (side === 2) {
                lineHeightCorrection = axis.tickRotCorr.y;
            } else {
                lineHeightCorrection = 0;
            }

            // Find the padded label offset
            labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
            if (labelOffset) {
                labelOffsetPadded -= lineHeightCorrection;
                labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
            }
            axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);

            axisOffset[side] = mathMax(
                axisOffset[side],
                axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
                labelOffsetPadded, // #3027
                hasData && tickPositions.length && tickSize ? tickSize[0] : 0 // #4866
            );

            // Decide the clipping needed to keep the graph inside the plot area and axis lines
            clip = options.offset ? 0 : mathFloor(options.lineWidth / 2) * 2; // #4308, #4371
            clipOffset[invertedSide] = mathMax(clipOffset[invertedSide], clip);
        },

        /**
         * Get the path for the axis line
         */
        getLinePath: function (lineWidth) {
            var chart = this.chart,
                opposite = this.opposite,
                offset = this.offset,
                horiz = this.horiz,
                lineLeft = this.left + (opposite ? this.width : 0) + offset,
                lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;

            if (opposite) {
                lineWidth *= -1; // crispify the other way - #1480, #1687
            }

            return chart.renderer
                .crispLine([
                    M,
                    horiz ?
                        this.left :
                        lineLeft,
                    horiz ?
                        lineTop :
                        this.top,
                    L,
                    horiz ?
                        chart.chartWidth - this.right :
                        lineLeft,
                    horiz ?
                        lineTop :
                        chart.chartHeight - this.bottom
                ], lineWidth);
        },

        /**
         * Position the title
         */
        getTitlePosition: function () {
            // compute anchor points for each of the title align options
            var horiz = this.horiz,
                axisLeft = this.left,
                axisTop = this.top,
                axisLength = this.len,
                axisTitleOptions = this.options.title,
                margin = horiz ? axisLeft : axisTop,
                opposite = this.opposite,
                offset = this.offset,
                xOption = axisTitleOptions.x || 0,
                yOption = axisTitleOptions.y || 0,
                fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style.fontSize).f,

                // the position in the length direction of the axis
                alongAxis = {
                    low: margin + (horiz ? 0 : axisLength),
                    middle: margin + axisLength / 2,
                    high: margin + (horiz ? axisLength : 0)
                }[axisTitleOptions.align],

                // the position in the perpendicular direction of the axis
                offAxis = (horiz ? axisTop + this.height : axisLeft) +
                    (horiz ? 1 : -1) * // horizontal axis reverses the margin
                    (opposite ? -1 : 1) * // so does opposite axes
                    this.axisTitleMargin +
                    (this.side === 2 ? fontSize : 0);

            return {
                x: horiz ?
                    alongAxis + xOption :
                    offAxis + (opposite ? this.width : 0) + offset + xOption,
                y: horiz ?
                    offAxis + yOption - (opposite ? this.height : 0) + offset :
                    alongAxis + yOption
            };
        },

        /**
         * Render the axis
         */
        render: function () {
            var axis = this,
                chart = axis.chart,
                renderer = chart.renderer,
                options = axis.options,
                isLog = axis.isLog,
                lin2log = axis.lin2log,
                isLinked = axis.isLinked,
                tickPositions = axis.tickPositions,
                axisTitle = axis.axisTitle,
                ticks = axis.ticks,
                minorTicks = axis.minorTicks,
                alternateBands = axis.alternateBands,
                stackLabelOptions = options.stackLabels,
                alternateGridColor = options.alternateGridColor,
                tickmarkOffset = axis.tickmarkOffset,
                lineWidth = options.lineWidth,
                linePath,
                hasRendered = chart.hasRendered,
                slideInTicks = hasRendered && isNumber(axis.oldMin),
                showAxis = axis.showAxis,
                animation = animObject(renderer.globalAnimation),
                from,
                to;

            // Reset
            axis.labelEdge.length = 0;
            //axis.justifyToPlot = overflow === 'justify';
            axis.overlap = false;

            // Mark all elements inActive before we go over and mark the active ones
            each([ticks, minorTicks, alternateBands], function (coll) {
                var pos;
                for (pos in coll) {
                    coll[pos].isActive = false;
                }
            });

            // If the series has data draw the ticks. Else only the line and title
            if (axis.hasData() || isLinked) {

                // minor ticks
                if (axis.minorTickInterval && !axis.categories) {
                    each(axis.getMinorTickPositions(), function (pos) {
                        if (!minorTicks[pos]) {
                            minorTicks[pos] = new Tick(axis, pos, 'minor');
                        }

                        // render new ticks in old position
                        if (slideInTicks && minorTicks[pos].isNew) {
                            minorTicks[pos].render(null, true);
                        }

                        minorTicks[pos].render(null, false, 1);
                    });
                }

                // Major ticks. Pull out the first item and render it last so that
                // we can get the position of the neighbour label. #808.
                if (tickPositions.length) { // #1300
                    each(tickPositions, function (pos, i) {

                        // linked axes need an extra check to find out if
                        if (!isLinked || (pos >= axis.min && pos <= axis.max)) {

                            if (!ticks[pos]) {
                                ticks[pos] = new Tick(axis, pos);
                            }

                            // render new ticks in old position
                            if (slideInTicks && ticks[pos].isNew) {
                                ticks[pos].render(i, true, 0.1);
                            }

                            ticks[pos].render(i);
                        }

                    });
                    // In a categorized axis, the tick marks are displayed between labels. So
                    // we need to add a tick mark and grid line at the left edge of the X axis.
                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                        if (!ticks[-1]) {
                            ticks[-1] = new Tick(axis, -1, null, true);
                        }
                        ticks[-1].render(-1);
                    }

                }

                // alternate grid color
                if (alternateGridColor) {
                    each(tickPositions, function (pos, i) {
                        to = tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset; 
                        if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660
                            if (!alternateBands[pos]) {
                                alternateBands[pos] = new Highcharts.PlotLineOrBand(axis);
                            }
                            from = pos + tickmarkOffset; // #949
                            alternateBands[pos].options = {
                                from: isLog ? lin2log(from) : from,
                                to: isLog ? lin2log(to) : to,
                                color: alternateGridColor
                            };
                            alternateBands[pos].render();
                            alternateBands[pos].isActive = true;
                        }
                    });
                }

                // custom plot lines and bands
                if (!axis._addedPlotLB) { // only first time
                    each((options.plotLines || []).concat(options.plotBands || []), function (plotLineOptions) {
                        axis.addPlotBandOrLine(plotLineOptions);
                    });
                    axis._addedPlotLB = true;
                }

            } // end if hasData

            // Remove inactive ticks
            each([ticks, minorTicks, alternateBands], function (coll) {
                var pos,
                    i,
                    forDestruction = [],
                    delay = animation.duration,
                    destroyInactiveItems = function () {
                        i = forDestruction.length;
                        while (i--) {
                            // When resizing rapidly, the same items may be destroyed in different timeouts,
                            // or the may be reactivated
                            if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                                coll[forDestruction[i]].destroy();
                                delete coll[forDestruction[i]];
                            }
                        }

                    };

                for (pos in coll) {

                    if (!coll[pos].isActive) {
                        // Render to zero opacity
                        coll[pos].render(pos, false, 0);
                        coll[pos].isActive = false;
                        forDestruction.push(pos);
                    }
                }

                // When the objects are finished fading out, destroy them
                syncTimeout(
                    destroyInactiveItems, 
                    coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay
                );
            });

            // Static items. As the axis group is cleared on subsequent calls
            // to render, these items are added outside the group.
            // axis line
            if (lineWidth) {
                linePath = axis.getLinePath(lineWidth);
                if (!axis.axisLine) {
                    axis.axisLine = renderer.path(linePath)
                        .attr({
                            stroke: options.lineColor,
                            'stroke-width': lineWidth,
                            zIndex: 7
                        })
                        .add(axis.axisGroup);
                } else {
                    axis.axisLine.animate({ d: linePath });
                }

                // show or hide the line depending on options.showEmpty
                axis.axisLine[showAxis ? 'show' : 'hide'](true);
            }

            if (axisTitle && showAxis) {

                axisTitle[axisTitle.isNew ? 'attr' : 'animate'](
                    axis.getTitlePosition()
                );
                axisTitle.isNew = false;
            }

            // Stacked totals:
            if (stackLabelOptions && stackLabelOptions.enabled) {
                axis.renderStackTotals();
            }
            // End stacked totals

            axis.isDirty = false;
        },

        /**
         * Redraw the axis to reflect changes in the data or axis extremes
         */
        redraw: function () {

            if (this.visible) {
                // render the axis
                this.render();

                // move plot lines and bands
                each(this.plotLinesAndBands, function (plotLine) {
                    plotLine.render();
                });
            }

            // mark associated series as dirty and ready for redraw
            each(this.series, function (series) {
                series.isDirty = true;
            });

        },

        /**
         * Destroys an Axis instance.
         */
        destroy: function (keepEvents) {
            var axis = this,
                stacks = axis.stacks,
                stackKey,
                plotLinesAndBands = axis.plotLinesAndBands,
                i;

            // Remove the events
            if (!keepEvents) {
                removeEvent(axis);
            }

            // Destroy each stack total
            for (stackKey in stacks) {
                destroyObjectProperties(stacks[stackKey]);

                stacks[stackKey] = null;
            }

            // Destroy collections
            each([axis.ticks, axis.minorTicks, axis.alternateBands], function (coll) {
                destroyObjectProperties(coll);
            });
            i = plotLinesAndBands.length;
            while (i--) { // #1975
                plotLinesAndBands[i].destroy();
            }

            // Destroy properties
            each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function (prop) {
                if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                }
            });


            this._addedPlotLB = this.chart._labelPanes = this.ordinalSlope = undefined; // #1611, #2887, #4314, #5316
        },

        /**
         * Draw the crosshair
         * 
         * @param  {Object} e The event arguments from the modified pointer event
         * @param  {Object} point The Point object
         */
        drawCrosshair: function (e, point) {

            var path,
                options = this.crosshair,
                pos,
                attribs,
                categorized,
                strokeWidth;

            // Use last available event when updating non-snapped crosshairs without
            // mouse interaction (#5287)
            if (!e) {
                e = this.cross && this.cross.e;
            }

            if (
                // Disabled in options
                !this.crosshair ||
                // Snap
                ((defined(point) || !pick(options.snap, true)) === false)
            ) {
                this.hideCrosshair();
            } else {

                // Get the path
                if (!pick(options.snap, true)) {
                    pos = (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
                } else if (defined(point)) {
                    pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834
                }

                if (this.isRadial) {
                    path = this.getPlotLinePath(this.isXAxis ? point.x : pick(point.stackY, point.y)) || null; // #3189
                } else {
                    path = this.getPlotLinePath(null, null, null, null, pos) || null; // #3189
                }

                if (path === null) {
                    this.hideCrosshair();
                    return;
                }

                categorized = this.categories && !this.isRadial;
                strokeWidth = pick(options.width, (categorized ? this.transA : 1));

                // Draw the cross
                if (this.cross) {
                    this.cross
                        .attr({
                            d: path,
                            visibility: 'visible',
                            'stroke-width': strokeWidth // #4737
                        });
                } else {
                    attribs = {
                        'pointer-events': 'none', // #5259
                        'stroke-width': strokeWidth,
                        stroke: options.color || (categorized ? 'rgba(155,200,255,0.2)' : '#C0C0C0'),
                        zIndex: pick(options.zIndex, 2)
                    };
                    if (options.dashStyle) {
                        attribs.dashstyle = options.dashStyle;
                    }
                    this.cross = this.chart.renderer.path(path).attr(attribs).add();
                }
                this.cross.e = e;
            }

        },

        /**
         *    Hide the crosshair.
         */
        hideCrosshair: function () {
            if (this.cross) {
                this.cross.hide();
            }
        }
    }; // end Axis

    extend(Axis.prototype, AxisPlotLineOrBandExtension);

    /**
     * Set the tick positions to a time unit that makes sense, for example
     * on the first of each month or on every Monday. Return an array
     * with the time positions. Used in datetime axes as well as for grouping
     * data on a datetime axis.
     *
     * @param {Object} normalizedInterval The interval in axis values (ms) and the count
     * @param {Number} min The minimum in axis values
     * @param {Number} max The maximum in axis values
     * @param {Number} startOfWeek
     */
    Axis.prototype.getTimeTicks = function (normalizedInterval, min, max, startOfWeek) {
        var tickPositions = [],
            i,
            higherRanks = {},
            useUTC = defaultOptions.global.useUTC,
            minYear, // used in months and years as a basis for Date.UTC()
            minDate = new Date(min - getTZOffset(min)),
            interval = normalizedInterval.unitRange,
            count = normalizedInterval.count;

        if (defined(min)) { // #1300
            minDate[setMilliseconds](interval >= timeUnits.second ? 0 : // #3935
                count * mathFloor(minDate.getMilliseconds() / count)); // #3652, #3654

            if (interval >= timeUnits.second) { // second
                minDate[setSeconds](interval >= timeUnits.minute ? 0 : // #3935
                    count * mathFloor(minDate.getSeconds() / count));
            }

            if (interval >= timeUnits.minute) { // minute
                minDate[setMinutes](interval >= timeUnits.hour ? 0 :
                    count * mathFloor(minDate[getMinutes]() / count));
            }

            if (interval >= timeUnits.hour) { // hour
                minDate[setHours](interval >= timeUnits.day ? 0 :
                    count * mathFloor(minDate[getHours]() / count));
            }

            if (interval >= timeUnits.day) { // day
                minDate[setDate](interval >= timeUnits.month ? 1 :
                    count * mathFloor(minDate[getDate]() / count));
            }

            if (interval >= timeUnits.month) { // month
                minDate[setMonth](interval >= timeUnits.year ? 0 :
                    count * mathFloor(minDate[getMonth]() / count));
                minYear = minDate[getFullYear]();
            }

            if (interval >= timeUnits.year) { // year
                minYear -= minYear % count;
                minDate[setFullYear](minYear);
            }

            // week is a special case that runs outside the hierarchy
            if (interval === timeUnits.week) {
                // get start of current week, independent of count
                minDate[setDate](minDate[getDate]() - minDate[getDay]() +
                    pick(startOfWeek, 1));
            }


            // get tick positions
            i = 1;
            if (timezoneOffset || getTimezoneOffset) {
                minDate = minDate.getTime();
                minDate = new Date(minDate + getTZOffset(minDate));
            }
            minYear = minDate[getFullYear]();
            var time = minDate.getTime(),
                minMonth = minDate[getMonth](),
                minDateDate = minDate[getDate](),
                variableDayLength = !useUTC || !!getTimezoneOffset, // #4951
                localTimezoneOffset = (timeUnits.day +
                        (useUTC ? getTZOffset(minDate) : minDate.getTimezoneOffset() * 60 * 1000)
                    ) % timeUnits.day; // #950, #3359

            // iterate and add tick positions at appropriate values
            while (time < max) {
                tickPositions.push(time);

                // if the interval is years, use Date.UTC to increase years
                if (interval === timeUnits.year) {
                    time = makeTime(minYear + i * count, 0);

                // if the interval is months, use Date.UTC to increase months
                } else if (interval === timeUnits.month) {
                    time = makeTime(minYear, minMonth + i * count);

                // if we're using global time, the interval is not fixed as it jumps
                // one hour at the DST crossover
                } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {
                    time = makeTime(minYear, minMonth, minDateDate +
                        i * count * (interval === timeUnits.day ? 1 : 7));

                // else, the interval is fixed and we use simple addition
                } else {
                    time += interval * count;
                }

                i++;
            }

            // push the last time
            tickPositions.push(time);


            // mark new days if the time is dividible by day (#1649, #1760)
            each(grep(tickPositions, function (time) {
                return interval <= timeUnits.hour && time % timeUnits.day === localTimezoneOffset;
            }), function (time) {
                higherRanks[time] = 'day';
            });
        }


        // record information on the chosen unit - for dynamic label formatter
        tickPositions.info = extend(normalizedInterval, {
            higherRanks: higherRanks,
            totalRange: interval * count
        });

        return tickPositions;
    };

    /**
     * Get a normalized tick interval for dates. Returns a configuration object with
     * unit range (interval), count and name. Used to prepare data for getTimeTicks.
     * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs
     * of segments in stock charts, the normalizing logic was extracted in order to
     * prevent it for running over again for each segment having the same interval.
     * #662, #697.
     */
    Axis.prototype.normalizeTimeTickInterval = function (tickInterval, unitsOption) {
        var units = unitsOption || [[
                'millisecond', // unit name
                [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
            ], [
                'second',
                [1, 2, 5, 10, 15, 30]
            ], [
                'minute',
                [1, 2, 5, 10, 15, 30]
            ], [
                'hour',
                [1, 2, 3, 4, 6, 8, 12]
            ], [
                'day',
                [1, 2]
            ], [
                'week',
                [1, 2]
            ], [
                'month',
                [1, 2, 3, 4, 6]
            ], [
                'year',
                null
            ]],
            unit = units[units.length - 1], // default unit is years
            interval = timeUnits[unit[0]],
            multiples = unit[1],
            count,
            i;

        // loop through the units to find the one that best fits the tickInterval
        for (i = 0; i < units.length; i++) {
            unit = units[i];
            interval = timeUnits[unit[0]];
            multiples = unit[1];


            if (units[i + 1]) {
                // lessThan is in the middle between the highest multiple and the next unit.
                var lessThan = (interval * multiples[multiples.length - 1] +
                            timeUnits[units[i + 1][0]]) / 2;

                // break and keep the current unit
                if (tickInterval <= lessThan) {
                    break;
                }
            }
        }

        // prevent 2.5 years intervals, though 25, 250 etc. are allowed
        if (interval === timeUnits.year && tickInterval < 5 * interval) {
            multiples = [1, 2, 5];
        }

        // get the count
        count = normalizeTickInterval(
            tickInterval / interval,
            multiples,
            unit[0] === 'year' ? mathMax(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360
        );

        return {
            unitRange: interval,
            count: count,
            unitName: unit[0]
        };
    };
    /**
     * Methods defined on the Axis prototype
     */

    /**
     * Set the tick positions of a logarithmic axis
     */
    Axis.prototype.getLogTickPositions = function (interval, min, max, minor) {
        var axis = this,
            options = axis.options,
            axisLength = axis.len,
            lin2log = axis.lin2log,
            log2lin = axis.log2lin,
            // Since we use this method for both major and minor ticks,
            // use a local variable and return the result
            positions = [];

        // Reset
        if (!minor) {
            axis._minorAutoInterval = null;
        }

        // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.
        if (interval >= 0.5) {
            interval = mathRound(interval);
            positions = axis.getLinearTickPositions(interval, min, max);

        // Second case: We need intermediary ticks. For example
        // 1, 2, 4, 6, 8, 10, 20, 40 etc.
        } else if (interval >= 0.08) {
            var roundedMin = mathFloor(min),
                intermediate,
                i,
                j,
                len,
                pos,
                lastPos,
                break2;

            if (interval > 0.3) {
                intermediate = [1, 2, 4];
            } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc
                intermediate = [1, 2, 4, 6, 8];
            } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc
                intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            }

            for (i = roundedMin; i < max + 1 && !break2; i++) {
                len = intermediate.length;
                for (j = 0; j < len && !break2; j++) {
                    pos = log2lin(lin2log(i) * intermediate[j]);
                    if (pos > min && (!minor || lastPos <= max) && lastPos !== UNDEFINED) { // #1670, lastPos is #3113
                        positions.push(lastPos);
                    }

                    if (lastPos > max) {
                        break2 = true;
                    }
                    lastPos = pos;
                }
            }

        // Third case: We are so deep in between whole logarithmic values that
        // we might as well handle the tick positions like a linear axis. For
        // example 1.01, 1.02, 1.03, 1.04.
        } else {
            var realMin = lin2log(min),
                realMax = lin2log(max),
                tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],
                filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,
                tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),
                totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;

            interval = pick(
                filteredTickIntervalOption,
                axis._minorAutoInterval,
                (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)
            );

            interval = normalizeTickInterval(
                interval,
                null,
                getMagnitude(interval)
            );

            positions = map(axis.getLinearTickPositions(
                interval,
                realMin,
                realMax
            ), log2lin);

            if (!minor) {
                axis._minorAutoInterval = interval / 5;
            }
        }

        // Set the axis-level tickInterval variable
        if (!minor) {
            axis.tickInterval = interval;
        }
        return positions;
    };

    Axis.prototype.log2lin = function (num) {
        return math.log(num) / math.LN10;
    };

    Axis.prototype.lin2log = function (num) {
        return math.pow(10, num);
    };
    /**
     * The tooltip object
     * @param {Object} chart The chart instance
     * @param {Object} options Tooltip options
     */
    var Tooltip = Highcharts.Tooltip = function () {
        this.init.apply(this, arguments);
    };

    Tooltip.prototype = {

        init: function (chart, options) {

            var borderWidth = options.borderWidth,
                style = options.style,
                padding = pInt(style.padding);

            // Save the chart and options
            this.chart = chart;
            this.options = options;

            // Keep track of the current series
            //this.currentSeries = UNDEFINED;

            // List of crosshairs
            this.crosshairs = [];

            // Current values of x and y when animating
            this.now = { x: 0, y: 0 };

            // The tooltip is initially hidden
            this.isHidden = true;


            // create the label
            this.label = chart.renderer.label('', 0, 0, options.shape || 'callout', null, null, options.useHTML, null, 'tooltip')
                .attr({
                    padding: padding,
                    fill: options.backgroundColor,
                    'stroke-width': borderWidth,
                    r: options.borderRadius,
                    zIndex: 8
                })
                .css(style)
                .css({ padding: 0 }) // Remove it from VML, the padding is applied as an attribute instead (#1117)
                .add()
                .attr({ y: -9e9 }); // #2301, #2657, #3532

            // When using canVG the shadow shows up as a gray circle
            // even if the tooltip is hidden.
            if (!useCanVG) {
                this.label.shadow(options.shadow);
            }

            // Public property for getting the shared state.
            this.shared = options.shared;
        },

        /**
         * Destroy the tooltip and its elements.
         */
        destroy: function () {
            // Destroy and clear local variables
            if (this.label) {
                this.label = this.label.destroy();
            }
            clearTimeout(this.hideTimer);
            clearTimeout(this.tooltipTimeout);
        },

        /**
         * Provide a soft movement for the tooltip
         *
         * @param {Number} x
         * @param {Number} y
         * @private
         */
        move: function (x, y, anchorX, anchorY) {
            var tooltip = this,
                now = tooltip.now,
                animate = tooltip.options.animation !== false && !tooltip.isHidden &&
                    // When we get close to the target position, abort animation and land on the right place (#3056)
                    (mathAbs(x - now.x) > 1 || mathAbs(y - now.y) > 1),
                skipAnchor = tooltip.followPointer || tooltip.len > 1;

            // Get intermediate values for animation
            extend(now, {
                x: animate ? (2 * now.x + x) / 3 : x,
                y: animate ? (now.y + y) / 2 : y,
                anchorX: skipAnchor ? UNDEFINED : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,
                anchorY: skipAnchor ? UNDEFINED : animate ? (now.anchorY + anchorY) / 2 : anchorY
            });

            // Move to the intermediate value
            tooltip.label.attr(now);


            // Run on next tick of the mouse tracker
            if (animate) {

                // Never allow two timeouts
                clearTimeout(this.tooltipTimeout);

                // Set the fixed interval ticking for the smooth tooltip
                this.tooltipTimeout = setTimeout(function () {
                    // The interval function may still be running during destroy, so check that the chart is really there before calling.
                    if (tooltip) {
                        tooltip.move(x, y, anchorX, anchorY);
                    }
                }, 32);

            }
        },

        /**
         * Hide the tooltip
         */
        hide: function (delay) {
            var tooltip = this;
            clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)
            delay = pick(delay, this.options.hideDelay, 500);
            if (!this.isHidden) {
                this.hideTimer = syncTimeout(function () {
                    tooltip.label[delay ? 'fadeOut' : 'hide']();
                    tooltip.isHidden = true;
                }, delay);
            }
        },

        /**
         * Extendable method to get the anchor position of the tooltip
         * from a point or set of points
         */
        getAnchor: function (points, mouseEvent) {
            var ret,
                chart = this.chart,
                inverted = chart.inverted,
                plotTop = chart.plotTop,
                plotLeft = chart.plotLeft,
                plotX = 0,
                plotY = 0,
                yAxis,
                xAxis;

            points = splat(points);

            // Pie uses a special tooltipPos
            ret = points[0].tooltipPos;

            // When tooltip follows mouse, relate the position to the mouse
            if (this.followPointer && mouseEvent) {
                if (mouseEvent.chartX === UNDEFINED) {
                    mouseEvent = chart.pointer.normalize(mouseEvent);
                }
                ret = [
                    mouseEvent.chartX - chart.plotLeft,
                    mouseEvent.chartY - plotTop
                ];
            }
            // When shared, use the average position
            if (!ret) {
                each(points, function (point) {
                    yAxis = point.series.yAxis;
                    xAxis = point.series.xAxis;
                    plotX += point.plotX  + (!inverted && xAxis ? xAxis.left - plotLeft : 0);
                    plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +
                        (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151
                });

                plotX /= points.length;
                plotY /= points.length;

                ret = [
                    inverted ? chart.plotWidth - plotY : plotX,
                    this.shared && !inverted && points.length > 1 && mouseEvent ?
                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)
                        inverted ? chart.plotHeight - plotX : plotY
                ];
            }

            return map(ret, mathRound);
        },

        /**
         * Place the tooltip in a chart without spilling over
         * and not covering the point it self.
         */
        getPosition: function (boxWidth, boxHeight, point) {

            var chart = this.chart,
                distance = this.distance,
                ret = {},
                h = point.h || 0, // #4117
                swapped,
                first = ['y', chart.chartHeight, boxHeight, point.plotY + chart.plotTop, chart.plotTop, chart.plotTop + chart.plotHeight],
                second = ['x', chart.chartWidth, boxWidth, point.plotX + chart.plotLeft, chart.plotLeft, chart.plotLeft + chart.plotWidth],
                // The far side is right or bottom
                preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984
                /**
                 * Handle the preferred dimension. When the preferred dimension is tooltip
                 * on top or bottom of the point, it will look for space there.
                 */
                firstDimension = function (dim, outerSize, innerSize, point, min, max) {
                    var roomLeft = innerSize < point - distance,
                        roomRight = point + distance + innerSize < outerSize,
                        alignedLeft = point - distance - innerSize,
                        alignedRight = point + distance;

                    if (preferFarSide && roomRight) {
                        ret[dim] = alignedRight;
                    } else if (!preferFarSide && roomLeft) {
                        ret[dim] = alignedLeft;
                    } else if (roomLeft) {
                        ret[dim] = mathMin(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);
                    } else if (roomRight) {
                        ret[dim] = mathMax(min, alignedRight + h + innerSize > outerSize ? alignedRight : alignedRight + h);
                    } else {
                        return false;
                    }
                },
                /**
                 * Handle the secondary dimension. If the preferred dimension is tooltip
                 * on top or bottom of the point, the second dimension is to align the tooltip
                 * above the point, trying to align center but allowing left or right
                 * align within the chart box.
                 */
                secondDimension = function (dim, outerSize, innerSize, point) {
                    var retVal;

                    // Too close to the edge, return false and swap dimensions
                    if (point < distance || point > outerSize - distance) {
                        retVal = false;
                    // Align left/top
                    } else if (point < innerSize / 2) {
                        ret[dim] = 1;
                    // Align right/bottom
                    } else if (point > outerSize - innerSize / 2) {
                        ret[dim] = outerSize - innerSize - 2;
                    // Align center
                    } else {
                        ret[dim] = point - innerSize / 2;
                    }
                    return retVal;
                },
                /**
                 * Swap the dimensions
                 */
                swap = function (count) {
                    var temp = first;
                    first = second;
                    second = temp;
                    swapped = count;
                },
                run = function () {
                    if (firstDimension.apply(0, first) !== false) {
                        if (secondDimension.apply(0, second) === false && !swapped) {
                            swap(true);
                            run();
                        }
                    } else if (!swapped) {
                        swap(true);
                        run();
                    } else {
                        ret.x = ret.y = 0;
                    }
                };

            // Under these conditions, prefer the tooltip on the side of the point
            if (chart.inverted || this.len > 1) {
                swap();
            }
            run();

            return ret;

        },

        /**
         * In case no user defined formatter is given, this will be used. Note that the context
         * here is an object holding point, series, x, y etc.
         */
        defaultFormatter: function (tooltip) {
            var items = this.points || splat(this),
                s;

            // build the header
            s = [tooltip.tooltipFooterHeaderFormatter(items[0])]; //#3397: abstraction to enable formatting of footer and header

            // build the values
            s = s.concat(tooltip.bodyFormatter(items));

            // footer
            s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true)); //#3397: abstraction to enable formatting of footer and header

            return s.join('');
        },

        /**
         * Refresh the tooltip's text and position.
         * @param {Object} point
         */
        refresh: function (point, mouseEvent) {
            var tooltip = this,
                chart = tooltip.chart,
                label = tooltip.label,
                options = tooltip.options,
                x,
                y,
                anchor,
                textConfig = {},
                text,
                pointConfig = [],
                formatter = options.formatter || tooltip.defaultFormatter,
                hoverPoints = chart.hoverPoints,
                borderColor,
                shared = tooltip.shared,
                currentSeries;

            clearTimeout(this.hideTimer);

            // get the reference point coordinates (pie charts use tooltipPos)
            tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;
            anchor = tooltip.getAnchor(point, mouseEvent);
            x = anchor[0];
            y = anchor[1];

            // shared tooltip, array is sent over
            if (shared && !(point.series && point.series.noSharedTooltip)) {

                // hide previous hoverPoints and set new

                chart.hoverPoints = point;
                if (hoverPoints) {
                    each(hoverPoints, function (point) {
                        point.setState();
                    });
                }

                each(point, function (item) {
                    item.setState(HOVER_STATE);

                    pointConfig.push(item.getLabelConfig());
                });

                textConfig = {
                    x: point[0].category,
                    y: point[0].y
                };
                textConfig.points = pointConfig;
                this.len = pointConfig.length;
                point = point[0];

            // single point tooltip
            } else {
                textConfig = point.getLabelConfig();
            }
            text = formatter.call(textConfig, tooltip);

            // register the current series
            currentSeries = point.series;
            this.distance = pick(currentSeries.tooltipOptions.distance, 16);

            // update the inner HTML
            if (text === false) {
                this.hide();
            } else {

                // show it
                if (tooltip.isHidden) {
                    stop(label);
                    label.attr('opacity', 1).show();
                }

                // update text
                label.attr({
                    text: text
                });

                // set the stroke color of the box
                borderColor = options.borderColor || point.color || currentSeries.color || '#606060';
                label.attr({
                    stroke: borderColor
                });
                tooltip.updatePosition({
                    plotX: x,
                    plotY: y,
                    negative: point.negative,
                    ttBelow: point.ttBelow,
                    h: anchor[2] || 0
                });

                this.isHidden = false;
            }
            fireEvent(chart, 'tooltipRefresh', {
                text: text,
                x: x + chart.plotLeft,
                y: y + chart.plotTop,
                borderColor: borderColor
            });
        },

        /**
         * Find the new position and perform the move
         */
        updatePosition: function (point) {
            var chart = this.chart,
                label = this.label,
                pos = (this.options.positioner || this.getPosition).call(
                    this,
                    label.width,
                    label.height,
                    point
                );

            // do the move
            this.move(
                mathRound(pos.x),
                mathRound(pos.y || 0), // can be undefined (#3977)
                point.plotX + chart.plotLeft,
                point.plotY + chart.plotTop
            );
        },

        /**
         * Get the best X date format based on the closest point range on the axis.
         */
        getXDateFormat: function (point, options, xAxis) {
            var xDateFormat,
                dateTimeLabelFormats = options.dateTimeLabelFormats,
                closestPointRange = xAxis && xAxis.closestPointRange,
                n,
                blank = '01-01 00:00:00.000',
                strpos = {
                    millisecond: 15,
                    second: 12,
                    minute: 9,
                    hour: 6,
                    day: 3
                },
                date,
                lastN = 'millisecond'; // for sub-millisecond data, #4223

            if (closestPointRange) {
                date = dateFormat('%m-%d %H:%M:%S.%L', point.x);
                for (n in timeUnits) {

                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format
                    if (closestPointRange === timeUnits.week && +dateFormat('%w', point.x) === xAxis.options.startOfWeek &&
                            date.substr(6) === blank.substr(6)) {
                        n = 'week';
                        break;
                    }

                    // The first format that is too great for the range
                    if (timeUnits[n] > closestPointRange) {
                        n = lastN;
                        break;
                    }

                    // If the point is placed every day at 23:59, we need to show
                    // the minutes as well. #2637.
                    if (strpos[n] && date.substr(strpos[n]) !== blank.substr(strpos[n])) {
                        break;
                    }

                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition
                    if (n !== 'week') {
                        lastN = n;
                    }
                }

                if (n) {
                    xDateFormat = dateTimeLabelFormats[n];
                }
            } else {
                xDateFormat = dateTimeLabelFormats.day;
            }

            return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581
        },

        /**
         * Format the footer/header of the tooltip
         * #3397: abstraction to enable formatting of footer and header
         */
        tooltipFooterHeaderFormatter: function (labelConfig, isFooter) {
            var footOrHead = isFooter ? 'footer' : 'header',
                series = labelConfig.series,
                tooltipOptions = series.tooltipOptions,
                xDateFormat = tooltipOptions.xDateFormat,
                xAxis = series.xAxis,
                isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),
                formatString = tooltipOptions[footOrHead + 'Format'];

            // Guess the best date format based on the closest point distance (#568, #3418)
            if (isDateTime && !xDateFormat) {
                xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);
            }

            // Insert the footer date format if any
            if (isDateTime && xDateFormat) {
                formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');
            }

            return format(formatString, {
                point: labelConfig,
                series: series
            });
        },

        /**
         * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,
         * abstracting this functionality allows to easily overwrite and extend it.
         */
        bodyFormatter: function (items) {
            return map(items, function (item) {
                var tooltipOptions = item.series.tooltipOptions;
                return (tooltipOptions.pointFormatter || item.point.tooltipFormatter).call(item.point, tooltipOptions.pointFormat);
            });
        }

    };

    var hoverChartIndex;

    // Global flag for touch support
    hasTouch = doc && doc.documentElement.ontouchstart !== UNDEFINED;

    /**
     * The mouse tracker object. All methods starting with "on" are primary DOM event handlers.
     * Subsequent methods should be named differently from what they are doing.
     * @param {Object} chart The Chart instance
     * @param {Object} options The root options object
     */
    var Pointer = Highcharts.Pointer = function (chart, options) {
        this.init(chart, options);
    };

    Pointer.prototype = {
        /**
         * Initialize Pointer
         */
        init: function (chart, options) {

            var chartOptions = options.chart,
                chartEvents = chartOptions.events,
                zoomType = useCanVG ? '' : chartOptions.zoomType,
                inverted = chart.inverted,
                zoomX,
                zoomY;

            // Store references
            this.options = options;
            this.chart = chart;

            // Zoom status
            this.zoomX = zoomX = /x/.test(zoomType);
            this.zoomY = zoomY = /y/.test(zoomType);
            this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);
            this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);
            this.hasZoom = zoomX || zoomY;

            // Do we need to handle click on a touch device?
            this.runChartClick = chartEvents && !!chartEvents.click;

            this.pinchDown = [];
            this.lastValidTouch = {};

            if (Highcharts.Tooltip && options.tooltip.enabled) {
                chart.tooltip = new Tooltip(chart, options.tooltip);
                this.followTouchMove = pick(options.tooltip.followTouchMove, true);
            }

            this.setDOMEvents();
        },

        /**
         * Add crossbrowser support for chartX and chartY
         * @param {Object} e The event object in standard browsers
         */
        normalize: function (e, chartPosition) {
            var chartX,
                chartY,
                ePos;

            // IE normalizing
            e = e || win.event;
            if (!e.target) {
                e.target = e.srcElement;
            }

            // iOS (#2757)
            ePos = e.touches ?  (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;

            // Get mouse position
            if (!chartPosition) {
                this.chartPosition = chartPosition = offset(this.chart.container);
            }

            // chartX and chartY
            if (ePos.pageX === UNDEFINED) { // IE < 9. #886.
                chartX = mathMax(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is
                    // for IE10 quirks mode within framesets
                chartY = e.y;
            } else {
                chartX = ePos.pageX - chartPosition.left;
                chartY = ePos.pageY - chartPosition.top;
            }

            return extend(e, {
                chartX: mathRound(chartX),
                chartY: mathRound(chartY)
            });
        },

        /**
         * Get the click position in terms of axis values.
         *
         * @param {Object} e A pointer event
         */
        getCoordinates: function (e) {
            var coordinates = {
                xAxis: [],
                yAxis: []
            };

            each(this.chart.axes, function (axis) {
                coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({
                    axis: axis,
                    value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])
                });
            });
            return coordinates;
        },

        /**
         * With line type charts with a single tracker, get the point closest to the mouse.
         * Run Point.onMouseOver and display tooltip for the point or points.
         */
        runPointActions: function (e) {

            var pointer = this,
                chart = pointer.chart,
                series = chart.series,
                tooltip = chart.tooltip,
                shared = tooltip ? tooltip.shared : false,
                followPointer,
                hoverPoint = chart.hoverPoint,
                hoverSeries = chart.hoverSeries,
                i,
                distance = [Number.MAX_VALUE, Number.MAX_VALUE], // #4511
                anchor,
                noSharedTooltip,
                stickToHoverSeries,
                directTouch,
                kdpoints = [],
                kdpoint = [],
                kdpointT;

            // For hovering over the empty parts of the plot area (hoverSeries is undefined).
            // If there is one series with point tracking (combo chart), don't go to nearest neighbour.
            if (!shared && !hoverSeries) {
                for (i = 0; i < series.length; i++) {
                    if (series[i].directTouch || !series[i].options.stickyTracking) {
                        series = [];
                    }
                }
            }

            // If it has a hoverPoint and that series requires direct touch (like columns, #3899), or we're on
            // a noSharedTooltip series among shared tooltip series (#4546), use the hoverPoint . Otherwise,
            // search the k-d tree.
            stickToHoverSeries = hoverSeries && (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);
            if (stickToHoverSeries && hoverPoint) {
                kdpoint = [hoverPoint];

            // Handle shared tooltip or cases where a series is not yet hovered
            } else {
                // Find nearest points on all series
                each(series, function (s) {
                    // Skip hidden series
                    noSharedTooltip = s.noSharedTooltip && shared;
                    directTouch = !shared && s.directTouch;
                    if (s.visible && !noSharedTooltip && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821
                        kdpointT = s.searchPoint(e, !noSharedTooltip && s.kdDimensions === 1); // #3828
                        if (kdpointT && kdpointT.series) { // Point.series becomes null when reset and before redraw (#5197)
                            kdpoints.push(kdpointT);
                        }
                    }
                });
                // Find absolute nearest point
                each(kdpoints, function (p) {
                    if (p) {
                        // Store both closest points, using point.dist and point.distX comparisons (#4645):
                        each(['dist', 'distX'], function (dist, k) {
                            if (isNumber(p[dist])) {
                                var
                                    // It is closer than the reference point
                                    isCloser = p[dist] < distance[k],
                                    // It is equally close, but above the reference point (#4679)
                                    isAbove = p[dist] === distance[k] && p.series.group.zIndex >= kdpoint[k].series.group.zIndex;

                                if (isCloser || isAbove) {
                                    distance[k] = p[dist];
                                    kdpoint[k] = p;
                                }
                            }
                        });
                    }
                });
            }

            // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):
            if (shared) {
                i = kdpoints.length;
                while (i--) {
                    if (kdpoints[i].clientX !== kdpoint[1].clientX || kdpoints[i].series.noSharedTooltip) {
                        kdpoints.splice(i, 1);
                    }
                }
            }

            // Refresh tooltip for kdpoint if new hover point or tooltip was hidden // #3926, #4200
            if (kdpoint[0] && (kdpoint[0] !== this.prevKDPoint || (tooltip && tooltip.isHidden))) {
                // Draw tooltip if necessary
                if (shared && !kdpoint[0].series.noSharedTooltip) {
                    if (kdpoints.length && tooltip) {
                        tooltip.refresh(kdpoints, e);
                    }

                    // Do mouseover on all points (#3919, #3985, #4410)
                    each(kdpoints, function (point) {
                        point.onMouseOver(e, point !== ((hoverSeries && hoverSeries.directTouch && hoverPoint) || kdpoint[0]));
                    });
                    this.prevKDPoint = kdpoint[1];
                } else {
                    if (tooltip) {
                        tooltip.refresh(kdpoint[0], e);
                    }
                    if (!hoverSeries || !hoverSeries.directTouch) { // #4448
                        kdpoint[0].onMouseOver(e);
                    }
                    this.prevKDPoint = kdpoint[0];
                }

            // Update positions (regardless of kdpoint or hoverPoint)
            } else {
                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;
                if (tooltip && followPointer && !tooltip.isHidden) {
                    anchor = tooltip.getAnchor([{}], e);
                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
                }
            }

            // Start the event listener to pick up the tooltip and crosshairs
            if (!pointer._onDocumentMouseMove) {
                pointer._onDocumentMouseMove = function (e) {
                    if (charts[hoverChartIndex]) {
                        charts[hoverChartIndex].pointer.onDocumentMouseMove(e);
                    }
                };
                addEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
            }

            // Crosshair. For each hover point, loop over axes and draw cross if that point
            // belongs to the axis (#4927).
            each(shared ? kdpoints : [pick(hoverPoint, kdpoint[1])], function (point) { // #5269
                each(chart.axes, function (axis) {
                    // In case of snap = false, point is undefined, and we draw the crosshair anyway (#5066)
                    if (!point || point.series[axis.coll] === axis) {
                        axis.drawCrosshair(e, point);
                    }
                });
            });
        },

        /**
         * Reset the tracking by hiding the tooltip, the hover series state and the hover point
         *
         * @param allowMove {Boolean} Instead of destroying the tooltip altogether, allow moving it if possible
         */
        reset: function (allowMove, delay) {
            var pointer = this,
                chart = pointer.chart,
                hoverSeries = chart.hoverSeries,
                hoverPoint = chart.hoverPoint,
                hoverPoints = chart.hoverPoints,
                tooltip = chart.tooltip,
                tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;

            // Check if the points have moved outside the plot area (#1003, #4736, #5101)
            if (allowMove && tooltipPoints) {
                each(splat(tooltipPoints), function (point) {
                    if (point.series.isCartesian && point.plotX === undefined) {
                        allowMove = false;
                    }
                });
            }
        
            // Just move the tooltip, #349
            if (allowMove) {
                if (tooltip && tooltipPoints) {
                    tooltip.refresh(tooltipPoints);
                    if (hoverPoint) { // #2500
                        hoverPoint.setState(hoverPoint.state, true);
                        each(chart.axes, function (axis) {
                            if (axis.crosshair) {
                                axis.drawCrosshair(null, hoverPoint);
                            }
                        });
                    }
                }

            // Full reset
            } else {

                if (hoverPoint) {
                    hoverPoint.onMouseOut();
                }

                if (hoverPoints) {
                    each(hoverPoints, function (point) {
                        point.setState();
                    });
                }

                if (hoverSeries) {
                    hoverSeries.onMouseOut();
                }

                if (tooltip) {
                    tooltip.hide(delay);
                }

                if (pointer._onDocumentMouseMove) {
                    removeEvent(doc, 'mousemove', pointer._onDocumentMouseMove);
                    pointer._onDocumentMouseMove = null;
                }

                // Remove crosshairs
                each(chart.axes, function (axis) {
                    axis.hideCrosshair();
                });

                pointer.hoverX = pointer.prevKDPoint = chart.hoverPoints = chart.hoverPoint = null;
            }
        },

        /**
         * Scale series groups to a certain scale and translation
         */
        scaleGroups: function (attribs, clip) {

            var chart = this.chart,
                seriesAttribs;

            // Scale each series
            each(chart.series, function (series) {
                seriesAttribs = attribs || series.getPlotBox(); // #1701
                if (series.xAxis && series.xAxis.zoomEnabled) {
                    series.group.attr(seriesAttribs);
                    if (series.markerGroup) {
                        series.markerGroup.attr(seriesAttribs);
                        series.markerGroup.clip(clip ? chart.clipRect : null);
                    }
                    if (series.dataLabelsGroup) {
                        series.dataLabelsGroup.attr(seriesAttribs);
                    }
                }
            });

            // Clip
            chart.clipRect.attr(clip || chart.clipBox);
        },

        /**
         * Start a drag operation
         */
        dragStart: function (e) {
            var chart = this.chart;

            // Record the start position
            chart.mouseIsDown = e.type;
            chart.cancelClick = false;
            chart.mouseDownX = this.mouseDownX = e.chartX;
            chart.mouseDownY = this.mouseDownY = e.chartY;
        },

        /**
         * Perform a drag operation in response to a mousemove event while the mouse is down
         */
        drag: function (e) {

            var chart = this.chart,
                chartOptions = chart.options.chart,
                chartX = e.chartX,
                chartY = e.chartY,
                zoomHor = this.zoomHor,
                zoomVert = this.zoomVert,
                plotLeft = chart.plotLeft,
                plotTop = chart.plotTop,
                plotWidth = chart.plotWidth,
                plotHeight = chart.plotHeight,
                clickedInside,
                size,
                selectionMarker = this.selectionMarker,
                mouseDownX = this.mouseDownX,
                mouseDownY = this.mouseDownY,
                panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];

            // If the device supports both touch and mouse (like IE11), and we are touch-dragging
            // inside the plot area, don't handle the mouse event. #4339.
            if (selectionMarker && selectionMarker.touch) {
                return;
            }

            // If the mouse is outside the plot area, adjust to cooordinates
            // inside to prevent the selection marker from going outside
            if (chartX < plotLeft) {
                chartX = plotLeft;
            } else if (chartX > plotLeft + plotWidth) {
                chartX = plotLeft + plotWidth;
            }

            if (chartY < plotTop) {
                chartY = plotTop;
            } else if (chartY > plotTop + plotHeight) {
                chartY = plotTop + plotHeight;
            }

            // determine if the mouse has moved more than 10px
            this.hasDragged = Math.sqrt(
                Math.pow(mouseDownX - chartX, 2) +
                Math.pow(mouseDownY - chartY, 2)
            );

            if (this.hasDragged > 10) {
                clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);

                // make a selection
                if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
                    if (!selectionMarker) {
                        this.selectionMarker = selectionMarker = chart.renderer.rect(
                            plotLeft,
                            plotTop,
                            zoomHor ? 1 : plotWidth,
                            zoomVert ? 1 : plotHeight,
                            0
                        )
                        .attr({
                            fill: chartOptions.selectionMarkerFill || 'rgba(69,114,167,0.25)',
                            zIndex: 7
                        })
                        .add();
                    }
                }

                // adjust the width of the selection marker
                if (selectionMarker && zoomHor) {
                    size = chartX - mouseDownX;
                    selectionMarker.attr({
                        width: mathAbs(size),
                        x: (size > 0 ? 0 : size) + mouseDownX
                    });
                }
                // adjust the height of the selection marker
                if (selectionMarker && zoomVert) {
                    size = chartY - mouseDownY;
                    selectionMarker.attr({
                        height: mathAbs(size),
                        y: (size > 0 ? 0 : size) + mouseDownY
                    });
                }

                // panning
                if (clickedInside && !selectionMarker && chartOptions.panning) {
                    chart.pan(e, chartOptions.panning);
                }
            }
        },

        /**
         * On mouse up or touch end across the entire document, drop the selection.
         */
        drop: function (e) {
            var pointer = this,
                chart = this.chart,
                hasPinched = this.hasPinched;

            if (this.selectionMarker) {
                var selectionData = {
                        originalEvent: e, // #4890
                        xAxis: [],
                        yAxis: []
                    },
                    selectionBox = this.selectionMarker,
                    selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,
                    selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,
                    selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,
                    selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,
                    runZoom;

                // a selection has been made
                if (this.hasDragged || hasPinched) {

                    // record each axis' min and max
                    each(chart.axes, function (axis) {
                        if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{ xAxis: 'zoomX', yAxis: 'zoomY' }[axis.coll]])) { // #859, #3569
                            var horiz = axis.horiz,
                                minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075
                                selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                                selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);

                            selectionData[axis.coll].push({
                                axis: axis,
                                min: mathMin(selectionMin, selectionMax), // for reversed axes
                                max: mathMax(selectionMin, selectionMax)
                            });
                            runZoom = true;
                        }
                    });
                    if (runZoom) {
                        fireEvent(chart, 'selection', selectionData, function (args) {
                            chart.zoom(extend(args, hasPinched ? { animation: false } : null));
                        });
                    }

                }
                this.selectionMarker = this.selectionMarker.destroy();

                // Reset scaling preview
                if (hasPinched) {
                    this.scaleGroups();
                }
            }

            // Reset all
            if (chart) { // it may be destroyed on mouse up - #877
                css(chart.container, { cursor: chart._cursor });
                chart.cancelClick = this.hasDragged > 10; // #370
                chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                this.pinchDown = [];
            }
        },

        onContainerMouseDown: function (e) {

            e = this.normalize(e);

            // issue #295, dragging not always working in Firefox
            if (e.preventDefault) {
                e.preventDefault();
            }

            this.dragStart(e);
        },



        onDocumentMouseUp: function (e) {
            if (charts[hoverChartIndex]) {
                charts[hoverChartIndex].pointer.drop(e);
            }
        },

        /**
         * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.
         * Issue #149 workaround. The mouseleave event does not always fire.
         */
        onDocumentMouseMove: function (e) {
            var chart = this.chart,
                chartPosition = this.chartPosition;

            e = this.normalize(e, chartPosition);

            // If we're outside, hide the tooltip
            if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&
                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                this.reset();
            }
        },

        /**
         * When mouse leaves the container, hide the tooltip.
         */
        onContainerMouseLeave: function (e) {
            var chart = charts[hoverChartIndex];
            if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target
                chart.pointer.reset();
                chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix
            }
        },

        // The mousemove, touchmove and touchstart event handler
        onContainerMouseMove: function (e) {

            var chart = this.chart;

            if (!defined(hoverChartIndex) || !charts[hoverChartIndex] || !charts[hoverChartIndex].mouseIsDown) {
                hoverChartIndex = chart.index;
            }

            e = this.normalize(e);
            e.returnValue = false; // #2251, #3224

            if (chart.mouseIsDown === 'mousedown') {
                this.drag(e);
            }

            // Show the tooltip and run mouse over events (#977)
            if ((this.inClass(e.target, 'highcharts-tracker') ||
                    chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {
                this.runPointActions(e);
            }
        },

        /**
         * Utility to detect whether an element has, or has a parent with, a specific
         * class name. Used on detection of tracker objects and on deciding whether
         * hovering the tooltip should cause the active series to mouse out.
         */
        inClass: function (element, className) {
            var elemClassName;
            while (element) {
                elemClassName = attr(element, 'class');
                if (elemClassName) {
                    if (elemClassName.indexOf(className) !== -1) {
                        return true;
                    }
                    if (elemClassName.indexOf(PREFIX + 'container') !== -1) {
                        return false;
                    }
                }
                element = element.parentNode;
            }
        },

        onTrackerMouseOut: function (e) {
            var series = this.chart.hoverSeries,
                relatedTarget = e.relatedTarget || e.toElement;

            if (series && relatedTarget && !series.options.stickyTracking && // #4886
                    !this.inClass(relatedTarget, PREFIX + 'tooltip') &&
                    !this.inClass(relatedTarget, PREFIX + 'series-' + series.index)) { // #2499, #4465
                series.onMouseOut();
            }
        },

        onContainerClick: function (e) {
            var chart = this.chart,
                hoverPoint = chart.hoverPoint,
                plotLeft = chart.plotLeft,
                plotTop = chart.plotTop;

            e = this.normalize(e);

            if (!chart.cancelClick) {

                // On tracker click, fire the series and point events. #783, #1583
                if (hoverPoint && this.inClass(e.target, PREFIX + 'tracker')) {

                    // the series click event
                    fireEvent(hoverPoint.series, 'click', extend(e, {
                        point: hoverPoint
                    }));

                    // the point click event
                    if (chart.hoverPoint) { // it may be destroyed (#1844)
                        hoverPoint.firePointEvent('click', e);
                    }

                // When clicking outside a tracker, fire a chart event
                } else {
                    extend(e, this.getCoordinates(e));

                    // fire a click event in the chart
                    if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                        fireEvent(chart, 'click', e);
                    }
                }


            }
        },

        /**
         * Set the JS DOM events on the container and document. This method should contain
         * a one-to-one assignment between methods and their handlers. Any advanced logic should
         * be moved to the handler reflecting the event's name.
         */
        setDOMEvents: function () {

            var pointer = this,
                container = pointer.chart.container;

            container.onmousedown = function (e) {
                pointer.onContainerMouseDown(e);
            };
            container.onmousemove = function (e) {
                pointer.onContainerMouseMove(e);
            };
            container.onclick = function (e) {
                pointer.onContainerClick(e);
            };
            addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);
            if (chartCount === 1) {
                addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);
            }
            if (hasTouch) {
                container.ontouchstart = function (e) {
                    pointer.onContainerTouchStart(e);
                };
                container.ontouchmove = function (e) {
                    pointer.onContainerTouchMove(e);
                };
                if (chartCount === 1) {
                    addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);
                }
            }

        },

        /**
         * Destroys the Pointer object and disconnects DOM events.
         */
        destroy: function () {
            var prop;

            removeEvent(this.chart.container, 'mouseleave', this.onContainerMouseLeave);
            if (!chartCount) {
                removeEvent(doc, 'mouseup', this.onDocumentMouseUp);
                removeEvent(doc, 'touchend', this.onDocumentTouchEnd);
            }

            // memory and CPU leak
            clearInterval(this.tooltipTimeout);

            for (prop in this) {
                this[prop] = null;
            }
        }
    };


    /* Support for touch devices */
    extend(Highcharts.Pointer.prototype, {

        /**
         * Run translation operations
         */
        pinchTranslate: function (pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
            if (this.zoomHor || this.pinchHor) {
                this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
            }
            if (this.zoomVert || this.pinchVert) {
                this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
            }
        },

        /**
         * Run translation operations for each direction (horizontal and vertical) independently
         */
        pinchTranslateDirection: function (horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
            var chart = this.chart,
                xy = horiz ? 'x' : 'y',
                XY = horiz ? 'X' : 'Y',
                sChartXY = 'chart' + XY,
                wh = horiz ? 'width' : 'height',
                plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],
                selectionWH,
                selectionXY,
                clipXY,
                scale = forcedScale || 1,
                inverted = chart.inverted,
                bounds = chart.bounds[horiz ? 'h' : 'v'],
                singleTouch = pinchDown.length === 1,
                touch0Start = pinchDown[0][sChartXY],
                touch0Now = touches[0][sChartXY],
                touch1Start = !singleTouch && pinchDown[1][sChartXY],
                touch1Now = !singleTouch && touches[1][sChartXY],
                outOfBounds,
                transformScale,
                scaleKey,
                setScale = function () {
                    if (!singleTouch && mathAbs(touch0Start - touch1Start) > 20) { // Don't zoom if fingers are too close on this axis
                        scale = forcedScale || mathAbs(touch0Now - touch1Now) / mathAbs(touch0Start - touch1Start);
                    }

                    clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                    selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;
                };

            // Set the scale, first pass
            setScale();

            selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not

            // Out of bounds
            if (selectionXY < bounds.min) {
                selectionXY = bounds.min;
                outOfBounds = true;
            } else if (selectionXY + selectionWH > bounds.max) {
                selectionXY = bounds.max - selectionWH;
                outOfBounds = true;
            }

            // Is the chart dragged off its bounds, determined by dataMin and dataMax?
            if (outOfBounds) {

                // Modify the touchNow position in order to create an elastic drag movement. This indicates
                // to the user that the chart is responsive but can't be dragged further.
                touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
                if (!singleTouch) {
                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
                }

                // Set the scale, second pass to adapt to the modified touchNow positions
                setScale();

            } else {
                lastValidTouch[xy] = [touch0Now, touch1Now];
            }

            // Set geometry for clipping, selection and transformation
            if (!inverted) {
                clip[xy] = clipXY - plotLeftTop;
                clip[wh] = selectionWH;
            }
            scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;
            transformScale = inverted ? 1 / scale : scale;

            selectionMarker[wh] = selectionWH;
            selectionMarker[xy] = selectionXY;
            transform[scaleKey] = scale;
            transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
        },

        /**
         * Handle touch events with two touches
         */
        pinch: function (e) {

            var self = this,
                chart = self.chart,
                pinchDown = self.pinchDown,
                touches = e.touches,
                touchesLength = touches.length,
                lastValidTouch = self.lastValidTouch,
                hasZoom = self.hasZoom,
                selectionMarker = self.selectionMarker,
                transform = {},
                fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, PREFIX + 'tracker') &&
                    chart.runTrackerClick) || self.runChartClick),
                clip = {};

            // Don't initiate panning until the user has pinched. This prevents us from
            // blocking page scrolling as users scroll down a long page (#4210).
            if (touchesLength > 1) {
                self.initiated = true;
            }

            // On touch devices, only proceed to trigger click if a handler is defined
            if (hasZoom && self.initiated && !fireClickEvent) {
                e.preventDefault();
            }

            // Normalize each touch
            map(touches, function (e) {
                return self.normalize(e);
            });

            // Register the touch start position
            if (e.type === 'touchstart') {
                each(touches, function (e, i) {
                    pinchDown[i] = { chartX: e.chartX, chartY: e.chartY };
                });
                lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
                lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];

                // Identify the data bounds in pixels
                each(chart.axes, function (axis) {
                    if (axis.zoomEnabled) {
                        var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],
                            minPixelPadding = axis.minPixelPadding,
                            min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
                            max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
                            absMin = mathMin(min, max),
                            absMax = mathMax(min, max);

                        // Store the bounds for use in the touchmove handler
                        bounds.min = mathMin(axis.pos, absMin - minPixelPadding);
                        bounds.max = mathMax(axis.pos + axis.len, absMax + minPixelPadding);
                    }
                });
                self.res = true; // reset on next move

            // Event type is touchmove, handle panning and pinching
            } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first


                // Set the marker
                if (!selectionMarker) {
                    self.selectionMarker = selectionMarker = extend({
                        destroy: noop,
                        touch: true
                    }, chart.plotBox);
                }

                self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);

                self.hasPinched = hasZoom;

                // Scale and translate the groups to provide visual feedback during pinching
                self.scaleGroups(transform, clip);

                // Optionally move the tooltip on touchmove
                if (!hasZoom && self.followTouchMove && touchesLength === 1) {
                    this.runPointActions(self.normalize(e));
                } else if (self.res) {
                    self.res = false;
                    this.reset(false, 0);
                }
            }
        },

        /**
         * General touch handler shared by touchstart and touchmove.
         */
        touch: function (e, start) {
            var chart = this.chart,
                hasMoved,
                pinchDown;

            hoverChartIndex = chart.index;

            if (e.touches.length === 1) {

                e = this.normalize(e);

                if (chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop) && !chart.openMenu) {

                    // Run mouse events and display tooltip etc
                    if (start) {
                        this.runPointActions(e);
                    }

                    // Android fires touchmove events after the touchstart even if the
                    // finger hasn't moved, or moved only a pixel or two. In iOS however,
                    // the touchmove doesn't fire unless the finger moves more than ~4px.
                    // So we emulate this behaviour in Android by checking how much it
                    // moved, and cancelling on small distances. #3450.
                    if (e.type === 'touchmove') {
                        pinchDown = this.pinchDown;
                        hasMoved = pinchDown[0] ? Math.sqrt( // #5266
                            Math.pow(pinchDown[0].chartX - e.chartX, 2) +
                            Math.pow(pinchDown[0].chartY - e.chartY, 2)
                        ) >= 4 : false;
                    }

                    if (pick(hasMoved, true)) {
                        this.pinch(e);
                    }

                } else if (start) {
                    // Hide the tooltip on touching outside the plot area (#1203)
                    this.reset();
                }

            } else if (e.touches.length === 2) {
                this.pinch(e);
            }
        },

        onContainerTouchStart: function (e) {
            this.touch(e, true);
        },

        onContainerTouchMove: function (e) {
            this.touch(e);
        },

        onDocumentTouchEnd: function (e) {
            if (charts[hoverChartIndex]) {
                charts[hoverChartIndex].pointer.drop(e);
            }
        }

    });
    if (win.PointerEvent || win.MSPointerEvent) {

        // The touches object keeps track of the points being touched at all times
        var touches = {},
            hasPointerEvent = !!win.PointerEvent,
            getWebkitTouches = function () {
                var key,
                    fake = [];
                fake.item = function (i) {
                    return this[i];
                };
                for (key in touches) {
                    if (touches.hasOwnProperty(key)) {
                        fake.push({
                            pageX: touches[key].pageX,
                            pageY: touches[key].pageY,
                            target: touches[key].target
                        });
                    }
                }
                return fake;
            },
            translateMSPointer = function (e, method, wktype, func) {
                var p;
                if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[hoverChartIndex]) {
                    func(e);
                    p = charts[hoverChartIndex].pointer;
                    p[method]({
                        type: wktype,
                        target: e.currentTarget,
                        preventDefault: noop,
                        touches: getWebkitTouches()
                    });
                }
            };

        /**
         * Extend the Pointer prototype with methods for each event handler and more
         */
        extend(Pointer.prototype, {
            onContainerPointerDown: function (e) {
                translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function (e) {
                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget };
                });
            },
            onContainerPointerMove: function (e) {
                translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function (e) {
                    touches[e.pointerId] = { pageX: e.pageX, pageY: e.pageY };
                    if (!touches[e.pointerId].target) {
                        touches[e.pointerId].target = e.currentTarget;
                    }
                });
            },
            onDocumentPointerUp: function (e) {
                translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function (e) {
                    delete touches[e.pointerId];
                });
            },

            /**
             * Add or remove the MS Pointer specific events
             */
            batchMSEvents: function (fn) {
                fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);
                fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);
                fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);
            }
        });

        // Disable default IE actions for pinch and such on chart element
        wrap(Pointer.prototype, 'init', function (proceed, chart, options) {
            proceed.call(this, chart, options);
            if (this.hasZoom) { // #4014
                css(chart.container, {
                    '-ms-touch-action': NONE,
                    'touch-action': NONE
                });
            }
        });

        // Add IE specific touch events to chart
        wrap(Pointer.prototype, 'setDOMEvents', function (proceed) {
            proceed.apply(this);
            if (this.hasZoom || this.followTouchMove) {
                this.batchMSEvents(addEvent);
            }
        });
        // Destroy MS events also
        wrap(Pointer.prototype, 'destroy', function (proceed) {
            this.batchMSEvents(removeEvent);
            proceed.call(this);
        });
    }
    /**
     * The overview of the chart's series
     */
    var Legend = Highcharts.Legend = function (chart, options) {
        this.init(chart, options);
    };

    Legend.prototype = {

        /**
         * Initialize the legend
         */
        init: function (chart, options) {

            var legend = this,
                itemStyle = options.itemStyle,
                padding,
                itemMarginTop = options.itemMarginTop || 0;

            this.options = options;

            if (!options.enabled) {
                return;
            }

            legend.itemStyle = itemStyle;
            legend.itemHiddenStyle = merge(itemStyle, options.itemHiddenStyle);
            legend.itemMarginTop = itemMarginTop;
            legend.padding = padding = pick(options.padding, 8);
            legend.initialItemX = padding;
            legend.initialItemY = padding - 5; // 5 is the number of pixels above the text
            legend.maxItemWidth = 0;
            legend.chart = chart;
            legend.itemHeight = 0;
            legend.symbolWidth = pick(options.symbolWidth, 16);
            legend.pages = [];


            // Render it
            legend.render();

            // move checkboxes
            addEvent(legend.chart, 'endResize', function () {
                legend.positionCheckboxes();
            });

        },

        /**
         * Set the colors for the legend item
         * @param {Object} item A Series or Point instance
         * @param {Object} visible Dimmed or colored
         */
        colorizeItem: function (item, visible) {
            var legend = this,
                options = legend.options,
                legendItem = item.legendItem,
                legendLine = item.legendLine,
                legendSymbol = item.legendSymbol,
                hiddenColor = legend.itemHiddenStyle.color,
                textColor = visible ? options.itemStyle.color : hiddenColor,
                symbolColor = visible ? (item.legendColor || item.color || '#CCC') : hiddenColor,
                markerOptions = item.options && item.options.marker,
                symbolAttr = { fill: symbolColor },
                key,
                val;

            if (legendItem) {
                legendItem.css({ fill: textColor, color: textColor }); // color for #1553, oldIE
            }
            if (legendLine) {
                legendLine.attr({ stroke: symbolColor });
            }

            if (legendSymbol) {

                // Apply marker options
                if (markerOptions && legendSymbol.isMarker) { // #585
                    symbolAttr.stroke = symbolColor;
                    markerOptions = item.convertAttribs(markerOptions);
                    for (key in markerOptions) {
                        val = markerOptions[key];
                        if (val !== UNDEFINED) {
                            symbolAttr[key] = val;
                        }
                    }
                }

                legendSymbol.attr(symbolAttr);
            }
        },

        /**
         * Position the legend item
         * @param {Object} item A Series or Point instance
         */
        positionItem: function (item) {
            var legend = this,
                options = legend.options,
                symbolPadding = options.symbolPadding,
                ltr = !options.rtl,
                legendItemPos = item._legendItemPos,
                itemX = legendItemPos[0],
                itemY = legendItemPos[1],
                checkbox = item.checkbox,
                legendGroup = item.legendGroup;

            if (legendGroup && legendGroup.element) {
                legendGroup.translate(
                    ltr ? itemX : legend.legendWidth - itemX - 2 * symbolPadding - 4,
                    itemY
                );
            }

            if (checkbox) {
                checkbox.x = itemX;
                checkbox.y = itemY;
            }
        },

        /**
         * Destroy a single legend item
         * @param {Object} item The series or point
         */
        destroyItem: function (item) {
            var checkbox = item.checkbox;

            // destroy SVG elements
            each(['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'], function (key) {
                if (item[key]) {
                    item[key] = item[key].destroy();
                }
            });

            if (checkbox) {
                discardElement(item.checkbox);
            }
        },

        /**
         * Destroys the legend.
         */
        destroy: function () {
            var legend = this,
                legendGroup = legend.group,
                box = legend.box;

            if (box) {
                legend.box = box.destroy();
            }

            if (legendGroup) {
                legend.group = legendGroup.destroy();
            }
        },

        /**
         * Position the checkboxes after the width is determined
         */
        positionCheckboxes: function (scrollOffset) {
            var alignAttr = this.group.alignAttr,
                translateY,
                clipHeight = this.clipHeight || this.legendHeight,
                titleHeight = this.titleHeight;

            if (alignAttr) {
                translateY = alignAttr.translateY;
                each(this.allItems, function (item) {
                    var checkbox = item.checkbox,
                        top;

                    if (checkbox) {
                        top = translateY + titleHeight + checkbox.y + (scrollOffset || 0) + 3;
                        css(checkbox, {
                            left: (alignAttr.translateX + item.checkboxOffset + checkbox.x - 20) + PX,
                            top: top + PX,
                            display: top > translateY - 6 && top < translateY + clipHeight - 6 ? '' : NONE
                        });
                    }
                });
            }
        },

        /**
         * Render the legend title on top of the legend
         */
        renderTitle: function () {
            var options = this.options,
                padding = this.padding,
                titleOptions = options.title,
                titleHeight = 0,
                bBox;

            if (titleOptions.text) {
                if (!this.title) {
                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, null, null, null, null, null, 'legend-title')
                        .attr({ zIndex: 1 })
                        .css(titleOptions.style)
                        .add(this.group);
                }
                bBox = this.title.getBBox();
                titleHeight = bBox.height;
                this.offsetWidth = bBox.width; // #1717
                this.contentGroup.attr({ translateY: titleHeight });
            }
            this.titleHeight = titleHeight;
        },

        /**
         * Set the legend item text
         */
        setText: function (item) {
            var options = this.options;
            item.legendItem.attr({
                text: options.labelFormat ? format(options.labelFormat, item) : options.labelFormatter.call(item)
            });
        },

        /**
         * Render a single specific legend item
         * @param {Object} item A series or point
         */
        renderItem: function (item) {
            var legend = this,
                chart = legend.chart,
                renderer = chart.renderer,
                options = legend.options,
                horizontal = options.layout === 'horizontal',
                symbolWidth = legend.symbolWidth,
                symbolPadding = options.symbolPadding,
                itemStyle = legend.itemStyle,
                itemHiddenStyle = legend.itemHiddenStyle,
                padding = legend.padding,
                itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,
                ltr = !options.rtl,
                itemHeight,
                widthOption = options.width,
                itemMarginBottom = options.itemMarginBottom || 0,
                itemMarginTop = legend.itemMarginTop,
                initialItemX = legend.initialItemX,
                bBox,
                itemWidth,
                li = item.legendItem,
                series = item.series && item.series.drawLegendSymbol ? item.series : item,
                seriesOptions = series.options,
                showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox,
                useHTML = options.useHTML;

            if (!li) { // generate it once, later move it

                // Generate the group box
                // A group to hold the symbol and text. Text is to be appended in Legend class.
                item.legendGroup = renderer.g('legend-item')
                    .attr({ zIndex: 1 })
                    .add(legend.scrollGroup);

                // Generate the list item text and add it to the group
                item.legendItem = li = renderer.text(
                        '',
                        ltr ? symbolWidth + symbolPadding : -symbolPadding,
                        legend.baseline || 0,
                        useHTML
                    )
                    .css(merge(item.visible ? itemStyle : itemHiddenStyle)) // merge to prevent modifying original (#1021)
                    .attr({
                        align: ltr ? 'left' : 'right',
                        zIndex: 2
                    })
                    .add(item.legendGroup);

                // Get the baseline for the first item - the font size is equal for all
                if (!legend.baseline) {
                    legend.fontMetrics = renderer.fontMetrics(itemStyle.fontSize, li);
                    legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;
                    li.attr('y', legend.baseline);
                }

                // Draw the legend symbol inside the group box
                series.drawLegendSymbol(legend, item);

                if (legend.setItemEvents) {
                    legend.setItemEvents(item, li, useHTML, itemStyle, itemHiddenStyle);
                }

                // add the HTML checkbox on top
                if (showCheckbox) {
                    legend.createCheckboxForItem(item);
                }
            }

            // Colorize the items
            legend.colorizeItem(item, item.visible);

            // Always update the text
            legend.setText(item);

            // calculate the positions for the next line
            bBox = li.getBBox();

            itemWidth = item.checkboxOffset =
                options.itemWidth ||
                item.legendItemWidth ||
                symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? 20 : 0);
            legend.itemHeight = itemHeight = mathRound(item.legendItemHeight || bBox.height);

            // if the item exceeds the width, start a new line
            if (horizontal && legend.itemX - initialItemX + itemWidth >
                    (widthOption || (chart.chartWidth - 2 * padding - initialItemX - options.x))) {
                legend.itemX = initialItemX;
                legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                legend.lastLineHeight = 0; // reset for next line (#915, #3976)
            }

            // If the item exceeds the height, start a new column
            /*if (!horizontal && legend.itemY + options.y + itemHeight > chart.chartHeight - spacingTop - spacingBottom) {
                legend.itemY = legend.initialItemY;
                legend.itemX += legend.maxItemWidth;
                legend.maxItemWidth = 0;
            }*/

            // Set the edge positions
            legend.maxItemWidth = mathMax(legend.maxItemWidth, itemWidth);
            legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
            legend.lastLineHeight = mathMax(itemHeight, legend.lastLineHeight); // #915

            // cache the position of the newly generated or reordered items
            item._legendItemPos = [legend.itemX, legend.itemY];

            // advance
            if (horizontal) {
                legend.itemX += itemWidth;

            } else {
                legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                legend.lastLineHeight = itemHeight;
            }

            // the width of the widest item
            legend.offsetWidth = widthOption || mathMax(
                (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
                legend.offsetWidth
            );
        },

        /**
         * Get all items, which is one item per series for normal series and one item per point
         * for pie series.
         */
        getAllItems: function () {
            var allItems = [];
            each(this.chart.series, function (series) {
                var seriesOptions = series.options;

                // Handle showInLegend. If the series is linked to another series, defaults to false.
                if (!pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? UNDEFINED : false, true)) {
                    return;
                }

                // use points or series for the legend item depending on legendType
                allItems = allItems.concat(
                        series.legendItems ||
                        (seriesOptions.legendType === 'point' ?
                                series.data :
                                series)
                );
            });
            return allItems;
        },

        /**
         * Adjust the chart margins by reserving space for the legend on only one side
         * of the chart. If the position is set to a corner, top or bottom is reserved
         * for horizontal legends and left or right for vertical ones.
         */
        adjustMargins: function (margin, spacing) {
            var chart = this.chart,
                options = this.options,
                // Use the first letter of each alignment option in order to detect the side
                alignment = options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0); // #4189 - use charAt(x) notation instead of [x] for IE7

            if (!options.floating) {

                each([
                    /(lth|ct|rth)/,
                    /(rtv|rm|rbv)/,
                    /(rbh|cb|lbh)/,
                    /(lbv|lm|ltv)/
                ], function (alignments, side) {
                    if (alignments.test(alignment) && !defined(margin[side])) {
                        // Now we have detected on which side of the chart we should reserve space for the legend
                        chart[marginNames[side]] = mathMax(
                            chart[marginNames[side]],
                            chart.legend[(side + 1) % 2 ? 'legendHeight' : 'legendWidth'] +
                                [1, -1, -1, 1][side] * options[(side % 2) ? 'x' : 'y'] +
                                pick(options.margin, 12) +
                                spacing[side]
                        );
                    }
                });
            }
        },

        /**
         * Render the legend. This method can be called both before and after
         * chart.render. If called after, it will only rearrange items instead
         * of creating new ones.
         */
        render: function () {
            var legend = this,
                chart = legend.chart,
                renderer = chart.renderer,
                legendGroup = legend.group,
                allItems,
                display,
                legendWidth,
                legendHeight,
                box = legend.box,
                options = legend.options,
                padding = legend.padding,
                legendBorderWidth = options.borderWidth,
                legendBackgroundColor = options.backgroundColor;

            legend.itemX = legend.initialItemX;
            legend.itemY = legend.initialItemY;
            legend.offsetWidth = 0;
            legend.lastItemY = 0;

            if (!legendGroup) {
                legend.group = legendGroup = renderer.g('legend')
                    .attr({ zIndex: 7 })
                    .add();
                legend.contentGroup = renderer.g()
                    .attr({ zIndex: 1 }) // above background
                    .add(legendGroup);
                legend.scrollGroup = renderer.g()
                    .add(legend.contentGroup);
            }

            legend.renderTitle();

            // add each series or point
            allItems = legend.getAllItems();

            // sort by legendIndex
            stableSort(allItems, function (a, b) {
                return ((a.options && a.options.legendIndex) || 0) - ((b.options && b.options.legendIndex) || 0);
            });

            // reversed legend
            if (options.reversed) {
                allItems.reverse();
            }

            legend.allItems = allItems;
            legend.display = display = !!allItems.length;

            // render the items
            legend.lastLineHeight = 0;
            each(allItems, function (item) {
                legend.renderItem(item);
            });

            // Get the box
            legendWidth = (options.width || legend.offsetWidth) + padding;
            legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
            legendHeight = legend.handleOverflow(legendHeight);
            legendHeight += padding;

            // Draw the border and/or background
            if (legendBorderWidth || legendBackgroundColor) {

                if (!box) {
                    legend.box = box = renderer.rect(
                        0,
                        0,
                        legendWidth,
                        legendHeight,
                        options.borderRadius,
                        legendBorderWidth || 0
                    ).attr({
                        stroke: options.borderColor,
                        'stroke-width': legendBorderWidth || 0,
                        fill: legendBackgroundColor || NONE
                    })
                    .add(legendGroup)
                    .shadow(options.shadow);
                    box.isNew = true;

                } else if (legendWidth > 0 && legendHeight > 0) {
                    box[box.isNew ? 'attr' : 'animate'](
                        box.crisp({ width: legendWidth, height: legendHeight })
                    );
                    box.isNew = false;
                }

                // hide the border if no items
                box[display ? 'show' : 'hide']();
            }

            legend.legendWidth = legendWidth;
            legend.legendHeight = legendHeight;

            // Now that the legend width and height are established, put the items in the
            // final position
            each(allItems, function (item) {
                legend.positionItem(item);
            });

            // 1.x compatibility: positioning based on style
            /*var props = ['left', 'right', 'top', 'bottom'],
                prop,
                i = 4;
            while (i--) {
                prop = props[i];
                if (options.style[prop] && options.style[prop] !== 'auto') {
                    options[i < 2 ? 'align' : 'verticalAlign'] = prop;
                    options[i < 2 ? 'x' : 'y'] = pInt(options.style[prop]) * (i % 2 ? -1 : 1);
                }
            }*/

            if (display) {
                legendGroup.align(extend({
                    width: legendWidth,
                    height: legendHeight
                }, options), true, 'spacingBox');
            }

            if (!chart.isResizing) {
                this.positionCheckboxes();
            }
        },

        /**
         * Set up the overflow handling by adding navigation with up and down arrows below the
         * legend.
         */
        handleOverflow: function (legendHeight) {
            var legend = this,
                chart = this.chart,
                renderer = chart.renderer,
                options = this.options,
                optionsY = options.y,
                alignTop = options.verticalAlign === 'top',
                spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - this.padding,
                maxHeight = options.maxHeight,
                clipHeight,
                clipRect = this.clipRect,
                navOptions = options.navigation,
                animation = pick(navOptions.animation, true),
                arrowSize = navOptions.arrowSize || 12,
                nav = this.nav,
                pages = this.pages,
                padding = this.padding,
                lastY,
                allItems = this.allItems,
                clipToHeight = function (height) {
                    clipRect.attr({
                        height: height
                    });

                    // useHTML
                    if (legend.contentGroup.div) {
                        legend.contentGroup.div.style.clip = 'rect(' + padding + 'px,9999px,' + (padding + height) + 'px,0)';
                    }
                };


            // Adjust the height
            if (options.layout === 'horizontal') {
                spaceHeight /= 2;
            }
            if (maxHeight) {
                spaceHeight = mathMin(spaceHeight, maxHeight);
            }

            // Reset the legend height and adjust the clipping rectangle
            pages.length = 0;
            if (legendHeight > spaceHeight && navOptions.enabled !== false) {

                this.clipHeight = clipHeight = mathMax(spaceHeight - 20 - this.titleHeight - padding, 0);
                this.currentPage = pick(this.currentPage, 1);
                this.fullHeight = legendHeight;

                // Fill pages with Y positions so that the top of each a legend item defines
                // the scroll top for each page (#2098)
                each(allItems, function (item, i) {
                    var y = item._legendItemPos[1],
                        h = mathRound(item.legendItem.getBBox().height),
                        len = pages.length;

                    if (!len || (y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1])) {
                        pages.push(lastY || y);
                        len++;
                    }

                    if (i === allItems.length - 1 && y + h - pages[len - 1] > clipHeight) {
                        pages.push(y);
                    }
                    if (y !== lastY) {
                        lastY = y;
                    }
                });

                // Only apply clipping if needed. Clipping causes blurred legend in PDF export (#1787)
                if (!clipRect) {
                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
                    legend.contentGroup.clip(clipRect);
                }

                clipToHeight(clipHeight);

                // Add navigation elements
                if (!nav) {
                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
                    this.up = renderer.symbol('triangle', 0, 0, arrowSize, arrowSize)
                        .on('click', function () {
                            legend.scroll(-1, animation);
                        })
                        .add(nav);
                    this.pager = renderer.text('', 15, 10)
                        .css(navOptions.style)
                        .add(nav);
                    this.down = renderer.symbol('triangle-down', 0, 0, arrowSize, arrowSize)
                        .on('click', function () {
                            legend.scroll(1, animation);
                        })
                        .add(nav);
                }

                // Set initial position
                legend.scroll(0);

                legendHeight = spaceHeight;

            } else if (nav) {
                clipToHeight(chart.chartHeight);
                nav.hide();
                this.scrollGroup.attr({
                    translateY: 1
                });
                this.clipHeight = 0; // #1379
            }

            return legendHeight;
        },

        /**
         * Scroll the legend by a number of pages
         * @param {Object} scrollBy
         * @param {Object} animation
         */
        scroll: function (scrollBy, animation) {
            var pages = this.pages,
                pageCount = pages.length,
                currentPage = this.currentPage + scrollBy,
                clipHeight = this.clipHeight,
                navOptions = this.options.navigation,
                activeColor = navOptions.activeColor,
                inactiveColor = navOptions.inactiveColor,
                pager = this.pager,
                padding = this.padding,
                scrollOffset;

            // When resizing while looking at the last page
            if (currentPage > pageCount) {
                currentPage = pageCount;
            }

            if (currentPage > 0) {

                if (animation !== UNDEFINED) {
                    setAnimation(animation, this.chart);
                }

                this.nav.attr({
                    translateX: padding,
                    translateY: clipHeight + this.padding + 7 + this.titleHeight,
                    visibility: VISIBLE
                });
                this.up.attr({
                        fill: currentPage === 1 ? inactiveColor : activeColor
                    })
                    .css({
                        cursor: currentPage === 1 ? 'default' : 'pointer'
                    });
                pager.attr({
                    text: currentPage + '/' + pageCount
                });
                this.down.attr({
                        x: 18 + this.pager.getBBox().width, // adjust to text width
                        fill: currentPage === pageCount ? inactiveColor : activeColor
                    })
                    .css({
                        cursor: currentPage === pageCount ? 'default' : 'pointer'
                    });

                scrollOffset = -pages[currentPage - 1] + this.initialItemY;

                this.scrollGroup.animate({
                    translateY: scrollOffset
                });

                this.currentPage = currentPage;
                this.positionCheckboxes(scrollOffset);
            }

        }

    };

    /*
     * LegendSymbolMixin
     */

    var LegendSymbolMixin = Highcharts.LegendSymbolMixin = {

        /**
         * Get the series' symbol in the legend
         *
         * @param {Object} legend The legend object
         * @param {Object} item The series (this) or point
         */
        drawRectangle: function (legend, item) {
            var symbolHeight = legend.options.symbolHeight || legend.fontMetrics.f;

            item.legendSymbol = this.chart.renderer.rect(
                0,
                legend.baseline - symbolHeight + 1, // #3988
                legend.symbolWidth,
                symbolHeight,
                legend.options.symbolRadius || 0
            ).attr({
                zIndex: 3
            }).add(item.legendGroup);

        },

        /**
         * Get the series' symbol in the legend. This method should be overridable to create custom
         * symbols through Highcharts.seriesTypes[type].prototype.drawLegendSymbols.
         *
         * @param {Object} legend The legend object
         */
        drawLineMarker: function (legend) {

            var options = this.options,
                markerOptions = options.marker,
                radius,
                legendSymbol,
                symbolWidth = legend.symbolWidth,
                renderer = this.chart.renderer,
                legendItemGroup = this.legendGroup,
                verticalCenter = legend.baseline - mathRound(legend.fontMetrics.b * 0.3),
                attr;

            // Draw the line
            if (options.lineWidth) {
                attr = {
                    'stroke-width': options.lineWidth
                };
                if (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                this.legendLine = renderer.path([
                    M,
                    0,
                    verticalCenter,
                    L,
                    symbolWidth,
                    verticalCenter
                ])
                .attr(attr)
                .add(legendItemGroup);
            }

            // Draw the marker
            if (markerOptions && markerOptions.enabled !== false) {
                radius = markerOptions.radius;
                this.legendSymbol = legendSymbol = renderer.symbol(
                    this.symbol,
                    (symbolWidth / 2) - radius,
                    verticalCenter - radius,
                    2 * radius,
                    2 * radius,
                    markerOptions
                )
                .add(legendItemGroup);
                legendSymbol.isMarker = true;
            }
        }
    };

    // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,
    // and for #2580, a similar drawing flaw in Firefox 26.
    // Explore if there's a general cause for this. The problem may be related
    // to nested group elements, as the legend item texts are within 4 group elements.
    if (/Trident\/7\.0/.test(userAgent) || isFirefox) {
        wrap(Legend.prototype, 'positionItem', function (proceed, item) {
            var legend = this,
                runPositionItem = function () { // If chart destroyed in sync, this is undefined (#2030)
                    if (item._legendItemPos) {
                        proceed.call(legend, item);
                    }
                };

            // Do it now, for export and to get checkbox placement
            runPositionItem();

            // Do it after to work around the core issue
            setTimeout(runPositionItem);
        });
    }
    /**
     * The Chart class
     * @param {String|Object} renderTo The DOM element to render to, or its id
     * @param {Object} options
     * @param {Function} callback Function to run when the chart has loaded
     */
    var Chart = Highcharts.Chart = function () {
        this.getArgs.apply(this, arguments);
    };

    Highcharts.chart = function (a, b, c) {
        return new Chart(a, b, c);
    };

    Chart.prototype = {

        /**
         * Hook for modules
         */
        callbacks: [],

        /**
         * Handle the arguments passed to the constructor
         * @returns {Array} Arguments without renderTo
         */
        getArgs: function () {
            var args = [].slice.call(arguments);
        
            // Remove the optional first argument, renderTo, and
            // set it on this.
            if (isString(args[0]) || args[0].nodeName) {
                this.renderTo = args.shift();
            }
            this.init(args[0], args[1]);
        },

        /**
         * Initialize the chart
         */
        init: function (userOptions, callback) {

            // Handle regular options
            var options,
                seriesOptions = userOptions.series; // skip merging data points to increase performance

            userOptions.series = null;
            options = merge(defaultOptions, userOptions); // do the merge
            options.series = userOptions.series = seriesOptions; // set back the series data
            this.userOptions = userOptions;

            var optionsChart = options.chart;

            // Create margin & spacing array
            this.margin = this.splashArray('margin', optionsChart);
            this.spacing = this.splashArray('spacing', optionsChart);

            var chartEvents = optionsChart.events;

            //this.runChartClick = chartEvents && !!chartEvents.click;
            this.bounds = { h: {}, v: {} }; // Pixel data bounds for touch zoom

            this.callback = callback;
            this.isResizing = 0;
            this.options = options;
            //chartTitleOptions = UNDEFINED;
            //chartSubtitleOptions = UNDEFINED;

            this.axes = [];
            this.series = [];
            this.hasCartesianSeries = optionsChart.showAxes;
            //this.axisOffset = UNDEFINED;
            //this.maxTicks = UNDEFINED; // handle the greatest amount of ticks on grouped axes
            //this.inverted = UNDEFINED;
            //this.loadingShown = UNDEFINED;
            //this.container = UNDEFINED;
            //this.chartWidth = UNDEFINED;
            //this.chartHeight = UNDEFINED;
            //this.marginRight = UNDEFINED;
            //this.marginBottom = UNDEFINED;
            //this.containerWidth = UNDEFINED;
            //this.containerHeight = UNDEFINED;
            //this.oldChartWidth = UNDEFINED;
            //this.oldChartHeight = UNDEFINED;

            //this.renderTo = UNDEFINED;
            //this.renderToClone = UNDEFINED;

            //this.spacingBox = UNDEFINED

            //this.legend = UNDEFINED;

            // Elements
            //this.chartBackground = UNDEFINED;
            //this.plotBackground = UNDEFINED;
            //this.plotBGImage = UNDEFINED;
            //this.plotBorder = UNDEFINED;
            //this.loadingDiv = UNDEFINED;
            //this.loadingSpan = UNDEFINED;

            var chart = this,
                eventType;

            // Add the chart to the global lookup
            chart.index = charts.length;
            charts.push(chart);
            chartCount++;

            // Set up auto resize
            if (optionsChart.reflow !== false) {
                addEvent(chart, 'load', function () {
                    chart.initReflow();
                });
            }

            // Chart event handlers
            if (chartEvents) {
                for (eventType in chartEvents) {
                    addEvent(chart, eventType, chartEvents[eventType]);
                }
            }

            chart.xAxis = [];
            chart.yAxis = [];

            // Expose methods and variables
            chart.animation = useCanVG ? false : pick(optionsChart.animation, true);
            chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;

            chart.firstRender();
        },

        /**
         * Initialize an individual series, called internally before render time
         */
        initSeries: function (options) {
            var chart = this,
                optionsChart = chart.options.chart,
                type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
                series,
                constr = seriesTypes[type];

            // No such series type
            if (!constr) {
                error(17, true);
            }

            series = new constr();
            series.init(this, options);
            return series;
        },

        /**
         * Check whether a given point is within the plot area
         *
         * @param {Number} plotX Pixel x relative to the plot area
         * @param {Number} plotY Pixel y relative to the plot area
         * @param {Boolean} inverted Whether the chart is inverted
         */
        isInsidePlot: function (plotX, plotY, inverted) {
            var x = inverted ? plotY : plotX,
                y = inverted ? plotX : plotY;

            return x >= 0 &&
                x <= this.plotWidth &&
                y >= 0 &&
                y <= this.plotHeight;
        },

        /**
         * Redraw legend, axes or series based on updated data
         *
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        redraw: function (animation) {
            var chart = this,
                axes = chart.axes,
                series = chart.series,
                pointer = chart.pointer,
                legend = chart.legend,
                redrawLegend = chart.isDirtyLegend,
                hasStackedSeries,
                hasDirtyStacks,
                hasCartesianSeries = chart.hasCartesianSeries,
                isDirtyBox = chart.isDirtyBox,
                seriesLength = series.length,
                i = seriesLength,
                serie,
                renderer = chart.renderer,
                isHiddenChart = renderer.isHidden(),
                afterRedraw = [];

            setAnimation(animation, chart);

            if (isHiddenChart) {
                chart.cloneRenderTo();
            }

            // Adjust title layout (reflow multiline text)
            chart.layOutTitles();

            // link stacked series
            while (i--) {
                serie = series[i];

                if (serie.options.stacking) {
                    hasStackedSeries = true;

                    if (serie.isDirty) {
                        hasDirtyStacks = true;
                        break;
                    }
                }
            }
            if (hasDirtyStacks) { // mark others as dirty
                i = seriesLength;
                while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                        serie.isDirty = true;
                    }
                }
            }

            // Handle updated data in the series
            each(series, function (serie) {
                if (serie.isDirty) {
                    if (serie.options.legendType === 'point') {
                        if (serie.updateTotals) {
                            serie.updateTotals();
                        }
                        redrawLegend = true;
                    }
                }
                if (serie.isDirtyData) {
                    fireEvent(serie, 'updatedData');
                }
            });

            // handle added or removed series
            if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed
                // draw legend graphics
                legend.render();

                chart.isDirtyLegend = false;
            }

            // reset stacks
            if (hasStackedSeries) {
                chart.getStacks();
            }


            if (hasCartesianSeries) {
                if (!chart.isResizing) {

                    // reset maxTicks
                    chart.maxTicks = null;

                    // set axes scales
                    each(axes, function (axis) {
                        axis.setScale();
                    });
                }
            }

            chart.getMargins(); // #3098

            if (hasCartesianSeries) {
                // If one axis is dirty, all axes must be redrawn (#792, #2169)
                each(axes, function (axis) {
                    if (axis.isDirty) {
                        isDirtyBox = true;
                    }
                });

                // redraw axes
                each(axes, function (axis) {

                    // Fire 'afterSetExtremes' only if extremes are set
                    var key = axis.min + ',' + axis.max;
                    if (axis.extKey !== key) { // #821, #4452
                        axis.extKey = key;
                        afterRedraw.push(function () { // prevent a recursive call to chart.redraw() (#1119)
                            fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751
                            delete axis.eventArgs;
                        });
                    }
                    if (isDirtyBox || hasStackedSeries) {
                        axis.redraw();
                    }
                });
            }

            // the plot areas size has changed
            if (isDirtyBox) {
                chart.drawChartBox();
            }


            // redraw affected series
            each(series, function (serie) {
                if (serie.isDirty && serie.visible &&
                        (!serie.isCartesian || serie.xAxis)) { // issue #153
                    serie.redraw();
                }
            });

            // move tooltip or reset
            if (pointer) {
                pointer.reset(true);
            }

            // redraw if canvas
            renderer.draw();

            // fire the event
            fireEvent(chart, 'redraw');

            if (isHiddenChart) {
                chart.cloneRenderTo(true);
            }

            // Fire callbacks that are put on hold until after the redraw
            each(afterRedraw, function (callback) {
                callback.call();
            });
        },

        /**
         * Get an axis, series or point object by id.
         * @param id {String} The id as given in the configuration options
         */
        get: function (id) {
            var chart = this,
                axes = chart.axes,
                series = chart.series;

            var i,
                j,
                points;

            // search axes
            for (i = 0; i < axes.length; i++) {
                if (axes[i].options.id === id) {
                    return axes[i];
                }
            }

            // search series
            for (i = 0; i < series.length; i++) {
                if (series[i].options.id === id) {
                    return series[i];
                }
            }

            // search points
            for (i = 0; i < series.length; i++) {
                points = series[i].points || [];
                for (j = 0; j < points.length; j++) {
                    if (points[j].id === id) {
                        return points[j];
                    }
                }
            }
            return null;
        },

        /**
         * Create the Axis instances based on the config options
         */
        getAxes: function () {
            var chart = this,
                options = this.options,
                xAxisOptions = options.xAxis = splat(options.xAxis || {}),
                yAxisOptions = options.yAxis = splat(options.yAxis || {}),
                optionsArray;

            // make sure the options are arrays and add some members
            each(xAxisOptions, function (axis, i) {
                axis.index = i;
                axis.isX = true;
            });

            each(yAxisOptions, function (axis, i) {
                axis.index = i;
            });

            // concatenate all axis options into one array
            optionsArray = xAxisOptions.concat(yAxisOptions);

            each(optionsArray, function (axisOptions) {
                new Axis(chart, axisOptions); // eslint-disable-line no-new
            });
        },


        /**
         * Get the currently selected points from all series
         */
        getSelectedPoints: function () {
            var points = [];
            each(this.series, function (serie) {
                points = points.concat(grep(serie.points || [], function (point) {
                    return point.selected;
                }));
            });
            return points;
        },

        /**
         * Get the currently selected series
         */
        getSelectedSeries: function () {
            return grep(this.series, function (serie) {
                return serie.selected;
            });
        },

        /**
         * Show the title and subtitle of the chart
         *
         * @param titleOptions {Object} New title options
         * @param subtitleOptions {Object} New subtitle options
         *
         */
        setTitle: function (titleOptions, subtitleOptions, redraw) {
            var chart = this,
                options = chart.options,
                chartTitleOptions,
                chartSubtitleOptions;

            chartTitleOptions = options.title = merge(options.title, titleOptions);
            chartSubtitleOptions = options.subtitle = merge(options.subtitle, subtitleOptions);

            // add title and subtitle
            each([
                ['title', titleOptions, chartTitleOptions],
                ['subtitle', subtitleOptions, chartSubtitleOptions]
            ], function (arr) {
                var name = arr[0],
                    title = chart[name],
                    titleOptions = arr[1],
                    chartTitleOptions = arr[2];

                if (title && titleOptions) {
                    chart[name] = title = title.destroy(); // remove old
                }

                if (chartTitleOptions && chartTitleOptions.text && !title) {
                    chart[name] = chart.renderer.text(
                        chartTitleOptions.text,
                        0,
                        0,
                        chartTitleOptions.useHTML
                    )
                    .attr({
                        align: chartTitleOptions.align,
                        'class': PREFIX + name,
                        zIndex: chartTitleOptions.zIndex || 4
                    })
                    .css(chartTitleOptions.style)
                    .add();
            
                }
            });
            chart.layOutTitles(redraw);
        },

        /**
         * Lay out the chart titles and cache the full offset height for use in getMargins
         */
        layOutTitles: function (redraw) {
            var titleOffset = 0,
                title = this.title,
                subtitle = this.subtitle,
                options = this.options,
                titleOptions = options.title,
                subtitleOptions = options.subtitle,
                requiresDirtyBox,
                renderer = this.renderer,
                spacingBox = this.spacingBox;

            if (title) {
                title
                    .css({ width: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + PX })
                    .align(extend({
                        y: renderer.fontMetrics(titleOptions.style.fontSize, title).b - 3
                    }, titleOptions), false, spacingBox);

                if (!titleOptions.floating && !titleOptions.verticalAlign) {
                    titleOffset = title.getBBox().height;
                }
            }
            if (subtitle) {
                subtitle
                    .css({ width: (subtitleOptions.width || spacingBox.width + subtitleOptions.widthAdjust) + PX })
                    .align(extend({
                        y: titleOffset + (titleOptions.margin - 13) + renderer.fontMetrics(subtitleOptions.style.fontSize, title).b
                    }, subtitleOptions), false, spacingBox);

                if (!subtitleOptions.floating && !subtitleOptions.verticalAlign) {
                    titleOffset = mathCeil(titleOffset + subtitle.getBBox().height);
                }
            }

            requiresDirtyBox = this.titleOffset !== titleOffset;
            this.titleOffset = titleOffset; // used in getMargins

            if (!this.isDirtyBox && requiresDirtyBox) {
                this.isDirtyBox = requiresDirtyBox;
                // Redraw if necessary (#2719, #2744)
                if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
                    this.redraw();
                }
            }
        },

        /**
         * Get chart width and height according to options and container size
         */
        getChartSize: function () {
            var chart = this,
                optionsChart = chart.options.chart,
                widthOption = optionsChart.width,
                heightOption = optionsChart.height,
                renderTo = chart.renderToClone || chart.renderTo;

            // Get inner width and height
            if (!defined(widthOption)) {
                chart.containerWidth = getStyle(renderTo, 'width');
            }
            if (!defined(heightOption)) {
                chart.containerHeight = getStyle(renderTo, 'height');
            }

            chart.chartWidth = mathMax(0, widthOption || chart.containerWidth || 600); // #1393, 1460
            chart.chartHeight = mathMax(0, pick(heightOption,
                // the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
                chart.containerHeight > 19 ? chart.containerHeight : 400));
        },

        /**
         * Create a clone of the chart's renderTo div and place it outside the viewport to allow
         * size computation on chart.render and chart.redraw
         */
        cloneRenderTo: function (revert) {
            var clone = this.renderToClone,
                container = this.container;

            // Destroy the clone and bring the container back to the real renderTo div
            if (revert) {
                if (clone) {
                    this.renderTo.appendChild(container);
                    discardElement(clone);
                    delete this.renderToClone;
                }

            // Set up the clone
            } else {
                if (container && container.parentNode === this.renderTo) {
                    this.renderTo.removeChild(container); // do not clone this
                }
                this.renderToClone = clone = this.renderTo.cloneNode(0);
                css(clone, {
                    position: ABSOLUTE,
                    top: '-9999px',
                    display: 'block' // #833
                });
                if (clone.style.setProperty) { // #2631
                    clone.style.setProperty('display', 'block', 'important');
                }
                doc.body.appendChild(clone);
                if (container) {
                    clone.appendChild(container);
                }
            }
        },

        /**
         * Get the containing element, determine the size and create the inner container
         * div to hold the chart
         */
        getContainer: function () {
            var chart = this,
                container,
                options = chart.options,
                optionsChart = options.chart,
                chartWidth,
                chartHeight,
                renderTo = chart.renderTo,
                indexAttrName = 'data-highcharts-chart',
                oldChartIndex,
                Ren,
                containerId = 'highcharts-' + idCounter++;

            if (!renderTo) {
                chart.renderTo = renderTo = optionsChart.renderTo;
            }
        
            if (isString(renderTo)) {
                chart.renderTo = renderTo = doc.getElementById(renderTo);
            }

            // Display an error if the renderTo is wrong
            if (!renderTo) {
                error(13, true);
            }

            // If the container already holds a chart, destroy it. The check for hasRendered is there
            // because web pages that are saved to disk from the browser, will preserve the data-highcharts-chart
            // attribute and the SVG contents, but not an interactive chart. So in this case,
            // charts[oldChartIndex] will point to the wrong chart if any (#2609).
            oldChartIndex = pInt(attr(renderTo, indexAttrName));
            if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
                charts[oldChartIndex].destroy();
            }

            // Make a reference to the chart from the div
            attr(renderTo, indexAttrName, chart.index);

            // remove previous chart
            renderTo.innerHTML = '';

            // If the container doesn't have an offsetWidth, it has or is a child of a node
            // that has display:none. We need to temporarily move it out to a visible
            // state to determine the size, else the legend and tooltips won't render
            // properly. The allowClone option is used in sparklines as a micro optimization,
            // saving about 1-2 ms each chart.
            if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                chart.cloneRenderTo();
            }

            // get the width and height
            chart.getChartSize();
            chartWidth = chart.chartWidth;
            chartHeight = chart.chartHeight;

            // create the inner container
            chart.container = container = createElement(DIV, {
                    className: PREFIX + 'container' +
                        (optionsChart.className ? ' ' + optionsChart.className : ''),
                    id: containerId
                }, extend({
                    position: RELATIVE,
                    overflow: HIDDEN, // needed for context menu (avoid scrollbars) and
                        // content overflow in IE
                    width: chartWidth + PX,
                    height: chartHeight + PX,
                    textAlign: 'left',
                    lineHeight: 'normal', // #427
                    zIndex: 0, // #1072
                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'
                }, optionsChart.style),
                chart.renderToClone || renderTo
            );

            // cache the cursor (#1650)
            chart._cursor = container.style.cursor;

            // Initialize the renderer
            Ren = Highcharts[optionsChart.renderer] || Renderer;
            chart.renderer = new Ren(
                container,
                chartWidth,
                chartHeight,
                optionsChart.style,
                optionsChart.forExport,
                options.exporting && options.exporting.allowHTML
            );

            if (useCanVG) {
                // If we need canvg library, extend and configure the renderer
                // to get the tracker for translating mouse events
                chart.renderer.create(chart, container, chartWidth, chartHeight);
            }
            // Add a reference to the charts index
            chart.renderer.chartIndex = chart.index;
        },

        /**
         * Calculate margins by rendering axis labels in a preliminary position. Title,
         * subtitle and legend have already been rendered at this stage, but will be
         * moved into their final positions
         */
        getMargins: function (skipAxes) {
            var chart = this,
                spacing = chart.spacing,
                margin = chart.margin,
                titleOffset = chart.titleOffset;

            chart.resetMargins();

            // Adjust for title and subtitle
            if (titleOffset && !defined(margin[0])) {
                chart.plotTop = mathMax(chart.plotTop, titleOffset + chart.options.title.margin + spacing[0]);
            }

            // Adjust for legend
            if (chart.legend.display) {
                chart.legend.adjustMargins(margin, spacing);
            }

            // adjust for scroller
            if (chart.extraBottomMargin) {
                chart.marginBottom += chart.extraBottomMargin;
            }
            if (chart.extraTopMargin) {
                chart.plotTop += chart.extraTopMargin;
            }
            if (!skipAxes) {
                this.getAxisMargins();
            }
        },

        getAxisMargins: function () {

            var chart = this,
                axisOffset = chart.axisOffset = [0, 0, 0, 0], // top, right, bottom, left
                margin = chart.margin;

            // pre-render axes to get labels offset width
            if (chart.hasCartesianSeries) {
                each(chart.axes, function (axis) {
                    if (axis.visible) {
                        axis.getOffset();
                    }
                });
            }

            // Add the axis offsets
            each(marginNames, function (m, side) {
                if (!defined(margin[side])) {
                    chart[m] += axisOffset[side];
                }
            });

            chart.setChartSize();

        },

        /**
         * Resize the chart to its container if size is not explicitly set
         */
        reflow: function (e) {
            var chart = this,
                optionsChart = chart.options.chart,
                renderTo = chart.renderTo,
                hasUserWidth = defined(optionsChart.width),
                width = optionsChart.width || getStyle(renderTo, 'width'),
                height = optionsChart.height || getStyle(renderTo, 'height'),
                target = e ? e.target : win;

            // Width and height checks for display:none. Target is doc in IE8 and Opera,
            // win in Firefox, Chrome and IE9.
            if (!hasUserWidth && !chart.isPrinting && width && height && (target === win || target === doc)) { // #1093
                if (width !== chart.containerWidth || height !== chart.containerHeight) {
                    clearTimeout(chart.reflowTimeout);
                    // When called from window.resize, e is set, else it's called directly (#2224)
                    chart.reflowTimeout = syncTimeout(function () {
                        if (chart.container) { // It may have been destroyed in the meantime (#1257)
                            chart.setSize(undefined, undefined, false);
                        }
                    }, e ? 100 : 0);
                }
                chart.containerWidth = width;
                chart.containerHeight = height;
            }
        },

        /**
         * Add the event handlers necessary for auto resizing
         */
        initReflow: function () {
            var chart = this,
                reflow = function (e) {
                    chart.reflow(e);
                };


            addEvent(win, 'resize', reflow);
            addEvent(chart, 'destroy', function () {
                removeEvent(win, 'resize', reflow);
            });
        },

        /**
         * Resize the chart to a given width and height
         * @param {Number} width
         * @param {Number} height
         * @param {Object|Boolean} animation
         */
        setSize: function (width, height, animation) {
            var chart = this,
                renderer = chart.renderer,
                globalAnimation;

            // Handle the isResizing counter
            chart.isResizing += 1;
        
            // set the animation for the current process
            setAnimation(animation, chart);

            chart.oldChartHeight = chart.chartHeight;
            chart.oldChartWidth = chart.chartWidth;
            if (width !== undefined) {
                chart.options.chart.width = width;
            }
            if (height !== undefined) {
                chart.options.chart.height = height;
            }
            chart.getChartSize();

            // Resize the container with the global animation applied if enabled (#2503)
            globalAnimation = renderer.globalAnimation;
            (globalAnimation ? animate : css)(chart.container, {
                width: chart.chartWidth + PX,
                height: chart.chartHeight + PX
            }, globalAnimation);

            chart.setChartSize(true);
            renderer.setSize(chart.chartWidth, chart.chartHeight, animation);

            // handle axes
            chart.maxTicks = null;
            each(chart.axes, function (axis) {
                axis.isDirty = true;
                axis.setScale();
            });

            // make sure non-cartesian series are also handled
            each(chart.series, function (serie) {
                serie.isDirty = true;
            });

            chart.isDirtyLegend = true; // force legend redraw
            chart.isDirtyBox = true; // force redraw of plot and chart border

            chart.layOutTitles(); // #2857
            chart.getMargins();

            chart.redraw(animation);


            chart.oldChartHeight = null;
            fireEvent(chart, 'resize');

            // Fire endResize and set isResizing back. If animation is disabled, fire without delay
            syncTimeout(function () {
                if (chart) {
                    fireEvent(chart, 'endResize', null, function () {
                        chart.isResizing -= 1;
                    });
                }
            }, animObject(globalAnimation).duration);
        },

        /**
         * Set the public chart properties. This is done before and after the pre-render
         * to determine margin sizes
         */
        setChartSize: function (skipAxes) {
            var chart = this,
                inverted = chart.inverted,
                renderer = chart.renderer,
                chartWidth = chart.chartWidth,
                chartHeight = chart.chartHeight,
                optionsChart = chart.options.chart,
                spacing = chart.spacing,
                clipOffset = chart.clipOffset,
                clipX,
                clipY,
                plotLeft,
                plotTop,
                plotWidth,
                plotHeight,
                plotBorderWidth;

            chart.plotLeft = plotLeft = mathRound(chart.plotLeft);
            chart.plotTop = plotTop = mathRound(chart.plotTop);
            chart.plotWidth = plotWidth = mathMax(0, mathRound(chartWidth - plotLeft - chart.marginRight));
            chart.plotHeight = plotHeight = mathMax(0, mathRound(chartHeight - plotTop - chart.marginBottom));

            chart.plotSizeX = inverted ? plotHeight : plotWidth;
            chart.plotSizeY = inverted ? plotWidth : plotHeight;

            chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;

            // Set boxes used for alignment
            chart.spacingBox = renderer.spacingBox = {
                x: spacing[3],
                y: spacing[0],
                width: chartWidth - spacing[3] - spacing[1],
                height: chartHeight - spacing[0] - spacing[2]
            };
            chart.plotBox = renderer.plotBox = {
                x: plotLeft,
                y: plotTop,
                width: plotWidth,
                height: plotHeight
            };

            plotBorderWidth = 2 * mathFloor(chart.plotBorderWidth / 2);
            clipX = mathCeil(mathMax(plotBorderWidth, clipOffset[3]) / 2);
            clipY = mathCeil(mathMax(plotBorderWidth, clipOffset[0]) / 2);
            chart.clipBox = {
                x: clipX,
                y: clipY,
                width: mathFloor(chart.plotSizeX - mathMax(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                height: mathMax(0, mathFloor(chart.plotSizeY - mathMax(plotBorderWidth, clipOffset[2]) / 2 - clipY))
            };

            if (!skipAxes) {
                each(chart.axes, function (axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                });
            }
        },

        /**
         * Initial margins before auto size margins are applied
         */
        resetMargins: function () {
            var chart = this;

            each(marginNames, function (m, side) {
                chart[m] = pick(chart.margin[side], chart.spacing[side]);
            });
            chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
            chart.clipOffset = [0, 0, 0, 0];
        },

        /**
         * Draw the borders and backgrounds for chart and plot area
         */
        drawChartBox: function () {
            var chart = this,
                optionsChart = chart.options.chart,
                renderer = chart.renderer,
                chartWidth = chart.chartWidth,
                chartHeight = chart.chartHeight,
                chartBackground = chart.chartBackground,
                plotBackground = chart.plotBackground,
                plotBorder = chart.plotBorder,
                plotBGImage = chart.plotBGImage,
                chartBorderWidth = optionsChart.borderWidth || 0,
                chartBackgroundColor = optionsChart.backgroundColor,
                plotBackgroundColor = optionsChart.plotBackgroundColor,
                plotBackgroundImage = optionsChart.plotBackgroundImage,
                plotBorderWidth = optionsChart.plotBorderWidth || 0,
                mgn,
                bgAttr,
                plotLeft = chart.plotLeft,
                plotTop = chart.plotTop,
                plotWidth = chart.plotWidth,
                plotHeight = chart.plotHeight,
                plotBox = chart.plotBox,
                clipRect = chart.clipRect,
                clipBox = chart.clipBox;

            // Chart area
            mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);

            if (chartBorderWidth || chartBackgroundColor) {
                if (!chartBackground) {

                    bgAttr = {
                        fill: chartBackgroundColor || NONE
                    };
                    if (chartBorderWidth) { // #980
                        bgAttr.stroke = optionsChart.borderColor;
                        bgAttr['stroke-width'] = chartBorderWidth;
                    }
                    chart.chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn,
                            optionsChart.borderRadius, chartBorderWidth)
                        .attr(bgAttr)
                        .addClass(PREFIX + 'background')
                        .add()
                        .shadow(optionsChart.shadow);

                } else { // resize
                    chartBackground.animate(
                        chartBackground.crisp({ width: chartWidth - mgn, height: chartHeight - mgn })
                    );
                }
            }


            // Plot background
            if (plotBackgroundColor) {
                if (!plotBackground) {
                    chart.plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
                        .attr({
                            fill: plotBackgroundColor
                        })
                        .add()
                        .shadow(optionsChart.plotShadow);
                } else {
                    plotBackground.animate(plotBox);
                }
            }
            if (plotBackgroundImage) {
                if (!plotBGImage) {
                    chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
                        .add();
                } else {
                    plotBGImage.animate(plotBox);
                }
            }

            // Plot clip
            if (!clipRect) {
                chart.clipRect = renderer.clipRect(clipBox);
            } else {
                clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                });
            }

            // Plot area border
            if (plotBorderWidth) {
                if (!plotBorder) {
                    chart.plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, -plotBorderWidth)
                        .attr({
                            stroke: optionsChart.plotBorderColor,
                            'stroke-width': plotBorderWidth,
                            fill: NONE,
                            zIndex: 1
                        })
                        .add();
                } else {
                    plotBorder.strokeWidth = -plotBorderWidth;
                    plotBorder.animate(
                        plotBorder.crisp({ x: plotLeft, y: plotTop, width: plotWidth, height: plotHeight }) //#3282 plotBorder should be negative
                    );
                }
            }

            // reset
            chart.isDirtyBox = false;
        },

        /**
         * Detect whether a certain chart property is needed based on inspecting its options
         * and series. This mainly applies to the chart.invert property, and in extensions to
         * the chart.angular and chart.polar properties.
         */
        propFromSeries: function () {
            var chart = this,
                optionsChart = chart.options.chart,
                klass,
                seriesOptions = chart.options.series,
                i,
                value;


            each(['inverted', 'angular', 'polar'], function (key) {

                // The default series type's class
                klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];

                // Get the value from available chart-wide properties
                value = (
                    chart[key] || // 1. it is set before
                    optionsChart[key] || // 2. it is set in the options
                    (klass && klass.prototype[key]) // 3. it's default series class requires it
                );

                // 4. Check if any the chart's series require it
                i = seriesOptions && seriesOptions.length;
                while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                        value = true;
                    }
                }

                // Set the chart property
                chart[key] = value;
            });

        },

        /**
         * Link two or more series together. This is done initially from Chart.render,
         * and after Chart.addSeries and Series.remove.
         */
        linkSeries: function () {
            var chart = this,
                chartSeries = chart.series;

            // Reset links
            each(chartSeries, function (series) {
                series.linkedSeries.length = 0;
            });

            // Apply new links
            each(chartSeries, function (series) {
                var linkedTo = series.options.linkedTo;
                if (isString(linkedTo)) {
                    if (linkedTo === ':previous') {
                        linkedTo = chart.series[series.index - 1];
                    } else {
                        linkedTo = chart.get(linkedTo);
                    }
                    if (linkedTo) {
                        linkedTo.linkedSeries.push(series);
                        series.linkedParent = linkedTo;
                        series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible); // #3879
                    }
                }
            });
        },

        /**
         * Render series for the chart
         */
        renderSeries: function () {
            each(this.series, function (serie) {
                serie.translate();
                serie.render();
            });
        },

        /**
         * Render labels for the chart
         */
        renderLabels: function () {
            var chart = this,
                labels = chart.options.labels;
            if (labels.items) {
                each(labels.items, function (label) {
                    var style = extend(labels.style, label.style),
                        x = pInt(style.left) + chart.plotLeft,
                        y = pInt(style.top) + chart.plotTop + 12;

                    // delete to prevent rewriting in IE
                    delete style.left;
                    delete style.top;

                    chart.renderer.text(
                        label.html,
                        x,
                        y
                    )
                    .attr({ zIndex: 2 })
                    .css(style)
                    .add();

                });
            }
        },

        /**
         * Render all graphics for the chart
         */
        render: function () {
            var chart = this,
                axes = chart.axes,
                renderer = chart.renderer,
                options = chart.options,
                tempWidth,
                tempHeight,
                redoHorizontal,
                redoVertical;

            // Title
            chart.setTitle();


            // Legend
            chart.legend = new Legend(chart, options.legend);

            // Get stacks
            if (chart.getStacks) {
                chart.getStacks();
            }

            // Get chart margins
            chart.getMargins(true);
            chart.setChartSize();

            // Record preliminary dimensions for later comparison
            tempWidth = chart.plotWidth;
            tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels

            // Get margins by pre-rendering axes
            each(axes, function (axis) {
                axis.setScale();
            });
            chart.getAxisMargins();

            // If the plot area size has changed significantly, calculate tick positions again
            redoHorizontal = tempWidth / chart.plotWidth > 1.1;
            redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive

            if (redoHorizontal || redoVertical) {

                chart.maxTicks = null; // reset for second pass
                each(axes, function (axis) {
                    if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {
                        axis.setTickInterval(true); // update to reflect the new margins
                    }
                });
                chart.getMargins(); // second pass to check for new labels
            }

            // Draw the borders and backgrounds
            chart.drawChartBox();


            // Axes
            if (chart.hasCartesianSeries) {
                each(axes, function (axis) {
                    if (axis.visible) {
                        axis.render();
                    }
                });
            }

            // The series
            if (!chart.seriesGroup) {
                chart.seriesGroup = renderer.g('series-group')
                    .attr({ zIndex: 3 })
                    .add();
            }
            chart.renderSeries();

            // Labels
            chart.renderLabels();

            // Credits
            chart.showCredits(options.credits);

            // Set flag
            chart.hasRendered = true;

        },

        /**
         * Show chart credits based on config options
         */
        showCredits: function (credits) {
            if (credits.enabled && !this.credits) {
                this.credits = this.renderer.text(
                    credits.text,
                    0,
                    0
                )
                .on('click', function () {
                    if (credits.href) {
                        win.location.href = credits.href;
                    }
                })
                .attr({
                    align: credits.position.align,
                    zIndex: 8
                })
                .css(credits.style)
                .add()
                .align(credits.position);
            }
        },

        /**
         * Clean up memory usage
         */
        destroy: function () {
            var chart = this,
                axes = chart.axes,
                series = chart.series,
                container = chart.container,
                i,
                parentNode = container && container.parentNode;

            // fire the chart.destoy event
            fireEvent(chart, 'destroy');

            // Delete the chart from charts lookup array
            charts[chart.index] = UNDEFINED;
            chartCount--;
            chart.renderTo.removeAttribute('data-highcharts-chart');

            // remove events
            removeEvent(chart);

            // ==== Destroy collections:
            // Destroy axes
            i = axes.length;
            while (i--) {
                axes[i] = axes[i].destroy();
            }

            // Destroy each series
            i = series.length;
            while (i--) {
                series[i] = series[i].destroy();
            }

            // ==== Destroy chart properties:
            each(['title', 'subtitle', 'chartBackground', 'plotBackground', 'plotBGImage',
                    'plotBorder', 'seriesGroup', 'clipRect', 'credits', 'pointer', 'scroller',
                    'rangeSelector', 'legend', 'resetZoomButton', 'tooltip', 'renderer'], function (name) {
                var prop = chart[name];

                if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                }
            });

            // remove container and all SVG
            if (container) { // can break in IE when destroyed before finished loading
                container.innerHTML = '';
                removeEvent(container);
                if (parentNode) {
                    discardElement(container);
                }

            }

            // clean it all up
            for (i in chart) {
                delete chart[i];
            }

        },


        /**
         * VML namespaces can't be added until after complete. Listening
         * for Perini's doScroll hack is not enough.
         */
        isReadyToRender: function () {
            var chart = this;

            // Note: win == win.top is required
            if ((!hasSVG && (win == win.top && doc.readyState !== 'complete')) || (useCanVG && !win.canvg)) { // eslint-disable-line eqeqeq
                if (useCanVG) {
                    // Delay rendering until canvg library is downloaded and ready
                    CanVGController.push(function () {
                        chart.firstRender();
                    }, chart.options.global.canvasToolsURL);
                } else {
                    doc.attachEvent('onreadystatechange', function () {
                        doc.detachEvent('onreadystatechange', chart.firstRender);
                        if (doc.readyState === 'complete') {
                            chart.firstRender();
                        }
                    });
                }
                return false;
            }
            return true;
        },

        /**
         * Prepare for first rendering after all data are loaded
         */
        firstRender: function () {
            var chart = this,
                options = chart.options;

            // Check whether the chart is ready to render
            if (!chart.isReadyToRender()) {
                return;
            }

            // Create the container
            chart.getContainer();

            // Run an early event after the container and renderer are established
            fireEvent(chart, 'init');


            chart.resetMargins();
            chart.setChartSize();

            // Set the common chart properties (mainly invert) from the given series
            chart.propFromSeries();

            // get axes
            chart.getAxes();

            // Initialize the series
            each(options.series || [], function (serieOptions) {
                chart.initSeries(serieOptions);
            });

            chart.linkSeries();

            // Run an event after axes and series are initialized, but before render. At this stage,
            // the series data is indexed and cached in the xData and yData arrays, so we can access
            // those before rendering. Used in Highstock.
            fireEvent(chart, 'beforeRender');

            // depends on inverted and on margins being set
            if (Highcharts.Pointer) {
                chart.pointer = new Pointer(chart, options);
            }

            chart.render();

            // add canvas
            chart.renderer.draw();
        
            // Fire the load event if there are no external images
            if (!chart.renderer.imgCount && chart.onload) {
                chart.onload();
            }

            // If the chart was rendered outside the top container, put it back in (#3679)
            chart.cloneRenderTo(true);

        },

        /** 
         * On chart load
         */
        onload: function () {
            var chart = this;

            // Run callbacks
            each([this.callback].concat(this.callbacks), function (fn) {
                if (fn && chart.index !== undefined) { // Chart destroyed in its own callback (#3600)
                    fn.apply(chart, [chart]);
                }
            });

            fireEvent(chart, 'load');

            // Don't run again
            this.onload = null;
        },

        /**
        * Creates arrays for spacing and margin from given options.
        */
        splashArray: function (target, options) {
            var oVar = options[target],
                tArray = isObject(oVar) ? oVar : [oVar, oVar, oVar, oVar];

            return [pick(options[target + 'Top'], tArray[0]),
                    pick(options[target + 'Right'], tArray[1]),
                    pick(options[target + 'Bottom'], tArray[2]),
                    pick(options[target + 'Left'], tArray[3])];
        }
    }; // end Chart

    var CenteredSeriesMixin = Highcharts.CenteredSeriesMixin = {
        /**
         * Get the center of the pie based on the size and center options relative to the
         * plot area. Borrowed by the polar and gauge series types.
         */
        getCenter: function () {

            var options = this.options,
                chart = this.chart,
                slicingRoom = 2 * (options.slicedOffset || 0),
                handleSlicingRoom,
                plotWidth = chart.plotWidth - 2 * slicingRoom,
                plotHeight = chart.plotHeight - 2 * slicingRoom,
                centerOption = options.center,
                positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],
                smallestSize = mathMin(plotWidth, plotHeight),
                i,
                value;

            for (i = 0; i < 4; ++i) {
                value = positions[i];
                handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));

                // i == 0: centerX, relative to width
                // i == 1: centerY, relative to height
                // i == 2: size, relative to smallestSize
                // i == 3: innerSize, relative to size
                positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +
                    (handleSlicingRoom ? slicingRoom : 0);

            }
            // innerSize cannot be larger than size (#3632)
            if (positions[3] > positions[2]) {
                positions[3] = positions[2];
            }
            return positions;
        }
    };

    /**
     * The Point object and prototype. Inheritable and used as base for PiePoint
     */
    var Point = function () {};
    Point.prototype = {

        /**
         * Initialize the point
         * @param {Object} series The series object containing this point
         * @param {Object} options The data in either number, array or object format
         */
        init: function (series, options, x) {

            var point = this,
                colors;
            point.series = series;
            point.color = series.color; // #3445
            point.applyOptions(options, x);
            point.pointAttr = {};

            if (series.options.colorByPoint) {
                colors = series.options.colors || series.chart.options.colors;
                point.color = point.color || colors[series.colorCounter++];
                // loop back to zero
                if (series.colorCounter === colors.length) {
                    series.colorCounter = 0;
                }
            }

            series.chart.pointCount++;
            return point;
        },
        /**
         * Apply the options containing the x and y data and possible some extra properties.
         * This is called on point init or from point.update.
         *
         * @param {Object} options
         */
        applyOptions: function (options, x) {
            var point = this,
                series = point.series,
                pointValKey = series.options.pointValKey || series.pointValKey;

            options = Point.prototype.optionsToObject.call(this, options);

            // copy options directly to point
            extend(point, options);
            point.options = point.options ? extend(point.options, options) : options;

            // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.
            if (pointValKey) {
                point.y = point[pointValKey];
            }
            point.isNull = point.x === null || !isNumber(point.y, true); // #3571, check for NaN

            // If no x is set by now, get auto incremented value. All points must have an
            // x value, however the y value can be null to create a gap in the series
            if (point.x === undefined && series) {
                if (x === undefined) {
                    point.x = series.autoIncrement(point);
                } else {
                    point.x = x;
                }
            }

            // Write the last point's name to the names array
            if (series.xAxis && series.xAxis.names) {
                series.xAxis.names[point.x] = point.name;
            }

            return point;
        },

        /**
         * Transform number or array configs into objects
         */
        optionsToObject: function (options) {
            var ret = {},
                series = this.series,
                keys = series.options.keys,
                pointArrayMap = keys || series.pointArrayMap || ['y'],
                valueCount = pointArrayMap.length,
                firstItemType,
                i = 0,
                j = 0;

            if (isNumber(options) || options === null) {
                ret[pointArrayMap[0]] = options;

            } else if (isArray(options)) {
                // with leading x value
                if (!keys && options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === 'string') {
                        ret.name = options[0];
                    } else if (firstItemType === 'number') {
                        ret.x = options[0];
                    }
                    i++;
                }
                while (j < valueCount) {
                    if (!keys || options[i] !== undefined) { // Skip undefined positions for keys
                        ret[pointArrayMap[j]] = options[i];
                    }
                    i++;
                    j++;
                }
            } else if (typeof options === 'object') {
                ret = options;

                // This is the fastest way to detect if there are individual point dataLabels that need
                // to be considered in drawDataLabels. These can only occur in object configs.
                if (options.dataLabels) {
                    series._hasPointLabels = true;
                }

                // Same approach as above for markers
                if (options.marker) {
                    series._hasPointMarkers = true;
                }
            }
            return ret;
        },

        /**
         * Destroy a point to clear memory. Its reference still stays in series.data.
         */
        destroy: function () {
            var point = this,
                series = point.series,
                chart = series.chart,
                hoverPoints = chart.hoverPoints,
                prop;

            chart.pointCount--;

            if (hoverPoints) {
                point.setState();
                erase(hoverPoints, point);
                if (!hoverPoints.length) {
                    chart.hoverPoints = null;
                }

            }
            if (point === chart.hoverPoint) {
                point.onMouseOut();
            }

            // remove all events
            if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive
                removeEvent(point);
                point.destroyElements();
            }

            if (point.legendItem) { // pies have legend items
                chart.legend.destroyItem(point);
            }

            for (prop in point) {
                point[prop] = null;
            }


        },

        /**
         * Destroy SVG elements associated with the point
         */
        destroyElements: function () {
            var point = this,
                props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],
                prop,
                i = 6;
            while (i--) {
                prop = props[i];
                if (point[prop]) {
                    point[prop] = point[prop].destroy();
                }
            }
        },

        /**
         * Return the configuration hash needed for the data label and tooltip formatters
         */
        getLabelConfig: function () {
            return {
                x: this.category,
                y: this.y,
                color: this.color,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
            };
        },

        /**
         * Extendable method for formatting each point's tooltip line
         *
         * @return {String} A string to be concatenated in to the common tooltip text
         */
        tooltipFormatter: function (pointFormat) {

            // Insert options for valueDecimals, valuePrefix, and valueSuffix
            var series = this.series,
                seriesTooltipOptions = series.tooltipOptions,
                valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),
                valuePrefix = seriesTooltipOptions.valuePrefix || '',
                valueSuffix = seriesTooltipOptions.valueSuffix || '';

            // Loop over the point array map and replace unformatted values with sprintf formatting markup
            each(series.pointArrayMap || ['y'], function (key) {
                key = '{point.' + key; // without the closing bracket
                if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);
                }
                pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');
            });

            return format(pointFormat, {
                point: this,
                series: this.series
            });
        },

        /**
         * Fire an event on the Point object.
         * @param {String} eventType
         * @param {Object} eventArgs Additional event arguments
         * @param {Function} defaultFunction Default event handler
         */
        firePointEvent: function (eventType, eventArgs, defaultFunction) {
            var point = this,
                series = this.series,
                seriesOptions = series.options;

            // load event handlers on demand to save time on mouseover/out
            if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {
                this.importEvents();
            }

            // add default handler if in selection mode
            if (eventType === 'click' && seriesOptions.allowPointSelect) {
                defaultFunction = function (event) {
                    // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
                    if (point.select) { // Could be destroyed by prior event handlers (#2911)
                        point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                    }
                };
            }

            fireEvent(this, eventType, eventArgs, defaultFunction);
        },
        visible: true
    };/**
     * @classDescription The base function which all other series types inherit from. The data in the series is stored
     * in various arrays.
     *
     * - First, series.options.data contains all the original config options for
     * each point whether added by options or methods like series.addPoint.
     * - Next, series.data contains those values converted to points, but in case the series data length
     * exceeds the cropThreshold, or if the data is grouped, series.data doesn't contain all the points. It
     * only contains the points that have been created on demand.
     * - Then there's series.points that contains all currently visible point objects. In case of cropping,
     * the cropped-away points are not part of this array. The series.points array starts at series.cropStart
     * compared to series.data and series.options.data. If however the series data is grouped, these can't
     * be correlated one to one.
     * - series.xData and series.processedXData contain clean x values, equivalent to series.data and series.points.
     * - series.yData and series.processedYData contain clean x values, equivalent to series.data and series.points.
     *
     * @param {Object} chart
     * @param {Object} options
     */
    var Series = Highcharts.Series = function () {};

    Series.prototype = {

        isCartesian: true,
        type: 'line',
        pointClass: Point,
        sorted: true, // requires the data to be sorted
        requireSorting: true,
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'lineColor',
            'stroke-width': 'lineWidth',
            fill: 'fillColor',
            r: 'radius'
        },
        directTouch: false,
        axisTypes: ['xAxis', 'yAxis'],
        colorCounter: 0,
        parallelArrays: ['x', 'y'], // each point's x and y values are stored in this.xData and this.yData
        init: function (chart, options) {
            var series = this,
                eventType,
                events,
                chartSeries = chart.series,
                sortByIndex = function (a, b) {
                    return pick(a.options.index, a._i) - pick(b.options.index, b._i);
                };

            series.chart = chart;
            series.options = options = series.setOptions(options); // merge with plotOptions
            series.linkedSeries = [];

            // bind the axes
            series.bindAxes();

            // set some variables
            extend(series, {
                name: options.name,
                state: NORMAL_STATE,
                pointAttr: {},
                visible: options.visible !== false, // true by default
                selected: options.selected === true // false by default
            });

            // special
            if (useCanVG) {
                options.animation = false;
            }

            // register event listeners
            events = options.events;
            for (eventType in events) {
                addEvent(series, eventType, events[eventType]);
            }
            if (
                (events && events.click) ||
                (options.point && options.point.events && options.point.events.click) ||
                options.allowPointSelect
            ) {
                chart.runTrackerClick = true;
            }

            series.getColor();
            series.getSymbol();

            // Set the data
            each(series.parallelArrays, function (key) {
                series[key + 'Data'] = [];
            });
            series.setData(options.data, false);

            // Mark cartesian
            if (series.isCartesian) {
                chart.hasCartesianSeries = true;
            }

            // Register it in the chart
            chartSeries.push(series);
            series._i = chartSeries.length - 1;

            // Sort series according to index option (#248, #1123, #2456)
            stableSort(chartSeries, sortByIndex);
            if (this.yAxis) {
                stableSort(this.yAxis.series, sortByIndex);
            }

            each(chartSeries, function (series, i) {
                series.index = i;
                series.name = series.name || 'Series ' + (i + 1);
            });

        },

        /**
         * Set the xAxis and yAxis properties of cartesian series, and register the series
         * in the axis.series array
         */
        bindAxes: function () {
            var series = this,
                seriesOptions = series.options,
                chart = series.chart,
                axisOptions;

            each(series.axisTypes || [], function (AXIS) { // repeat for xAxis and yAxis

                each(chart[AXIS], function (axis) { // loop through the chart's axis objects
                    axisOptions = axis.options;

                    // apply if the series xAxis or yAxis option mathches the number of the
                    // axis, or if undefined, use the first axis
                    if ((seriesOptions[AXIS] === axisOptions.index) ||
                            (seriesOptions[AXIS] !== UNDEFINED && seriesOptions[AXIS] === axisOptions.id) ||
                            (seriesOptions[AXIS] === UNDEFINED && axisOptions.index === 0)) {

                        // register this series in the axis.series lookup
                        axis.series.push(series);

                        // set this series.xAxis or series.yAxis reference
                        series[AXIS] = axis;

                        // mark dirty for redraw
                        axis.isDirty = true;
                    }
                });

                // The series needs an X and an Y axis
                if (!series[AXIS] && series.optionalAxis !== AXIS) {
                    error(18, true);
                }

            });
        },

        /**
         * For simple series types like line and column, the data values are held in arrays like
         * xData and yData for quick lookup to find extremes and more. For multidimensional series
         * like bubble and map, this can be extended with arrays like zData and valueData by
         * adding to the series.parallelArrays array.
         */
        updateParallelArrays: function (point, i) {
            var series = point.series,
                args = arguments,
                fn = isNumber(i) ?
                    // Insert the value in the given position
                    function (key) {
                        var val = key === 'y' && series.toYData ? series.toYData(point) : point[key];
                        series[key + 'Data'][i] = val;
                    } :
                    // Apply the method specified in i with the following arguments as arguments
                    function (key) {
                        Array.prototype[i].apply(series[key + 'Data'], Array.prototype.slice.call(args, 2));
                    };

            each(series.parallelArrays, fn);
        },

        /**
         * Return an auto incremented x value based on the pointStart and pointInterval options.
         * This is only used if an x value is not given for the point that calls autoIncrement.
         */
        autoIncrement: function (point) {

            var options = this.options,
                xIncrement = this.xIncrement,
                date,
                pointInterval,
                pointIntervalUnit = options.pointIntervalUnit,
                xAxis = this.xAxis,
                explicitCategories,
                names,
                nameX;

            xIncrement = pick(xIncrement, options.pointStart, 0);

            this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);

            // When a point name is given and no x, search for the name in the existing categories,
            // or if categories aren't provided, search names or create a new category (#2522).
            if (xAxis && xAxis.categories && point.name) {
                this.requireSorting = false;
                explicitCategories = isArray(xAxis.categories);
                names = explicitCategories ? xAxis.categories : xAxis.names;
                nameX = inArray(point.name, names); // #2522
                if (nameX === -1) { // The name is not found in currenct categories
                    if (!explicitCategories) {
                        xIncrement = names.length;
                    }
                } else {
                    xIncrement = nameX;
                }
            }

            // Added code for pointInterval strings
            if (pointIntervalUnit) {
                date = new Date(xIncrement);

                if (pointIntervalUnit === 'day') {
                    date = +date[setDate](date[getDate]() + pointInterval);
                } else if (pointIntervalUnit === 'month') {
                    date = +date[setMonth](date[getMonth]() + pointInterval);
                } else if (pointIntervalUnit === 'year') {
                    date = +date[setFullYear](date[getFullYear]() + pointInterval);
                }
                pointInterval = date - xIncrement;
            }

            this.xIncrement = xIncrement + pointInterval;
            return xIncrement;
        },
    
        /**
         * Set the series options by merging from the options tree
         * @param {Object} itemOptions
         */
        setOptions: function (itemOptions) {
            var chart = this.chart,
                chartOptions = chart.options,
                plotOptions = chartOptions.plotOptions,
                userOptions = chart.userOptions || {},
                userPlotOptions = userOptions.plotOptions || {},
                typeOptions = plotOptions[this.type],
                options,
                zones;

            this.userOptions = itemOptions;

            // General series options take precedence over type options because otherwise, default
            // type options like column.animation would be overwritten by the general option.
            // But issues have been raised here (#3881), and the solution may be to distinguish
            // between default option and userOptions like in the tooltip below.
            options = merge(
                typeOptions,
                plotOptions.series,
                itemOptions
            );

            // The tooltip options are merged between global and series specific options
            this.tooltipOptions = merge(
                defaultOptions.tooltip,
                defaultOptions.plotOptions[this.type].tooltip,
                userOptions.tooltip,
                userPlotOptions.series && userPlotOptions.series.tooltip,
                userPlotOptions[this.type] && userPlotOptions[this.type].tooltip,
                itemOptions.tooltip
            );

            // Delete marker object if not allowed (#1125)
            if (typeOptions.marker === null) {
                delete options.marker;
            }

            // Handle color zones
            this.zoneAxis = options.zoneAxis;
            zones = this.zones = (options.zones || []).slice();
            if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
                zones.push({
                    value: options[this.zoneAxis + 'Threshold'] || options.threshold || 0,
                    color: options.negativeColor,
                    fillColor: options.negativeFillColor
                });
            }
            if (zones.length) { // Push one extra zone for the rest
                if (defined(zones[zones.length - 1].value)) {
                    zones.push({
                        color: this.color,
                        fillColor: this.fillColor
                    });
                }
            }
            return options;
        },

        getCyclic: function (prop, value, defaults) {
            var i,
                userOptions = this.userOptions,
                indexName = '_' + prop + 'Index',
                counterName = prop + 'Counter';

            if (!value) {
                if (defined(userOptions[indexName])) { // after Series.update()
                    i = userOptions[indexName];
                } else {
                    userOptions[indexName] = i = this.chart[counterName] % defaults.length;
                    this.chart[counterName] += 1;
                }
                value = defaults[i];
            }
            this[prop] = value;
        },

        /**
         * Get the series' color
         */
        getColor: function () {
            if (this.options.colorByPoint) {
                this.options.color = null; // #4359, selected slice got series.color even when colorByPoint was set.
            } else {
                this.getCyclic('color', this.options.color || defaultPlotOptions[this.type].color, this.chart.options.colors);
            }
        },
        /**
         * Get the series' symbol
         */
        getSymbol: function () {
            var seriesMarkerOption = this.options.marker;

            this.getCyclic('symbol', seriesMarkerOption.symbol, this.chart.options.symbols);

            // don't substract radius in image symbols (#604)
            if (/^url/.test(this.symbol)) {
                seriesMarkerOption.radius = 0;
            }
        },

        drawLegendSymbol: LegendSymbolMixin.drawLineMarker,

        /**
         * Replace the series data with a new set of data
         * @param {Object} data
         * @param {Object} redraw
         */
        setData: function (data, redraw, animation, updatePoints) {
            var series = this,
                oldData = series.points,
                oldDataLength = (oldData && oldData.length) || 0,
                dataLength,
                options = series.options,
                chart = series.chart,
                firstPoint = null,
                xAxis = series.xAxis,
                i,
                turboThreshold = options.turboThreshold,
                pt,
                xData = this.xData,
                yData = this.yData,
                pointArrayMap = series.pointArrayMap,
                valueCount = pointArrayMap && pointArrayMap.length;

            data = data || [];
            dataLength = data.length;
            redraw = pick(redraw, true);

            // If the point count is the same as is was, just run Point.update which is
            // cheaper, allows animation, and keeps references to points.
            if (updatePoints !== false && dataLength && oldDataLength === dataLength && !series.cropped && !series.hasGroupedData && series.visible) {
                each(data, function (point, i) {
                    // .update doesn't exist on a linked, hidden series (#3709)
                    if (oldData[i].update && point !== options.data[i]) {
                        oldData[i].update(point, false, null, false);
                    }
                });

            } else {

                // Reset properties
                series.xIncrement = null;

                series.colorCounter = 0; // for series with colorByPoint (#1547)

                // Update parallel arrays
                each(this.parallelArrays, function (key) {
                    series[key + 'Data'].length = 0;
                });

                // In turbo mode, only one- or twodimensional arrays of numbers are allowed. The
                // first value is tested, and we assume that all the rest are defined the same
                // way. Although the 'for' loops are similar, they are repeated inside each
                // if-else conditional for max performance.
                if (turboThreshold && dataLength > turboThreshold) {

                    // find the first non-null point
                    i = 0;
                    while (firstPoint === null && i < dataLength) {
                        firstPoint = data[i];
                        i++;
                    }


                    if (isNumber(firstPoint)) { // assume all points are numbers
                        var x = pick(options.pointStart, 0),
                            pointInterval = pick(options.pointInterval, 1);

                        for (i = 0; i < dataLength; i++) {
                            xData[i] = x;
                            yData[i] = data[i];
                            x += pointInterval;
                        }
                        series.xIncrement = x;
                    } else if (isArray(firstPoint)) { // assume all points are arrays
                        if (valueCount) { // [x, low, high] or [x, o, h, l, c]
                            for (i = 0; i < dataLength; i++) {
                                pt = data[i];
                                xData[i] = pt[0];
                                yData[i] = pt.slice(1, valueCount + 1);
                            }
                        } else { // [x, y]
                            for (i = 0; i < dataLength; i++) {
                                pt = data[i];
                                xData[i] = pt[0];
                                yData[i] = pt[1];
                            }
                        }
                    } else {
                        error(12); // Highcharts expects configs to be numbers or arrays in turbo mode
                    }
                } else {
                    for (i = 0; i < dataLength; i++) {
                        if (data[i] !== UNDEFINED) { // stray commas in oldIE
                            pt = { series: series };
                            series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                            series.updateParallelArrays(pt, i);
                        }
                    }
                }

                // Forgetting to cast strings to numbers is a common caveat when handling CSV or JSON
                if (isString(yData[0])) {
                    error(14, true);
                }

                series.data = [];
                series.options.data = series.userOptions.data = data;

                // destroy old points
                i = oldDataLength;
                while (i--) {
                    if (oldData[i] && oldData[i].destroy) {
                        oldData[i].destroy();
                    }
                }

                // reset minRange (#878)
                if (xAxis) {
                    xAxis.minRange = xAxis.userMinRange;
                }

                // redraw
                series.isDirty = series.isDirtyData = chart.isDirtyBox = true;
                animation = false;
            }

            // Typically for pie series, points need to be processed and generated
            // prior to rendering the legend
            if (options.legendType === 'point') {
                this.processData();
                this.generatePoints();
            }

            if (redraw) {
                chart.redraw(animation);
            }
        },

        /**
         * Process the data by cropping away unused data points if the series is longer
         * than the crop threshold. This saves computing time for lage series.
         */
        processData: function (force) {
            var series = this,
                processedXData = series.xData, // copied during slice operation below
                processedYData = series.yData,
                dataLength = processedXData.length,
                croppedData,
                cropStart = 0,
                cropped,
                distance,
                closestPointRange,
                xAxis = series.xAxis,
                i, // loop variable
                options = series.options,
                cropThreshold = options.cropThreshold,
                getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll, // #4599
                isCartesian = series.isCartesian,
                xExtremes,
                val2lin = xAxis && xAxis.val2lin,
                isLog = xAxis && xAxis.isLog,
                min,
                max;

            // If the series data or axes haven't changed, don't go through this. Return false to pass
            // the message on to override methods like in data grouping.
            if (isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                return false;
            }

            if (xAxis) {
                xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)
                min = xExtremes.min;
                max = xExtremes.max;
            }

            // optionally filter out points outside the plot area
            if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {

                // it's outside current extremes
                if (processedXData[dataLength - 1] < min || processedXData[0] > max) {
                    processedXData = [];
                    processedYData = [];

                // only crop if it's actually spilling out
                } else if (processedXData[0] < min || processedXData[dataLength - 1] > max) {
                    croppedData = this.cropData(series.xData, series.yData, min, max);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                }
            }


            // Find the closest distance between processed points
            i = processedXData.length || 1;
            while (--i) {
                distance = isLog ?
                    val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :
                    processedXData[i] - processedXData[i - 1];

                if (distance > 0 && (closestPointRange === UNDEFINED || distance < closestPointRange)) {
                    closestPointRange = distance;

                // Unsorted data is not supported by the line tooltip, as well as data grouping and
                // navigation in Stock charts (#725) and width calculation of columns (#1900)
                } else if (distance < 0 && series.requireSorting) {
                    error(15);
                }
            }

            // Record the properties
            series.cropped = cropped; // undefined or true
            series.cropStart = cropStart;
            series.processedXData = processedXData;
            series.processedYData = processedYData;

            series.closestPointRange = closestPointRange;

        },

        /**
         * Iterate over xData and crop values between min and max. Returns object containing crop start/end
         * cropped xData with corresponding part of yData, dataMin and dataMax within the cropped range
         */
        cropData: function (xData, yData, min, max) {
            var dataLength = xData.length,
                cropStart = 0,
                cropEnd = dataLength,
                cropShoulder = pick(this.cropShoulder, 1), // line-type series need one point outside
                i,
                j;

            // iterate up to find slice start
            for (i = 0; i < dataLength; i++) {
                if (xData[i] >= min) {
                    cropStart = mathMax(0, i - cropShoulder);
                    break;
                }
            }

            // proceed to find slice end
            for (j = i; j < dataLength; j++) {
                if (xData[j] > max) {
                    cropEnd = j + cropShoulder;
                    break;
                }
            }

            return {
                xData: xData.slice(cropStart, cropEnd),
                yData: yData.slice(cropStart, cropEnd),
                start: cropStart,
                end: cropEnd
            };
        },


        /**
         * Generate the data point after the data has been processed by cropping away
         * unused points and optionally grouped in Highcharts Stock.
         */
        generatePoints: function () {
            var series = this,
                options = series.options,
                dataOptions = options.data,
                data = series.data,
                dataLength,
                processedXData = series.processedXData,
                processedYData = series.processedYData,
                pointClass = series.pointClass,
                processedDataLength = processedXData.length,
                cropStart = series.cropStart || 0,
                cursor,
                hasGroupedData = series.hasGroupedData,
                point,
                points = [],
                i;

            if (!data && !hasGroupedData) {
                var arr = [];
                arr.length = dataOptions.length;
                data = series.data = arr;
            }

            for (i = 0; i < processedDataLength; i++) {
                cursor = cropStart + i;
                if (!hasGroupedData) {
                    if (data[cursor]) {
                        point = data[cursor];
                    } else if (dataOptions[cursor] !== UNDEFINED) { // #970
                        data[cursor] = point = (new pointClass()).init(series, dataOptions[cursor], processedXData[i]);
                    }
                    points[i] = point;
                } else {
                    // splat the y data in case of ohlc data array
                    points[i] = (new pointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
                    points[i].dataGroup = series.groupMap[i];
                }
                points[i].index = cursor; // For faster access in Point.update
            }

            // Hide cropped-away points - this only runs when the number of points is above cropThreshold, or when
            // swithching view from non-grouped data to grouped data (#637)
            if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                for (i = 0; i < dataLength; i++) {
                    if (i === cropStart && !hasGroupedData) { // when has grouped data, clear all points
                        i += processedDataLength;
                    }
                    if (data[i]) {
                        data[i].destroyElements();
                        data[i].plotX = UNDEFINED; // #1003
                    }
                }
            }

            series.data = data;
            series.points = points;
        },

        /**
         * Calculate Y extremes for visible data
         */
        getExtremes: function (yData) {
            var xAxis = this.xAxis,
                yAxis = this.yAxis,
                xData = this.processedXData,
                yDataLength,
                activeYData = [],
                activeCounter = 0,
                xExtremes = xAxis.getExtremes(), // #2117, need to compensate for log X axis
                xMin = xExtremes.min,
                xMax = xExtremes.max,
                validValue,
                withinRange,
                x,
                y,
                i,
                j;

            yData = yData || this.stackedYData || this.processedYData || [];
            yDataLength = yData.length;

            for (i = 0; i < yDataLength; i++) {

                x = xData[i];
                y = yData[i];

                // For points within the visible range, including the first point outside the
                // visible range, consider y extremes
                validValue = y !== null && y !== UNDEFINED && (!yAxis.isLog || (y.length || y > 0));
                withinRange = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped ||
                    ((xData[i + 1] || x) >= xMin &&    (xData[i - 1] || x) <= xMax);

                if (validValue && withinRange) {

                    j = y.length;
                    if (j) { // array, like ohlc or range data
                        while (j--) {
                            if (y[j] !== null) {
                                activeYData[activeCounter++] = y[j];
                            }
                        }
                    } else {
                        activeYData[activeCounter++] = y;
                    }
                }
            }
            this.dataMin = arrayMin(activeYData);
            this.dataMax = arrayMax(activeYData);
        },

        /**
         * Translate data points from raw data values to chart specific positioning data
         * needed later in drawPoints, drawGraph and drawTracker.
         */
        translate: function () {
            if (!this.processedXData) { // hidden series
                this.processData();
            }
            this.generatePoints();
            var series = this,
                options = series.options,
                stacking = options.stacking,
                xAxis = series.xAxis,
                categories = xAxis.categories,
                yAxis = series.yAxis,
                points = series.points,
                dataLength = points.length,
                hasModifyValue = !!series.modifyValue,
                i,
                pointPlacement = options.pointPlacement,
                dynamicallyPlaced = pointPlacement === 'between' || isNumber(pointPlacement),
                threshold = options.threshold,
                stackThreshold = options.startFromThreshold ? threshold : 0,
                plotX,
                plotY,
                lastPlotX,
                stackIndicator,
                closestPointRangePx = Number.MAX_VALUE;

            // Translate each point
            for (i = 0; i < dataLength; i++) {
                var point = points[i],
                    xValue = point.x,
                    yValue = point.y,
                    yBottom = point.low,
                    stack = stacking && yAxis.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? '-' : '') + series.stackKey],
                    pointStack,
                    stackValues;

                // Discard disallowed y values for log axes (#3434)
                if (yAxis.isLog && yValue !== null && yValue <= 0) {
                    point.y = yValue = null;
                    error(10);
                }

                // Get the plotX translation
                point.plotX = plotX = correctFloat( // #5236
                    mathMin(mathMax(-1e5, xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement, this.type === 'flags')), 1e5) // #3923
                );

                // Calculate the bottom y value for stacked series
                if (stacking && series.visible && !point.isNull && stack && stack[xValue]) {
                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                    pointStack = stack[xValue];
                    stackValues = pointStack.points[stackIndicator.key];
                    yBottom = stackValues[0];
                    yValue = stackValues[1];

                    if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
                        yBottom = pick(threshold, yAxis.min);
                    }
                    if (yAxis.isLog && yBottom <= 0) { // #1200, #1232
                        yBottom = null;
                    }

                    point.total = point.stackTotal = pointStack.total;
                    point.percentage = pointStack.total && (point.y / pointStack.total * 100);
                    point.stackY = yValue;

                    // Place the stack label
                    pointStack.setOffset(series.pointXOffset || 0, series.barW || 0);

                }

                // Set translated yBottom or remove it
                point.yBottom = defined(yBottom) ?
                    yAxis.translate(yBottom, 0, 1, 0, 1) :
                    null;

                // general hook, used for Highstock compare mode
                if (hasModifyValue) {
                    yValue = series.modifyValue(yValue, point);
                }

                // Set the the plotY value, reset it for redraws
                point.plotY = plotY = (typeof yValue === 'number' && yValue !== Infinity) ?
                    mathMin(mathMax(-1e5, yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201
                    UNDEFINED;
                point.isInside = plotY !== UNDEFINED && plotY >= 0 && plotY <= yAxis.len && // #3519
                    plotX >= 0 && plotX <= xAxis.len;


                // Set client related positions for mouse tracking
                point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1)) : plotX; // #1514

                point.negative = point.y < (threshold || 0);

                // some API data
                point.category = categories && categories[point.x] !== UNDEFINED ?
                    categories[point.x] : point.x;

                // Determine auto enabling of markers (#3635, #5099)
                if (!point.isNull) {
                    if (lastPlotX !== undefined) {
                        closestPointRangePx = mathMin(closestPointRangePx, mathAbs(plotX - lastPlotX));
                    }
                    lastPlotX = plotX;
                }

            }
            series.closestPointRangePx = closestPointRangePx;
        },

        /**
         * Return the series points with null points filtered out
         */
        getValidPoints: function (points, insideOnly) {
            var chart = this.chart;
            return grep(points || this.points || [], function isValidPoint(point) { // #3916, #5029
                if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) { // #5085
                    return false;
                }
                return !point.isNull;
            });
        },

        /**
         * Set the clipping for the series. For animated series it is called twice, first to initiate
         * animating the clip then the second time without the animation to set the final clip.
         */
        setClip: function (animation) {
            var chart = this.chart,
                options = this.options,
                renderer = chart.renderer,
                inverted = chart.inverted,
                seriesClipBox = this.clipBox,
                clipBox = seriesClipBox || chart.clipBox,
                sharedClipKey = this.sharedClipKey || ['_sharedClip', animation && animation.duration, animation && animation.easing, clipBox.height, options.xAxis, options.yAxis].join(','), // #4526
                clipRect = chart[sharedClipKey],
                markerClipRect = chart[sharedClipKey + 'm'];

            // If a clipping rectangle with the same properties is currently present in the chart, use that.
            if (!clipRect) {

                // When animation is set, prepare the initial positions
                if (animation) {
                    clipBox.width = 0;

                    chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(
                        -99, // include the width of the first marker
                        inverted ? -chart.plotLeft : -chart.plotTop,
                        99,
                        inverted ? chart.chartWidth : chart.chartHeight
                    );
                }
                chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
                // Create hashmap for series indexes
                clipRect.count = { length: 0 };

            }
            if (animation) {
                if (!clipRect.count[this.index]) {
                    clipRect.count[this.index] = true;
                    clipRect.count.length += 1;
                }
            }

            if (options.clip !== false) {
                this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
                this.markerGroup.clip(markerClipRect);
                this.sharedClipKey = sharedClipKey;
            }

            // Remove the shared clipping rectangle when all series are shown
            if (!animation) {
                if (clipRect.count[this.index]) {
                    delete clipRect.count[this.index];
                    clipRect.count.length -= 1;
                }

                if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {
                    if (!seriesClipBox) {
                        chart[sharedClipKey] = chart[sharedClipKey].destroy();
                    }
                    if (chart[sharedClipKey + 'm']) {
                        chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();
                    }
                }
            }
        },

        /**
         * Animate in the series
         */
        animate: function (init) {
            var series = this,
                chart = series.chart,
                clipRect,
                animation = series.options.animation,
                sharedClipKey;

            // Animation option is set to true
            if (animation && !isObject(animation)) {
                animation = defaultPlotOptions[series.type].animation;
            }

            // Initialize the animation. Set up the clipping rectangle.
            if (init) {

                series.setClip(animation);

            // Run the animation
            } else {
                sharedClipKey = this.sharedClipKey;
                clipRect = chart[sharedClipKey];
                if (clipRect) {
                    clipRect.animate({
                        width: chart.plotSizeX
                    }, animation);
                }
                if (chart[sharedClipKey + 'm']) {
                    chart[sharedClipKey + 'm'].animate({
                        width: chart.plotSizeX + 99
                    }, animation);
                }

                // Delete this function to allow it only once
                series.animate = null;

            }
        },

        /**
         * This runs after animation to land on the final plot clipping
         */
        afterAnimate: function () {
            this.setClip();
            fireEvent(this, 'afterAnimate');
        },

        /**
         * Draw the markers
         */
        drawPoints: function () {
            var series = this,
                pointAttr,
                points = series.points,
                chart = series.chart,
                plotX,
                plotY,
                i,
                point,
                radius,
                symbol,
                isImage,
                graphic,
                options = series.options,
                seriesMarkerOptions = options.marker,
                seriesPointAttr = series.pointAttr[''],
                pointMarkerOptions,
                hasPointMarker,
                enabled,
                isInside,
                markerGroup = series.markerGroup,
                xAxis = series.xAxis,
                globallyEnabled = pick(
                    seriesMarkerOptions.enabled,
                    xAxis.isRadial,
                    series.closestPointRangePx > 2 * seriesMarkerOptions.radius
                );

            if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {

                i = points.length;
                while (i--) {
                    point = points[i];
                    plotX = mathFloor(point.plotX); // #1843
                    plotY = point.plotY;
                    graphic = point.graphic;
                    pointMarkerOptions = point.marker || {};
                    hasPointMarker = !!point.marker;
                    enabled = (globallyEnabled && pointMarkerOptions.enabled === UNDEFINED) || pointMarkerOptions.enabled;
                    isInside = point.isInside;

                    // only draw the point if y is defined
                    if (enabled && isNumber(plotY) && point.y !== null) {

                        // shortcuts
                        pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || seriesPointAttr;
                        radius = pointAttr.r;
                        symbol = pick(pointMarkerOptions.symbol, series.symbol);
                        isImage = symbol.indexOf('url') === 0;

                        if (graphic) { // update
                            graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled
                                .attr(pointAttr) // #4759
                                .animate(extend({
                                    x: plotX - radius,
                                    y: plotY - radius
                                }, graphic.symbolName ? { // don't apply to image symbols #507
                                    width: 2 * radius,
                                    height: 2 * radius
                                } : {}));
                        } else if (isInside && (radius > 0 || isImage)) {
                            point.graphic = graphic = chart.renderer.symbol(
                                symbol,
                                plotX - radius,
                                plotY - radius,
                                2 * radius,
                                2 * radius,
                                hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
                            )
                            .attr(pointAttr)
                            .add(markerGroup);
                        }

                    } else if (graphic) {
                        point.graphic = graphic.destroy(); // #1269
                    }
                }
            }

        },

        /**
         * Convert state properties from API naming conventions to SVG attributes
         *
         * @param {Object} options API options object
         * @param {Object} base1 SVG attribute object to inherit from
         * @param {Object} base2 Second level SVG attribute object to inherit from
         */
        convertAttribs: function (options, base1, base2, base3) {
            var conversion = this.pointAttrToOptions,
                attr,
                option,
                obj = {};

            options = options || {};
            base1 = base1 || {};
            base2 = base2 || {};
            base3 = base3 || {};

            for (attr in conversion) {
                option = conversion[attr];
                obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);
            }
            return obj;
        },

        /**
         * Get the state attributes. Each series type has its own set of attributes
         * that are allowed to change on a point's state change. Series wide attributes are stored for
         * all series, and additionally point specific attributes are stored for all
         * points with individual marker options. If such options are not defined for the point,
         * a reference to the series wide attributes is stored in point.pointAttr.
         */
        getAttribs: function () {
            var series = this,
                seriesOptions = series.options,
                normalOptions = defaultPlotOptions[series.type].marker ? seriesOptions.marker : seriesOptions,
                stateOptions = normalOptions.states,
                stateOptionsHover = stateOptions[HOVER_STATE],
                pointStateOptionsHover,
                seriesColor = series.color,
                seriesNegativeColor = series.options.negativeColor,
                normalDefaults = {
                    stroke: seriesColor,
                    fill: seriesColor
                },
                points = series.points || [], // #927
                i,
                j,
                threshold,
                point,
                seriesPointAttr = [],
                pointAttr,
                pointAttrToOptions = series.pointAttrToOptions,
                hasPointSpecificOptions = series.hasPointSpecificOptions,
                defaultLineColor = normalOptions.lineColor,
                defaultFillColor = normalOptions.fillColor,
                turboThreshold = seriesOptions.turboThreshold,
                zones = series.zones,
                zoneAxis = series.zoneAxis || 'y',
                zoneColor, 
                attr,
                key;

            // series type specific modifications
            if (seriesOptions.marker) { // line, spline, area, areaspline, scatter

                // if no hover radius is given, default to normal radius + 2
                stateOptionsHover.radius = +stateOptionsHover.radius || +normalOptions.radius + +stateOptionsHover.radiusPlus;
                stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + stateOptionsHover.lineWidthPlus;

            } else { // column, bar, pie

                // if no hover color is given, brighten the normal color
                stateOptionsHover.color = stateOptionsHover.color ||
                    Color(stateOptionsHover.color || seriesColor)
                        .brighten(stateOptionsHover.brightness).get();

                // if no hover negativeColor is given, brighten the normal negativeColor
                stateOptionsHover.negativeColor = stateOptionsHover.negativeColor ||
                    Color(stateOptionsHover.negativeColor || seriesNegativeColor)
                        .brighten(stateOptionsHover.brightness).get();
            }

            // general point attributes for the series normal state
            seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

            // HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
            each([HOVER_STATE, SELECT_STATE], function (state) {
                seriesPointAttr[state] =
                        series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
            });

            // set it
            series.pointAttr = seriesPointAttr;


            // Generate the point-specific attribute collections if specific point
            // options are given. If not, create a referance to the series wide point
            // attributes
            i = points.length;
            if (!turboThreshold || i < turboThreshold || hasPointSpecificOptions) {
                while (i--) {
                    point = points[i];
                    normalOptions = (point.options && point.options.marker) || point.options;
                    if (normalOptions && normalOptions.enabled === false) {
                        normalOptions.radius = 0;
                    }

                    zoneColor = null;
                    if (zones.length) {
                        j = 0;
                        threshold = zones[j];
                        while (point[zoneAxis] >= threshold.value) {
                            threshold = zones[++j];
                        }

                        point.color = point.fillColor = zoneColor = pick(threshold.color, series.color); // #3636, #4267, #4430 - inherit color from series, when color is undefined

                    }

                    hasPointSpecificOptions = seriesOptions.colorByPoint || point.color; // #868

                    // check if the point has specific visual options
                    if (point.options) {
                        for (key in pointAttrToOptions) {
                            if (defined(normalOptions[pointAttrToOptions[key]])) {
                                hasPointSpecificOptions = true;
                            }
                        }
                    }

                    // a specific marker config object is defined for the individual point:
                    // create it's own attribute collection
                    if (hasPointSpecificOptions) {
                        normalOptions = normalOptions || {};
                        pointAttr = [];
                        stateOptions = normalOptions.states || {}; // reassign for individual point
                        pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

                        // Handle colors for column and pies
                        if (!seriesOptions.marker || (point.negative && !pointStateOptionsHover.fillColor && !stateOptionsHover.fillColor)) { // column, bar, point or negative threshold for series with markers (#3636)
                            // If no hover color is given, brighten the normal color. #1619, #2579
                            pointStateOptionsHover[series.pointAttrToOptions.fill] = pointStateOptionsHover.color || (!point.options.color && stateOptionsHover[(point.negative && seriesNegativeColor ? 'negativeColor' : 'color')]) ||
                                Color(point.color)
                                    .brighten(pointStateOptionsHover.brightness || stateOptionsHover.brightness)
                                    .get();
                        }

                        // normal point state inherits series wide normal state
                        attr = { color: point.color }; // #868
                        if (!defaultFillColor) { // Individual point color or negative color markers (#2219)
                            attr.fillColor = point.color;
                        }
                        if (!defaultLineColor) {
                            attr.lineColor = point.color; // Bubbles take point color, line markers use white
                        }
                        // Color is explicitly set to null or undefined (#1288, #4068)
                        if (normalOptions.hasOwnProperty('color') && !normalOptions.color) {
                            delete normalOptions.color;
                        }

                        // When zone is set, but series.states.hover.color is not set, apply zone color on hover, #4670: 
                        if (zoneColor && !stateOptionsHover.fillColor) {
                            pointStateOptionsHover.fillColor = zoneColor;
                        }

                        pointAttr[NORMAL_STATE] = series.convertAttribs(extend(attr, normalOptions), seriesPointAttr[NORMAL_STATE]);

                        // inherit from point normal and series hover
                        pointAttr[HOVER_STATE] = series.convertAttribs(
                            stateOptions[HOVER_STATE],
                            seriesPointAttr[HOVER_STATE],
                            pointAttr[NORMAL_STATE]
                        );

                        // inherit from point normal and series hover
                        pointAttr[SELECT_STATE] = series.convertAttribs(
                            stateOptions[SELECT_STATE],
                            seriesPointAttr[SELECT_STATE],
                            pointAttr[NORMAL_STATE]
                        );


                    // no marker config object is created: copy a reference to the series-wide
                    // attribute collection
                    } else {
                        pointAttr = seriesPointAttr;
                    }

                    point.pointAttr = pointAttr;
                }
            }
        },

        /**
         * Clear DOM objects and free up memory
         */
        destroy: function () {
            var series = this,
                chart = series.chart,
                issue134 = /AppleWebKit\/533/.test(userAgent),
                destroy,
                i,
                data = series.data || [],
                point,
                prop,
                axis;

            // add event hook
            fireEvent(series, 'destroy');

            // remove all events
            removeEvent(series);

            // erase from axes
            each(series.axisTypes || [], function (AXIS) {
                axis = series[AXIS];
                if (axis) {
                    erase(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                }
            });

            // remove legend items
            if (series.legendItem) {
                series.chart.legend.destroyItem(series);
            }

            // destroy all points with their elements
            i = data.length;
            while (i--) {
                point = data[i];
                if (point && point.destroy) {
                    point.destroy();
                }
            }
            series.points = null;

            // Clear the animation timeout if we are destroying the series during initial animation
            clearTimeout(series.animationTimeout);

            // Destroy all SVGElements associated to the series
            for (prop in series) {
                if (series[prop] instanceof SVGElement && !series[prop].survive) { // Survive provides a hook for not destroying

                    // issue 134 workaround
                    destroy = issue134 && prop === 'group' ?
                        'hide' :
                        'destroy';

                    series[prop][destroy]();
                }
            }

            // remove from hoverSeries
            if (chart.hoverSeries === series) {
                chart.hoverSeries = null;
            }
            erase(chart.series, series);

            // clear all members
            for (prop in series) {
                delete series[prop];
            }
        },

        /**
         * Get the graph path
         */
        getGraphPath: function (points, nullsAsZeroes, connectCliffs) {
            var series = this,
                options = series.options,
                step = options.step,
                reversed,
                graphPath = [],
                xMap = [],
                gap;

            points = points || series.points;

            // Bottom of a stack is reversed
            reversed = points.reversed;
            if (reversed) {
                points.reverse();
            }
            // Reverse the steps (#5004)
            step = { right: 1, center: 2 }[step] || (step && 3);
            if (step && reversed) {
                step = 4 - step;
            }

            // Remove invalid points, especially in spline (#5015)
            if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {
                points = this.getValidPoints(points);
            }

            // Build the line
            each(points, function (point, i) {

                var plotX = point.plotX,
                    plotY = point.plotY,
                    lastPoint = points[i - 1],
                    pathToPoint; // the path to this point from the previous

                if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {
                    gap = true; // ... and continue
                }

                // Line series, nullsAsZeroes is not handled
                if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
                    gap = !options.connectNulls;

                // Area series, nullsAsZeroes is set
                } else if (point.isNull && !nullsAsZeroes) {
                    gap = true;

                } else {

                    if (i === 0 || gap) {
                        pathToPoint = [M, point.plotX, point.plotY];
                
                    } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
                    
                        pathToPoint = series.getPointSpline(points, point, i);

                    } else if (step) {

                        if (step === 1) { // right
                            pathToPoint = [
                                L,
                                lastPoint.plotX,
                                plotY
                            ];
                        
                        } else if (step === 2) { // center
                            pathToPoint = [
                                L,
                                (lastPoint.plotX + plotX) / 2,
                                lastPoint.plotY,
                                L,
                                (lastPoint.plotX + plotX) / 2,
                                plotY
                            ];
                        
                        } else {
                            pathToPoint = [
                                L,
                                plotX,
                                lastPoint.plotY
                            ];
                        }
                        pathToPoint.push(L, plotX, plotY);

                    } else {
                        // normal line to next point
                        pathToPoint = [
                            L,
                            plotX,
                            plotY
                        ];
                    }

                    // Prepare for animation. When step is enabled, there are two path nodes for each x value.
                    xMap.push(point.x);
                    if (step) {
                        xMap.push(point.x);
                    }

                    graphPath.push.apply(graphPath, pathToPoint);
                    gap = false;
                }
            });

            graphPath.xMap = xMap;
            series.graphPath = graphPath;

            return graphPath;

        },

        /**
         * Draw the actual graph
         */
        drawGraph: function () {
            var series = this,
                options = this.options,
                props = [['graph', options.lineColor || this.color, options.dashStyle]],
                lineWidth = options.lineWidth,
                roundCap = options.linecap !== 'square',
                graphPath = (this.gappedPath || this.getGraphPath).call(this),
                zones = this.zones;

            each(zones, function (threshold, i) {
                props.push(['zoneGraph' + i, threshold.color || series.color, threshold.dashStyle || options.dashStyle]);
            });

            // Draw the graph
            each(props, function (prop, i) {
                var graphKey = prop[0],
                    graph = series[graphKey],
                    attribs;

                if (graph) {
                    graph.endX = graphPath.xMap;
                    graph.animate({ d: graphPath });

                } else if (lineWidth && graphPath.length) { // #1487
                    attribs = {
                        stroke: prop[1],
                        'stroke-width': lineWidth,
                        fill: 'none',
                        zIndex: 1 // #1069
                    };
                    if (prop[2]) {
                        attribs.dashstyle = prop[2];
                    } else if (roundCap) {
                        attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';
                    }

                    graph = series[graphKey] = series.chart.renderer.path(graphPath)
                        .attr(attribs)
                        .add(series.group)
                        .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932
                }

                // Helpers for animation
                if (graph) {
                    graph.startX = graphPath.xMap;
                    //graph.shiftUnit = options.step ? 2 : 1;
                    graph.isArea = graphPath.isArea; // For arearange animation
                }
            });
        },

        /**
         * Clip the graphs into the positive and negative coloured graphs
         */
        applyZones: function () {
            var series = this,
                chart = this.chart,
                renderer = chart.renderer,
                zones = this.zones,
                translatedFrom,
                translatedTo,
                clips = this.clips || [],
                clipAttr,
                graph = this.graph,
                area = this.area,
                chartSizeMax = mathMax(chart.chartWidth, chart.chartHeight),
                axis = this[(this.zoneAxis || 'y') + 'Axis'],
                extremes,
                reversed = axis.reversed,
                inverted = chart.inverted,
                horiz = axis.horiz,
                pxRange,
                pxPosMin,
                pxPosMax,
                ignoreZones = false;

            if (zones.length && (graph || area) && axis.min !== UNDEFINED) {
                // The use of the Color Threshold assumes there are no gaps
                // so it is safe to hide the original graph and area
                if (graph) {
                    graph.hide();
                }
                if (area) {
                    area.hide();
                }

                // Create the clips
                extremes = axis.getExtremes();
                each(zones, function (threshold, i) {

                    translatedFrom = reversed ?
                        (horiz ? chart.plotWidth : 0) :
                        (horiz ? 0 : axis.toPixels(extremes.min));
                    translatedFrom = mathMin(mathMax(pick(translatedTo, translatedFrom), 0), chartSizeMax);
                    translatedTo = mathMin(mathMax(mathRound(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);

                    if (ignoreZones) {
                        translatedFrom = translatedTo = axis.toPixels(extremes.max);
                    }

                    pxRange = Math.abs(translatedFrom - translatedTo);
                    pxPosMin = mathMin(translatedFrom, translatedTo);
                    pxPosMax = mathMax(translatedFrom, translatedTo);
                    if (axis.isXAxis) {
                        clipAttr = {
                            x: inverted ? pxPosMax : pxPosMin,
                            y: 0,
                            width: pxRange,
                            height: chartSizeMax
                        };
                        if (!horiz) {
                            clipAttr.x = chart.plotHeight - clipAttr.x;
                        }
                    } else {
                        clipAttr = {
                            x: 0,
                            y: inverted ? pxPosMax : pxPosMin,
                            width: chartSizeMax,
                            height: pxRange
                        };
                        if (horiz) {
                            clipAttr.y = chart.plotWidth - clipAttr.y;
                        }
                    }

                    /// VML SUPPPORT
                    if (chart.inverted && renderer.isVML) {
                        if (axis.isXAxis) {
                            clipAttr = {
                                x: 0,
                                y: reversed ? pxPosMin : pxPosMax,
                                height: clipAttr.width,
                                width: chart.chartWidth
                            };
                        } else {
                            clipAttr = {
                                x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                                y: 0,
                                width: clipAttr.height,
                                height: chart.chartHeight
                            };
                        }
                    }
                    /// END OF VML SUPPORT

                    if (clips[i]) {
                        clips[i].animate(clipAttr);
                    } else {
                        clips[i] = renderer.clipRect(clipAttr);

                        if (graph) {
                            series['zoneGraph' + i].clip(clips[i]);
                        }

                        if (area) {
                            series['zoneArea' + i].clip(clips[i]);
                        }
                    }
                    // if this zone extends out of the axis, ignore the others
                    ignoreZones = threshold.value > extremes.max;
                });
                this.clips = clips;
            }
        },

        /**
         * Initialize and perform group inversion on series.group and series.markerGroup
         */
        invertGroups: function () {
            var series = this,
                chart = series.chart;

            // Pie, go away (#1736)
            if (!series.xAxis) {
                return;
            }

            // A fixed size is needed for inversion to work
            function setInvert() {
                var size = {
                    width: series.yAxis.len,
                    height: series.xAxis.len
                };

                each(['group', 'markerGroup'], function (groupName) {
                    if (series[groupName]) {
                        series[groupName].attr(size).invert();
                    }
                });
            }

            addEvent(chart, 'resize', setInvert); // do it on resize
            addEvent(series, 'destroy', function () {
                removeEvent(chart, 'resize', setInvert);
            });

            // Do it now
            setInvert(); // do it now

            // On subsequent render and redraw, just do setInvert without setting up events again
            series.invertGroups = setInvert;
        },

        /**
         * General abstraction for creating plot groups like series.group, series.dataLabelsGroup and
         * series.markerGroup. On subsequent calls, the group will only be adjusted to the updated plot size.
         */
        plotGroup: function (prop, name, visibility, zIndex, parent) {
            var group = this[prop],
                isNew = !group;

            // Generate it on first call
            if (isNew) {
                this[prop] = group = this.chart.renderer.g(name)
                    .attr({
                        zIndex: zIndex || 0.1 // IE8 and pointer logic use this
                    })
                    .add(parent);

                group.addClass('highcharts-series-' + this.index);
            }

            // Place it on first and subsequent (redraw) calls
            group.attr({ visibility: visibility })[isNew ? 'attr' : 'animate'](this.getPlotBox());
            return group;
        },

        /**
         * Get the translation and scale for the plot area of this series
         */
        getPlotBox: function () {
            var chart = this.chart,
                xAxis = this.xAxis,
                yAxis = this.yAxis;

            // Swap axes for inverted (#2339)
            if (chart.inverted) {
                xAxis = yAxis;
                yAxis = this.xAxis;
            }
            return {
                translateX: xAxis ? xAxis.left : chart.plotLeft,
                translateY: yAxis ? yAxis.top : chart.plotTop,
                scaleX: 1, // #1623
                scaleY: 1
            };
        },

        /**
         * Render the graph and markers
         */
        render: function () {
            var series = this,
                chart = series.chart,
                group,
                options = series.options,
                // Animation doesn't work in IE8 quirks when the group div is hidden,
                // and looks bad in other oldIE
                animDuration = !!series.animate && chart.renderer.isSVG && animObject(options.animation).duration,
                visibility = series.visible ? 'inherit' : 'hidden', // #2597
                zIndex = options.zIndex,
                hasRendered = series.hasRendered,
                chartSeriesGroup = chart.seriesGroup;

            // the group
            group = series.plotGroup(
                'group',
                'series',
                visibility,
                zIndex,
                chartSeriesGroup
            );

            series.markerGroup = series.plotGroup(
                'markerGroup',
                'markers',
                visibility,
                zIndex,
                chartSeriesGroup
            );

            // initiate the animation
            if (animDuration) {
                series.animate(true);
            }

            // cache attributes for shapes
            series.getAttribs();

            // SVGRenderer needs to know this before drawing elements (#1089, #1795)
            group.inverted = series.isCartesian ? chart.inverted : false;

            // draw the graph if any
            if (series.drawGraph) {
                series.drawGraph();
                series.applyZones();
            }

            each(series.points, function (point) {
                if (point.redraw) {
                    point.redraw();
                }
            });

            // draw the data labels (inn pies they go before the points)
            if (series.drawDataLabels) {
                series.drawDataLabels();
            }

            // draw the points
            if (series.visible) {
                series.drawPoints();
            }


            // draw the mouse tracking area
            if (series.drawTracker && series.options.enableMouseTracking !== false) {
                series.drawTracker();
            }

            // Handle inverted series and tracker groups
            if (chart.inverted) {
                series.invertGroups();
            }

            // Initial clipping, must be defined after inverting groups for VML. Applies to columns etc. (#3839).
            if (options.clip !== false && !series.sharedClipKey && !hasRendered) {
                group.clip(chart.clipRect);
            }

            // Run the animation
            if (animDuration) {
                series.animate();
            }

            // Call the afterAnimate function on animation complete (but don't overwrite the animation.complete option
            // which should be available to the user).
            if (!hasRendered) {
                series.animationTimeout = syncTimeout(function () {
                    series.afterAnimate();
                }, animDuration);
            }

            series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
            // (See #322) series.isDirty = series.isDirtyData = false; // means data is in accordance with what you see
            series.hasRendered = true;
        },

        /**
         * Redraw the series after an update in the axes.
         */
        redraw: function () {
            var series = this,
                chart = series.chart,
                wasDirty = series.isDirty || series.isDirtyData, // cache it here as it is set to false in render, but used after
                group = series.group,
                xAxis = series.xAxis,
                yAxis = series.yAxis;

            // reposition on resize
            if (group) {
                if (chart.inverted) {
                    group.attr({
                        width: chart.plotWidth,
                        height: chart.plotHeight
                    });
                }

                group.animate({
                    translateX: pick(xAxis && xAxis.left, chart.plotLeft),
                    translateY: pick(yAxis && yAxis.top, chart.plotTop)
                });
            }

            series.translate();
            series.render();
            if (wasDirty) { // #3868, #3945
                delete this.kdTree;
            }
        },

        /**
         * KD Tree && PointSearching Implementation
         */

        kdDimensions: 1,
        kdAxisArray: ['clientX', 'plotY'],

        searchPoint: function (e, compareX) {
            var series = this,
                xAxis = series.xAxis,
                yAxis = series.yAxis,
                inverted = series.chart.inverted;

            return this.searchKDTree({
                clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
            }, compareX);
        },

        buildKDTree: function () {
            var series = this,
                dimensions = series.kdDimensions;

            // Internal function
            function _kdtree(points, depth, dimensions) {
                var axis,
                    median,
                    length = points && points.length;

                if (length) {

                    // alternate between the axis
                    axis = series.kdAxisArray[depth % dimensions];

                    // sort point array
                    points.sort(function (a, b) {
                        return a[axis] - b[axis];
                    });

                    median = Math.floor(length / 2);

                    // build and return nod
                    return {
                        point: points[median],
                        left: _kdtree(points.slice(0, median), depth + 1, dimensions),
                        right: _kdtree(points.slice(median + 1), depth + 1, dimensions)
                    };

                }
            }

            // Start the recursive build process with a clone of the points array and null points filtered out (#3873)
            function startRecursive() {
                series.kdTree = _kdtree(
                    series.getValidPoints(
                        null,
                        !series.directTouch // For line-type series restrict to plot area, but column-type series not (#3916, #4511)
                    ),
                    dimensions,
                    dimensions
                );
            }
            delete series.kdTree;

            // For testing tooltips, don't build async
            syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);
        },

        searchKDTree: function (point, compareX) {
            var series = this,
                kdX = this.kdAxisArray[0],
                kdY = this.kdAxisArray[1],
                kdComparer = compareX ? 'distX' : 'dist';

            // Set the one and two dimensional distance on the point object
            function setDistance(p1, p2) {
                var x = (defined(p1[kdX]) && defined(p2[kdX])) ? Math.pow(p1[kdX] - p2[kdX], 2) : null,
                    y = (defined(p1[kdY]) && defined(p2[kdY])) ? Math.pow(p1[kdY] - p2[kdY], 2) : null,
                    r = (x || 0) + (y || 0);

                p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
                p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
            }
            function _search(search, tree, depth, dimensions) {
                var point = tree.point,
                    axis = series.kdAxisArray[depth % dimensions],
                    tdist,
                    sideA,
                    sideB,
                    ret = point,
                    nPoint1,
                    nPoint2;

                setDistance(search, point);

                // Pick side based on distance to splitting point
                tdist = search[axis] - point[axis];
                sideA = tdist < 0 ? 'left' : 'right';
                sideB = tdist < 0 ? 'right' : 'left';

                // End of tree
                if (tree[sideA]) {
                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);

                    ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);
                }
                if (tree[sideB]) {
                    // compare distance to current best to splitting point to decide wether to check side B or not
                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                        nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                        ret = (nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret);
                    }
                }

                return ret;
            }

            if (!this.kdTree) {
                this.buildKDTree();
            }

            if (this.kdTree) {
                return _search(point,
                    this.kdTree, this.kdDimensions, this.kdDimensions);
            }
        }

    }; // end Series prototype

    /**
     * The class for stack items
     */
    function StackItem(axis, options, isNegative, x, stackOption) {

        var inverted = axis.chart.inverted;

        this.axis = axis;

        // Tells if the stack is negative
        this.isNegative = isNegative;

        // Save the options to be able to style the label
        this.options = options;

        // Save the x value to be able to position the label later
        this.x = x;

        // Initialize total value
        this.total = null;

        // This will keep each points' extremes stored by series.index and point index
        this.points = {};

        // Save the stack option on the series configuration object, and whether to treat it as percent
        this.stack = stackOption;
        this.leftCliff = 0;
        this.rightCliff = 0;

        // The align options and text align varies on whether the stack is negative and
        // if the chart is inverted or not.
        // First test the user supplied value, then use the dynamic.
        this.alignOptions = {
            align: options.align || (inverted ? (isNegative ? 'left' : 'right') : 'center'),
            verticalAlign: options.verticalAlign || (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),
            y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),
            x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)
        };

        this.textAlign = options.textAlign || (inverted ? (isNegative ? 'right' : 'left') : 'center');
    }

    StackItem.prototype = {
        destroy: function () {
            destroyObjectProperties(this, this.axis);
        },

        /**
         * Renders the stack total label and adds it to the stack label group.
         */
        render: function (group) {
            var options = this.options,
                formatOption = options.format,
                str = formatOption ?
                    format(formatOption, this) :
                    options.formatter.call(this);  // format the text in the label

            // Change the text to reflect the new total and set visibility to hidden in case the serie is hidden
            if (this.label) {
                this.label.attr({ text: str, visibility: 'hidden' });
            // Create new label
            } else {
                this.label =
                    this.axis.chart.renderer.text(str, null, null, options.useHTML)        // dummy positions, actual position updated with setOffset method in columnseries
                        .css(options.style)                // apply style
                        .attr({
                            align: this.textAlign,                // fix the text-anchor
                            rotation: options.rotation,    // rotation
                            visibility: HIDDEN                    // hidden until setOffset is called
                        })
                        .add(group);                            // add to the labels-group
            }
        },

        /**
         * Sets the offset that the stack has from the x value and repositions the label.
         */
        setOffset: function (xOffset, xWidth) {
            var stackItem = this,
                axis = stackItem.axis,
                chart = axis.chart,
                inverted = chart.inverted,
                reversed = axis.reversed,
                neg = (this.isNegative && !reversed) || (!this.isNegative && reversed), // #4056
                y = axis.translate(axis.usePercentage ? 100 : this.total, 0, 0, 0, 1), // stack value translated mapped to chart coordinates
                yZero = axis.translate(0),                        // stack origin
                h = mathAbs(y - yZero),                            // stack height
                x = chart.xAxis[0].translate(this.x) + xOffset,    // stack x position
                plotHeight = chart.plotHeight,
                stackBox = {    // this is the box for the complete stack
                    x: inverted ? (neg ? y : y - h) : x,
                    y: inverted ? plotHeight - x - xWidth : (neg ? (plotHeight - y - h) : plotHeight - y),
                    width: inverted ? h : xWidth,
                    height: inverted ? xWidth : h
                },
                label = this.label,
                alignAttr;

            if (label) {
                label.align(this.alignOptions, null, stackBox);    // align the label to the box

                // Set visibility (#678)
                alignAttr = label.alignAttr;
                label[this.options.crop === false || chart.isInsidePlot(alignAttr.x, alignAttr.y) ? 'show' : 'hide'](true);
            }
        }
    };

    /**
     * Generate stacks for each series and calculate stacks total values
     */
    Chart.prototype.getStacks = function () {
        var chart = this;

        // reset stacks for each yAxis
        each(chart.yAxis, function (axis) {
            if (axis.stacks && axis.hasVisibleSeries) {
                axis.oldStacks = axis.stacks;
            }
        });

        each(chart.series, function (series) {
            if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                series.stackKey = series.type + pick(series.options.stack, '');
            }
        });
    };


    // Stacking methods defined on the Axis prototype

    /**
     * Build the stacks from top down
     */
    Axis.prototype.buildStacks = function () {
        var axisSeries = this.series,
            series,
            reversedStacks = pick(this.options.reversedStacks, true),
            len = axisSeries.length,
            i;
        if (!this.isXAxis) {
            this.usePercentage = false;
            i = len;
            while (i--) {
                axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();
            }

            i = len;
            while (i--) {
                series = axisSeries[reversedStacks ? i : len - i - 1];
                if (series.setStackCliffs) {
                    series.setStackCliffs();
                }
            }
            // Loop up again to compute percent stack
            if (this.usePercentage) {
                for (i = 0; i < len; i++) {
                    axisSeries[i].setPercentStacks();
                }
            }
        }
    };

    Axis.prototype.renderStackTotals = function () {
        var axis = this,
            chart = axis.chart,
            renderer = chart.renderer,
            stacks = axis.stacks,
            stackKey,
            oneStack,
            stackCategory,
            stackTotalGroup = axis.stackTotalGroup;

        // Create a separate group for the stack total labels
        if (!stackTotalGroup) {
            axis.stackTotalGroup = stackTotalGroup =
                renderer.g('stack-labels')
                    .attr({
                        visibility: VISIBLE,
                        zIndex: 6
                    })
                    .add();
        }

        // plotLeft/Top will change when y axis gets wider so we need to translate the
        // stackTotalGroup at every render call. See bug #506 and #516
        stackTotalGroup.translate(chart.plotLeft, chart.plotTop);

        // Render each stack total
        for (stackKey in stacks) {
            oneStack = stacks[stackKey];
            for (stackCategory in oneStack) {
                oneStack[stackCategory].render(stackTotalGroup);
            }
        }
    };

    /**
     * Set all the stacks to initial states and destroy unused ones.
     */
    Axis.prototype.resetStacks = function () {
        var stacks = this.stacks,
            type,
            i;
        if (!this.isXAxis) {
            for (type in stacks) {
                for (i in stacks[type]) {

                    // Clean up memory after point deletion (#1044, #4320)
                    if (stacks[type][i].touched < this.stacksTouched) {
                        stacks[type][i].destroy();
                        delete stacks[type][i];

                    // Reset stacks
                    } else {
                        stacks[type][i].total = null;
                        stacks[type][i].cum = 0;
                    }
                }
            }
        }
    };

    Axis.prototype.cleanStacks = function () {
        var stacks, type, i;

        if (!this.isXAxis) {
            if (this.oldStacks) {
                stacks = this.stacks = this.oldStacks;
            }

            // reset stacks
            for (type in stacks) {
                for (i in stacks[type]) {
                    stacks[type][i].cum = stacks[type][i].total;
                }
            }
        }
    };


    // Stacking methods defnied for Series prototype

    /**
     * Adds series' points value to corresponding stack
     */
    Series.prototype.setStackedPoints = function () {
        if (!this.options.stacking || (this.visible !== true && this.chart.options.chart.ignoreHiddenSeries !== false)) {
            return;
        }

        var series = this,
            xData = series.processedXData,
            yData = series.processedYData,
            stackedYData = [],
            yDataLength = yData.length,
            seriesOptions = series.options,
            threshold = seriesOptions.threshold,
            stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,
            stackOption = seriesOptions.stack,
            stacking = seriesOptions.stacking,
            stackKey = series.stackKey,
            negKey = '-' + stackKey,
            negStacks = series.negStacks,
            yAxis = series.yAxis,
            stacks = yAxis.stacks,
            oldStacks = yAxis.oldStacks,
            stackIndicator,
            isNegative,
            stack,
            other,
            key,
            pointKey,
            i,
            x,
            y;


        yAxis.stacksTouched += 1;

        // loop over the non-null y values and read them into a local array
        for (i = 0; i < yDataLength; i++) {
            x = xData[i];
            y = yData[i];
            stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
            pointKey = stackIndicator.key;
            // Read stacked values into a stack based on the x value,
            // the sign of y and the stack key. Stacking is also handled for null values (#739)
            isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
            key = isNegative ? negKey : stackKey;

            // Create empty object for this stack if it doesn't exist yet
            if (!stacks[key]) {
                stacks[key] = {};
            }

            // Initialize StackItem for this x
            if (!stacks[key][x]) {
                if (oldStacks[key] && oldStacks[key][x]) {
                    stacks[key][x] = oldStacks[key][x];
                    stacks[key][x].total = null;
                } else {
                    stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, isNegative, x, stackOption);
                }
            }

            // If the StackItem doesn't exist, create it first
            stack = stacks[key][x];
            if (y !== null) {
                stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];

                // Record the base of the stack
                if (!defined(stack.cum)) {
                    stack.base = pointKey;
                }
                stack.touched = yAxis.stacksTouched;
        

                // In area charts, if there are multiple points on the same X value, let the 
                // area fill the full span of those points
                if (stackIndicator.index > 0 && series.singleStacks === false) {
                    stack.points[pointKey][0] = stack.points[series.index + ',' + x + ',0'][0];
                }
            }

            // Add value to the stack total
            if (stacking === 'percent') {

                // Percent stacked column, totals are the same for the positive and negative stacks
                other = isNegative ? stackKey : negKey;
                if (negStacks && stacks[other] && stacks[other][x]) {
                    other = stacks[other][x];
                    stack.total = other.total = mathMax(other.total, stack.total) + mathAbs(y) || 0;

                // Percent stacked areas
                } else {
                    stack.total = correctFloat(stack.total + (mathAbs(y) || 0));
                }
            } else {
                stack.total = correctFloat(stack.total + (y || 0));
            }

            stack.cum = pick(stack.cum, stackThreshold) + (y || 0);

            if (y !== null) {
                stack.points[pointKey].push(stack.cum);
                stackedYData[i] = stack.cum;
            }

        }

        if (stacking === 'percent') {
            yAxis.usePercentage = true;
        }

        this.stackedYData = stackedYData; // To be used in getExtremes

        // Reset old stacks
        yAxis.oldStacks = {};
    };

    /**
     * Iterate over all stacks and compute the absolute values to percent
     */
    Series.prototype.setPercentStacks = function () {
        var series = this,
            stackKey = series.stackKey,
            stacks = series.yAxis.stacks,
            processedXData = series.processedXData,
            stackIndicator;

        each([stackKey, '-' + stackKey], function (key) {
            var i = processedXData.length,
                x,
                stack,
                pointExtremes,
                totalFactor;

            while (i--) {
                x = processedXData[i];
                stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
                stack = stacks[key] && stacks[key][x];
                pointExtremes = stack && stack.points[stackIndicator.key];
                if (pointExtremes) {
                    totalFactor = stack.total ? 100 / stack.total : 0;
                    pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor); // Y bottom value
                    pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor); // Y value
                    series.stackedYData[i] = pointExtremes[1];
                }
            }
        });
    };

    /**
    * Get stack indicator, according to it's x-value, to determine points with the same x-value
    */
    Series.prototype.getStackIndicator = function (stackIndicator, x, index) {
        if (!defined(stackIndicator) || stackIndicator.x !== x) {
            stackIndicator = {
                x: x,
                index: 0
            };
        } else {
            stackIndicator.index++;
        }

        stackIndicator.key = [index, x, stackIndicator.index].join(',');

        return stackIndicator;
    };

    // Extend the Chart prototype for dynamic methods
    extend(Chart.prototype, {

        /**
         * Add a series dynamically after  time
         *
         * @param {Object} options The config options
         * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         *
         * @return {Object} series The newly created series object
         */
        addSeries: function (options, redraw, animation) {
            var series,
                chart = this;

            if (options) {
                redraw = pick(redraw, true); // defaults to true

                fireEvent(chart, 'addSeries', { options: options }, function () {
                    series = chart.initSeries(options);

                    chart.isDirtyLegend = true; // the series array is out of sync with the display
                    chart.linkSeries();
                    if (redraw) {
                        chart.redraw(animation);
                    }
                });
            }

            return series;
        },

        /**
         * Add an axis to the chart
         * @param {Object} options The axis option
         * @param {Boolean} isX Whether it is an X axis or a value axis
         */
        addAxis: function (options, isX, redraw, animation) {
            var key = isX ? 'xAxis' : 'yAxis',
                chartOptions = this.options,
                userOptions = merge(options, {
                    index: this[key].length,
                    isX: isX
                });

            new Axis(this, userOptions); // eslint-disable-line no-new

            // Push the new axis options to the chart options
            chartOptions[key] = splat(chartOptions[key] || {});
            chartOptions[key].push(userOptions);

            if (pick(redraw, true)) {
                this.redraw(animation);
            }
        },

        /**
         * Dim the chart and show a loading text or symbol
         * @param {String} str An optional text to show in the loading label instead of the default one
         */
        showLoading: function (str) {
            var chart = this,
                options = chart.options,
                loadingDiv = chart.loadingDiv,
                loadingOptions = options.loading,
                setLoadingSize = function () {
                    if (loadingDiv) {
                        css(loadingDiv, {
                            left: chart.plotLeft + PX,
                            top: chart.plotTop + PX,
                            width: chart.plotWidth + PX,
                            height: chart.plotHeight + PX
                        });
                    }
                };

            // create the layer at the first call
            if (!loadingDiv) {
                chart.loadingDiv = loadingDiv = createElement(DIV, {
                    className: PREFIX + 'loading'
                }, extend(loadingOptions.style, {
                    zIndex: 10,
                    display: NONE
                }), chart.container);

                chart.loadingSpan = createElement(
                    'span',
                    null,
                    loadingOptions.labelStyle,
                    loadingDiv
                );
                addEvent(chart, 'redraw', setLoadingSize); // #1080
            }

            // update text
            chart.loadingSpan.innerHTML = str || options.lang.loading;

            // show it
            if (!chart.loadingShown) {
                css(loadingDiv, {
                    opacity: 0,
                    display: ''
                });
                animate(loadingDiv, {
                    opacity: loadingOptions.style.opacity
                }, {
                    duration: loadingOptions.showDuration || 0
                });
                chart.loadingShown = true;
            }
            setLoadingSize();
        },

        /**
         * Hide the loading layer
         */
        hideLoading: function () {
            var options = this.options,
                loadingDiv = this.loadingDiv;

            if (loadingDiv) {
                animate(loadingDiv, {
                    opacity: 0
                }, {
                    duration: options.loading.hideDuration || 100,
                    complete: function () {
                        css(loadingDiv, { display: NONE });
                    }
                });
            }
            this.loadingShown = false;
        }
    });

    // extend the Point prototype for dynamic methods
    extend(Point.prototype, {
        /**
         * Update the point with new options (typically x/y data) and optionally redraw the series.
         *
         * @param {Object} options Point options as defined in the series.data array
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         *
         */
        update: function (options, redraw, animation, runEvent) {
            var point = this,
                series = point.series,
                graphic = point.graphic,
                i,
                chart = series.chart,
                seriesOptions = series.options,
                names = series.xAxis && series.xAxis.names;

            redraw = pick(redraw, true);

            function update() {

                point.applyOptions(options);

                // Update visuals
                if (point.y === null && graphic) { // #4146
                    point.graphic = graphic.destroy();
                }
                if (isObject(options, true)) {
                    // Defer the actual redraw until getAttribs has been called (#3260)
                    point.redraw = function () {
                        if (graphic && graphic.element) {
                            if (options && options.marker && options.marker.symbol) {
                                point.graphic = graphic.destroy();
                            }
                        }
                        if (options && options.dataLabels && point.dataLabel) { // #2468
                            point.dataLabel = point.dataLabel.destroy();
                        }
                        point.redraw = null;
                    };
                }

                // record changes in the parallel arrays
                i = point.index;
                series.updateParallelArrays(point, i);
                if (names && point.name) {
                    names[point.x] = point.name;
                }

                // Record the options to options.data. If there is an object from before,
                // use point options, otherwise use raw options. (#4701)
                seriesOptions.data[i] = isObject(seriesOptions.data[i], true) ? point.options : options;

                // redraw
                series.isDirty = series.isDirtyData = true;
                if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320
                    chart.isDirtyBox = true;
                }

                if (seriesOptions.legendType === 'point') { // #1831, #1885
                    chart.isDirtyLegend = true;
                }
                if (redraw) {
                    chart.redraw(animation);
                }
            }

            // Fire the event with a default handler of doing the update
            if (runEvent === false) { // When called from setData
                update();
            } else {
                point.firePointEvent('update', { options: options }, update);
            }
        },

        /**
         * Remove a point and optionally redraw the series and if necessary the axes
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        remove: function (redraw, animation) {
            this.series.removePoint(inArray(this, this.series.data), redraw, animation);
        }
    });

    // Extend the series prototype for dynamic methods
    extend(Series.prototype, {
        /**
         * Add a point dynamically after chart load time
         * @param {Object} options Point options as given in series.data
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean} shift If shift is true, a point is shifted off the start
         *    of the series as one is appended to the end.
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        addPoint: function (options, redraw, shift, animation) {
            var series = this,
                seriesOptions = series.options,
                data = series.data,
                chart = series.chart,
                names = series.xAxis && series.xAxis.names,
                dataOptions = seriesOptions.data,
                point,
                isInTheMiddle,
                xData = series.xData,
                i,
                x;

            setAnimation(animation, chart);

            // Optional redraw, defaults to true
            redraw = pick(redraw, true);

            // Get options and push the point to xData, yData and series.options. In series.generatePoints
            // the Point instance will be created on demand and pushed to the series.data array.
            point = { series: series };
            series.pointClass.prototype.applyOptions.apply(point, [options]);
            x = point.x;

            // Get the insertion point
            i = xData.length;
            if (series.requireSorting && x < xData[i - 1]) {
                isInTheMiddle = true;
                while (i && xData[i - 1] > x) {
                    i--;
                }
            }

            series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item
            series.updateParallelArrays(point, i); // update it

            if (names && point.name) {
                names[x] = point.name;
            }
            dataOptions.splice(i, 0, options);

            if (isInTheMiddle) {
                series.data.splice(i, 0, null);
                series.processData();
            }

            // Generate points to be added to the legend (#1329)
            if (seriesOptions.legendType === 'point') {
                series.generatePoints();
            }

            // Shift the first point off the parallel arrays
            if (shift) {
                if (data[0] && data[0].remove) {
                    data[0].remove(false);
                } else {
                    data.shift();
                    series.updateParallelArrays(point, 'shift');

                    dataOptions.shift();
                }
            }

            // redraw
            series.isDirty = true;
            series.isDirtyData = true;
            if (redraw) {
                series.getAttribs(); // #1937
                chart.redraw();
            }
        },

        /**
         * Remove a point (rendered or not), by index
         */
        removePoint: function (i, redraw, animation) {

            var series = this,
                data = series.data,
                point = data[i],
                points = series.points,
                chart = series.chart,
                remove = function () {

                    if (points && points.length === data.length) { // #4935
                        points.splice(i, 1);
                    }
                    data.splice(i, 1);
                    series.options.data.splice(i, 1);
                    series.updateParallelArrays(point || { series: series }, 'splice', i, 1);

                    if (point) {
                        point.destroy();
                    }

                    // redraw
                    series.isDirty = true;
                    series.isDirtyData = true;
                    if (redraw) {
                        chart.redraw();
                    }
                };

            setAnimation(animation, chart);
            redraw = pick(redraw, true);

            // Fire the event with a default handler of removing the point
            if (point) {
                point.firePointEvent('remove', null, remove);
            } else {
                remove();
            }
        },

        /**
         * Remove a series and optionally redraw the chart
         *
         * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
         * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
         *    configuration
         */
        remove: function (redraw, animation) {
            var series = this,
                chart = series.chart;

            // Fire the event with a default handler of removing the point
            fireEvent(series, 'remove', null, function () {

                // Destroy elements
                series.destroy();

                // Redraw
                chart.isDirtyLegend = chart.isDirtyBox = true;
                chart.linkSeries();

                if (pick(redraw, true)) {
                    chart.redraw(animation);
                }
            });
        },

        /**
         * Update the series with a new set of options
         */
        update: function (newOptions, redraw) {
            var series = this,
                chart = this.chart,
                // must use user options when changing type because this.options is merged
                // in with type specific plotOptions
                oldOptions = this.userOptions,
                oldType = this.type,
                proto = seriesTypes[oldType].prototype,
                preserve = ['group', 'markerGroup', 'dataLabelsGroup'],
                n;

            // If we're changing type or zIndex, create new groups (#3380, #3404)
            if ((newOptions.type && newOptions.type !== oldType) || newOptions.zIndex !== undefined) {
                preserve.length = 0;
            }

            // Make sure groups are not destroyed (#3094)
            each(preserve, function (prop) {
                preserve[prop] = series[prop];
                delete series[prop];
            });

            // Do the merge, with some forced options
            newOptions = merge(oldOptions, {
                animation: false,
                index: this.index,
                pointStart: this.xData[0] // when updating after addPoint
            }, { data: this.options.data }, newOptions);

            // Destroy the series and delete all properties. Reinsert all methods
            // and properties from the new type prototype (#2270, #3719)
            this.remove(false);
            for (n in proto) {
                this[n] = UNDEFINED;
            }
            extend(this, seriesTypes[newOptions.type || oldType].prototype);

            // Re-register groups (#3094)
            each(preserve, function (prop) {
                series[prop] = preserve[prop];
            });

            this.init(chart, newOptions);
            chart.linkSeries(); // Links are lost in this.remove (#3028)
            if (pick(redraw, true)) {
                chart.redraw(false);
            }
        }
    });

    // Extend the Axis.prototype for dynamic methods
    extend(Axis.prototype, {

        /**
         * Update the axis with a new options structure
         */
        update: function (newOptions, redraw) {
            var chart = this.chart;

            newOptions = chart.options[this.coll][this.options.index] = merge(this.userOptions, newOptions);

            this.destroy(true);

            this.init(chart, extend(newOptions, { events: UNDEFINED }));

            chart.isDirtyBox = true;
            if (pick(redraw, true)) {
                chart.redraw();
            }
        },

        /**
         * Remove the axis from the chart
         */
        remove: function (redraw) {
            var chart = this.chart,
                key = this.coll, // xAxis or yAxis
                axisSeries = this.series,
                i = axisSeries.length;

            // Remove associated series (#2687)
            while (i--) {
                if (axisSeries[i]) {
                    axisSeries[i].remove(false);
                }
            }

            // Remove the axis
            erase(chart.axes, this);
            erase(chart[key], this);
            chart.options[key].splice(this.options.index, 1);
            each(chart[key], function (axis, i) { // Re-index, #1706
                axis.options.index = i;
            });
            this.destroy();
            chart.isDirtyBox = true;

            if (pick(redraw, true)) {
                chart.redraw();
            }
        },

        /**
         * Update the axis title by options
         */
        setTitle: function (newTitleOptions, redraw) {
            this.update({ title: newTitleOptions }, redraw);
        },

        /**
         * Set new axis categories and optionally redraw
         * @param {Array} categories
         * @param {Boolean} redraw
         */
        setCategories: function (categories, redraw) {
            this.update({ categories: categories }, redraw);
        }

    });


    /**
     * LineSeries object
     */
    var LineSeries = extendClass(Series);
    seriesTypes.line = LineSeries;

    /**
     * Set the default options for area
     */
    defaultPlotOptions.area = merge(defaultSeriesOptions, {
        softThreshold: false,
        threshold: 0
        // trackByArea: false,
        // lineColor: null, // overrides color, but lets fillColor be unaltered
        // fillOpacity: 0.75,
        // fillColor: null
    });

    /**
     * AreaSeries object
     */
    var AreaSeries = extendClass(Series, {
        type: 'area',
        singleStacks: false,
        /** 
         * Return an array of stacked points, where null and missing points are replaced by 
         * dummy points in order for gaps to be drawn correctly in stacks.
         */
        getStackPoints: function () {
            var series = this,
                segment = [],
                keys = [],
                xAxis = this.xAxis,
                yAxis = this.yAxis,
                stack = yAxis.stacks[this.stackKey],
                pointMap = {},
                points = this.points,
                seriesIndex = series.index,
                yAxisSeries = yAxis.series,
                seriesLength = yAxisSeries.length,
                visibleSeries,
                upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,
                i,
                x;

            if (this.options.stacking) {
                // Create a map where we can quickly look up the points by their X value.
                for (i = 0; i < points.length; i++) {
                    pointMap[points[i].x] = points[i];
                }

                // Sort the keys (#1651)
                for (x in stack) {
                    if (stack[x].total !== null) { // nulled after switching between grouping and not (#1651, #2336)
                        keys.push(x);
                    }
                }
                keys.sort(function (a, b) {
                    return a - b;
                });

                visibleSeries = map(yAxisSeries, function () {
                    return this.visible;
                });

                each(keys, function (x, idx) {
                    var y = 0,
                        stackPoint,
                        stackedValues;

                    if (pointMap[x] && !pointMap[x].isNull) {
                        segment.push(pointMap[x]);

                        // Find left and right cliff. -1 goes left, 1 goes right.
                        each([-1, 1], function (direction) {
                            var nullName = direction === 1 ? 'rightNull' : 'leftNull',
                                cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',
                                cliff = 0,
                                otherStack = stack[keys[idx + direction]];

                            // If there is a stack next to this one, to the left or to the right...
                            if (otherStack) {
                                i = seriesIndex;
                                while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks
                                    stackPoint = otherStack.points[i];
                                    if (!stackPoint) {
                                        // If the next point in this series is missing, mark the point
                                        // with point.leftNull or point.rightNull = true.
                                        if (i === seriesIndex) {
                                            pointMap[x][nullName] = true;

                                        // If there are missing points in the next stack in any of the 
                                        // series below this one, we need to substract the missing values
                                        // and add a hiatus to the left or right.
                                        } else if (visibleSeries[i]) {
                                            stackedValues = stack[x].points[i];
                                            if (stackedValues) {
                                                cliff -= stackedValues[1] - stackedValues[0];
                                            }
                                        }
                                    }
                                    // When reversedStacks is true, loop up, else loop down
                                    i += upOrDown; 
                                }                
                            }
                            pointMap[x][cliffName] = cliff;
                        });


                    // There is no point for this X value in this series, so we 
                    // insert a dummy point in order for the areas to be drawn
                    // correctly.
                    } else {

                        // Loop down the stack to find the series below this one that has
                        // a value (#1991)
                        i = seriesIndex;
                        while (i >= 0 && i < seriesLength) {
                            stackPoint = stack[x].points[i];
                            if (stackPoint) {
                                y = stackPoint[1];
                                break;
                            }
                            // When reversedStacks is true, loop up, else loop down
                            i += upOrDown;
                        }

                        y = yAxis.toPixels(y, true);
                        segment.push({ 
                            isNull: true,
                            plotX: xAxis.toPixels(x, true),
                            plotY: y,
                            yBottom: y
                        });
                    }
                });

            } 

            return segment;
        },

        getGraphPath: function (points) {
            var getGraphPath = Series.prototype.getGraphPath,
                graphPath,
                options = this.options,
                stacking = options.stacking,
                yAxis = this.yAxis,
                topPath,
                //topPoints = [],
                bottomPath,
                bottomPoints = [],
                graphPoints = [],
                seriesIndex = this.index,
                i,
                areaPath,
                plotX,
                stacks = yAxis.stacks[this.stackKey],
                threshold = options.threshold,
                translatedThreshold = yAxis.getThreshold(options.threshold),
                isNull,
                yBottom,
                connectNulls = options.connectNulls || stacking === 'percent',
                /**
                 * To display null points in underlying stacked series, this series graph must be 
                 * broken, and the area also fall down to fill the gap left by the null point. #2069
                 */
                addDummyPoints = function (i, otherI, side) {
                    var point = points[i],
                        stackedValues = stacking && stacks[point.x].points[seriesIndex],
                        nullVal = point[side + 'Null'] || 0,
                        cliffVal = point[side + 'Cliff'] || 0,
                        top,
                        bottom,
                        isNull = true;

                    if (cliffVal || nullVal) {

                        top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
                        bottom = stackedValues[0] + cliffVal;
                        isNull = !!nullVal;
                
                    } else if (!stacking && points[otherI] && points[otherI].isNull) {
                        top = bottom = threshold;
                    }

                    // Add to the top and bottom line of the area
                    if (top !== undefined) {
                        graphPoints.push({
                            plotX: plotX,
                            plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
                            isNull: isNull
                        });
                        bottomPoints.push({
                            plotX: plotX,
                            plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom)
                        });
                    }
                };

            // Find what points to use
            points = points || this.points;

        
            // Fill in missing points
            if (stacking) {
                points = this.getStackPoints();
            }

            for (i = 0; i < points.length; i++) {
                isNull = points[i].isNull;
                plotX = pick(points[i].rectPlotX, points[i].plotX);
                yBottom = pick(points[i].yBottom, translatedThreshold);

                if (!isNull || connectNulls) {

                    if (!connectNulls) {
                        addDummyPoints(i, i - 1, 'left');
                    }

                    if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true
                        graphPoints.push(points[i]);
                        bottomPoints.push({
                            x: i,
                            plotX: plotX,
                            plotY: yBottom
                        });
                    }

                    if (!connectNulls) {
                        addDummyPoints(i, i + 1, 'right');
                    }
                }
            }

            topPath = getGraphPath.call(this, graphPoints, true, true);
        
            bottomPoints.reversed = true;
            bottomPath = getGraphPath.call(this, bottomPoints, true, true);
            if (bottomPath.length) {
                bottomPath[0] = L;
            }

            areaPath = topPath.concat(bottomPath);
            graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?

            areaPath.xMap = topPath.xMap;
            this.areaPath = areaPath;
            return graphPath;
        },

        /**
         * Draw the graph and the underlying area. This method calls the Series base
         * function and adds the area. The areaPath is calculated in the getSegmentPath
         * method called from Series.prototype.drawGraph.
         */
        drawGraph: function () {

            // Define or reset areaPath
            this.areaPath = [];

            // Call the base method
            Series.prototype.drawGraph.apply(this);

            // Define local variables
            var series = this,
                areaPath = this.areaPath,
                options = this.options,
                zones = this.zones,
                props = [['area', this.color, options.fillColor]]; // area name, main color, fill color

            each(zones, function (threshold, i) {
                props.push(['zoneArea' + i, threshold.color || series.color, threshold.fillColor || options.fillColor]);
            });
            each(props, function (prop) {
                var areaKey = prop[0],
                    area = series[areaKey],
                    attr;

                // Create or update the area
                if (area) { // update
                    area.endX = areaPath.xMap;
                    area.animate({ d: areaPath });

                } else { // create
                    attr = {
                        fill: prop[2] || prop[1],
                        zIndex: 0 // #1069
                    };
                    if (!prop[2]) {
                        attr['fill-opacity'] = pick(options.fillOpacity, 0.75);
                    }
                    area = series[areaKey] = series.chart.renderer.path(areaPath)
                        .attr(attr)
                        .add(series.group);
                    area.isArea = true;
                }
                area.startX = areaPath.xMap;
                area.shiftUnit = options.step ? 2 : 1;
            });
        },

        drawLegendSymbol: LegendSymbolMixin.drawRectangle
    });

    seriesTypes.area = AreaSeries;
    /**
     * Set the default options for spline
     */
    defaultPlotOptions.spline = merge(defaultSeriesOptions);

    /**
     * SplineSeries object
     */
    var SplineSeries = extendClass(Series, {
        type: 'spline',

        /**
         * Get the spline segment from a given point's previous neighbour to the given point
         */
        getPointSpline: function (points, point, i) {
            var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
                denom = smoothing + 1,
                plotX = point.plotX,
                plotY = point.plotY,
                lastPoint = points[i - 1],
                nextPoint = points[i + 1],
                leftContX,
                leftContY,
                rightContX,
                rightContY,
                ret;

            // Find control points
            if (lastPoint && !lastPoint.isNull && nextPoint && !nextPoint.isNull) {
                var lastX = lastPoint.plotX,
                    lastY = lastPoint.plotY,
                    nextX = nextPoint.plotX,
                    nextY = nextPoint.plotY,
                    correction = 0;

                leftContX = (smoothing * plotX + lastX) / denom;
                leftContY = (smoothing * plotY + lastY) / denom;
                rightContX = (smoothing * plotX + nextX) / denom;
                rightContY = (smoothing * plotY + nextY) / denom;

                // Have the two control points make a straight line through main point
                if (rightContX !== leftContX) { // #5016, division by zero
                    correction = ((rightContY - leftContY) * (rightContX - plotX)) /
                        (rightContX - leftContX) + plotY - rightContY;
                }

                leftContY += correction;
                rightContY += correction;

                // to prevent false extremes, check that control points are between
                // neighbouring points' y values
                if (leftContY > lastY && leftContY > plotY) {
                    leftContY = mathMax(lastY, plotY);
                    rightContY = 2 * plotY - leftContY; // mirror of left control point
                } else if (leftContY < lastY && leftContY < plotY) {
                    leftContY = mathMin(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                }
                if (rightContY > nextY && rightContY > plotY) {
                    rightContY = mathMax(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                } else if (rightContY < nextY && rightContY < plotY) {
                    rightContY = mathMin(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                }

                // record for drawing in next point
                point.rightContX = rightContX;
                point.rightContY = rightContY;

            
            }

            // Visualize control points for debugging
            /*
            if (leftContX) {
                this.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)
                    .attr({
                        stroke: 'red',
                        'stroke-width': 1,
                        fill: 'none'
                    })
                    .add();
                this.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,
                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                    .attr({
                        stroke: 'red',
                        'stroke-width': 1
                    })
                    .add();
                this.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)
                    .attr({
                        stroke: 'green',
                        'stroke-width': 1,
                        fill: 'none'
                    })
                    .add();
                this.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,
                    'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])
                    .attr({
                        stroke: 'green',
                        'stroke-width': 1
                    })
                    .add();
            }
            // */
            ret = [
                'C',
                pick(lastPoint.rightContX, lastPoint.plotX),
                pick(lastPoint.rightContY, lastPoint.plotY),
                pick(leftContX, plotX),
                pick(leftContY, plotY),
                plotX,
                plotY
            ];
            lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
            return ret;
        }
    });
    seriesTypes.spline = SplineSeries;

    /**
     * Set the default options for areaspline
     */
    defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);

    /**
     * AreaSplineSeries object
     */
    var areaProto = AreaSeries.prototype,
        AreaSplineSeries = extendClass(SplineSeries, {
            type: 'areaspline',
            getStackPoints: areaProto.getStackPoints,
            getGraphPath: areaProto.getGraphPath,
            setStackCliffs: areaProto.setStackCliffs,
            drawGraph: areaProto.drawGraph,
            drawLegendSymbol: LegendSymbolMixin.drawRectangle
        });

    seriesTypes.areaspline = AreaSplineSeries;

    /**
     * Set the default options for column
     */
    defaultPlotOptions.column = merge(defaultSeriesOptions, {
        borderColor: '#FFFFFF',
        //borderWidth: 1,
        borderRadius: 0,
        //colorByPoint: undefined,
        groupPadding: 0.2,
        //grouping: true,
        marker: null, // point options are specified in the base options
        pointPadding: 0.1,
        //pointWidth: null,
        minPointLength: 0,
        cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes
        pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories
        states: {
            hover: {
                brightness: 0.1,
                shadow: false,
                halo: false
            },
            select: {
                color: '#C0C0C0',
                borderColor: '#000000',
                shadow: false
            }
        },
        dataLabels: {
            align: null, // auto
            verticalAlign: null, // auto
            y: null
        },
        softThreshold: false,
        startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/
        stickyTracking: false,
        tooltip: {
            distance: 6
        },
        threshold: 0
    });

    /**
     * ColumnSeries object
     */
    var ColumnSeries = extendClass(Series, {
        type: 'column',
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'borderColor',
            fill: 'color',
            r: 'borderRadius'
        },
        cropShoulder: 0,
        directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.
        trackerGroups: ['group', 'dataLabelsGroup'],
        negStacks: true, // use separate negative stacks, unlike area stacks where a negative
            // point is substracted from previous (#1910)

        /**
         * Initialize the series
         */
        init: function () {
            Series.prototype.init.apply(this, arguments);

            var series = this,
                chart = series.chart;

            // if the series is added dynamically, force redraw of other
            // series affected by a new column
            if (chart.hasRendered) {
                each(chart.series, function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }
        },

        /**
         * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,
         * pointWidth etc.
         */
        getColumnMetrics: function () {

            var series = this,
                options = series.options,
                xAxis = series.xAxis,
                yAxis = series.yAxis,
                reversedXAxis = xAxis.reversed,
                stackKey,
                stackGroups = {},
                columnCount = 0;

            // Get the total number of column type series.
            // This is called on every series. Consider moving this logic to a
            // chart.orderStacks() function and call it on init, addSeries and removeSeries
            if (options.grouping === false) {
                columnCount = 1;
            } else {
                each(series.chart.series, function (otherSeries) {
                    var otherOptions = otherSeries.options,
                        otherYAxis = otherSeries.yAxis,
                        columnIndex;
                    if (otherSeries.type === series.type && otherSeries.visible &&
                            yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {  // #642, #2086
                        if (otherOptions.stacking) {
                            stackKey = otherSeries.stackKey;
                            if (stackGroups[stackKey] === UNDEFINED) {
                                stackGroups[stackKey] = columnCount++;
                            }
                            columnIndex = stackGroups[stackKey];
                        } else if (otherOptions.grouping !== false) { // #1162
                            columnIndex = columnCount++;
                        }
                        otherSeries.columnIndex = columnIndex;
                    }
                });
            }

            var categoryWidth = mathMin(
                    mathAbs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610
                    xAxis.len // #1535
                ),
                groupPadding = categoryWidth * options.groupPadding,
                groupWidth = categoryWidth - 2 * groupPadding,
                pointOffsetWidth = groupWidth / columnCount,
                pointWidth = mathMin(
                    options.maxPointWidth || xAxis.len,
                    pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))
                ),
                pointPadding = (pointOffsetWidth - pointWidth) / 2,
                colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737
                pointXOffset = pointPadding + (groupPadding + colIndex *
                    pointOffsetWidth - (categoryWidth / 2)) *
                    (reversedXAxis ? -1 : 1);

            // Save it for reading in linked series (Error bars particularly)
            series.columnMetrics = {
                width: pointWidth,
                offset: pointXOffset
            };
            return series.columnMetrics;

        },

        /**
         * Make the columns crisp. The edges are rounded to the nearest full pixel.
         */
        crispCol: function (x, y, w, h) {
            var chart = this.chart,
                borderWidth = this.borderWidth,
                xCrisp = -(borderWidth % 2 ? 0.5 : 0),
                yCrisp = borderWidth % 2 ? 0.5 : 1,
                right,
                bottom,
                fromTop;

            if (chart.inverted && chart.renderer.isVML) {
                yCrisp += 1;
            }

            // Horizontal. We need to first compute the exact right edge, then round it
            // and compute the width from there.
            right = Math.round(x + w) + xCrisp;
            x = Math.round(x) + xCrisp;
            w = right - x;

            // Vertical
            bottom = Math.round(y + h) + yCrisp;
            fromTop = mathAbs(y) <= 0.5 && bottom > 0.5; // #4504, #4656
            y = Math.round(y) + yCrisp;
            h = bottom - y;

            // Top edges are exceptions
            if (fromTop && h) { // #5146
                y -= 1;
                h += 1;
            }

            return {
                x: x,
                y: y,
                width: w,
                height: h
            };
        },

        /**
         * Translate each point to the plot area coordinate system and find shape positions
         */
        translate: function () {
            var series = this,
                chart = series.chart,
                options = series.options,
                borderWidth = series.borderWidth = pick(
                    options.borderWidth,
                    series.closestPointRange * series.xAxis.transA < 2 ? 0 : 1 // #3635
                ),
                yAxis = series.yAxis,
                threshold = options.threshold,
                translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
                minPointLength = pick(options.minPointLength, 5),
                metrics = series.getColumnMetrics(),
                pointWidth = metrics.width,
                seriesBarW = series.barW = mathMax(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width
                pointXOffset = series.pointXOffset = metrics.offset;

            if (chart.inverted) {
                translatedThreshold -= 0.5; // #3355
            }

            // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual
            // columns to have individual sizes. When pointPadding is greater, we strive for equal-width
            // columns (#2694).
            if (options.pointPadding) {
                seriesBarW = mathCeil(seriesBarW);
            }

            Series.prototype.translate.apply(series);

            // Record the new values
            each(series.points, function (point) {
                var yBottom = mathMin(pick(point.yBottom, translatedThreshold), 9e4), // #3575
                    safeDistance = 999 + mathAbs(yBottom),
                    plotY = mathMin(mathMax(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)
                    barX = point.plotX + pointXOffset,
                    barW = seriesBarW,
                    barY = mathMin(plotY, yBottom),
                    up,
                    barH = mathMax(plotY, yBottom) - barY;

                // Handle options.minPointLength
                if (mathAbs(barH) < minPointLength) {
                    if (minPointLength) {
                        barH = minPointLength;
                        up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);
                        barY = mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
                                yBottom - minPointLength : // keep position
                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051
                    }
                }

                // Cache for access in polar
                point.barX = barX;
                point.pointWidth = pointWidth;

                // Fix the tooltip on center of grouped columns (#1216, #424, #3648)
                point.tooltipPos = chart.inverted ?
                    [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] :
                    [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];

                // Register shape type and arguments to be used in drawPoints
                point.shapeType = 'rect';
                point.shapeArgs = series.crispCol(barX, barY, barW, barH);
            });

        },

        getSymbol: noop,

        /**
         * Use a solid rectangle like the area series types
         */
        drawLegendSymbol: LegendSymbolMixin.drawRectangle,


        /**
         * Columns have no graph
         */
        drawGraph: noop,

        /**
         * Draw the columns. For bars, the series.group is rotated, so the same coordinates
         * apply for columns and bars. This method is inherited by scatter series.
         *
         */
        drawPoints: function () {
            var series = this,
                chart = this.chart,
                options = series.options,
                renderer = chart.renderer,
                animationLimit = options.animationLimit || 250,
                shapeArgs,
                pointAttr;

            // draw the columns
            each(series.points, function (point) {
                var plotY = point.plotY,
                    graphic = point.graphic,
                    borderAttr;

                if (isNumber(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;

                    borderAttr = defined(series.borderWidth) ? {
                        'stroke-width': series.borderWidth
                    } : {};

                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE] || series.pointAttr[NORMAL_STATE];

                    if (graphic) { // update
                        stop(graphic);
                        graphic.attr(borderAttr).attr(pointAttr)[chart.pointCount < animationLimit ? 'animate' : 'attr'](merge(shapeArgs)); // #4267

                    } else {
                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                            .attr(borderAttr)
                            .attr(pointAttr)
                            .add(point.group || series.group)
                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);
                    }

                } else if (graphic) {
                    point.graphic = graphic.destroy(); // #1269
                }
            });
        },

        /**
         * Animate the column heights one by one from zero
         * @param {Boolean} init Whether to initialize the animation or run it
         */
        animate: function (init) {
            var series = this,
                yAxis = this.yAxis,
                options = series.options,
                inverted = this.chart.inverted,
                attr = {},
                translatedThreshold;

            if (hasSVG) { // VML is too slow anyway
                if (init) {
                    attr.scaleY = 0.001;
                    translatedThreshold = mathMin(yAxis.pos + yAxis.len, mathMax(yAxis.pos, yAxis.toPixels(options.threshold)));
                    if (inverted) {
                        attr.translateX = translatedThreshold - yAxis.len;
                    } else {
                        attr.translateY = translatedThreshold;
                    }
                    series.group.attr(attr);

                } else { // run the animation

                    attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;
                    series.group.animate(attr, extend(animObject(series.options.animation), {
                        // Do the scale synchronously to ensure smooth updating (#5030)
                        step: function (val, fx) {
                            series.group.attr({
                                scaleY: mathMax(0.001, fx.pos) // #5250
                            });
                        }
                    }));

                    // delete this function to allow it only once
                    series.animate = null;
                }
            }
        },

        /**
         * Remove this series from the chart
         */
        remove: function () {
            var series = this,
                chart = series.chart;

            // column and bar series affects other series of the same type
            // as they are either stacked or grouped
            if (chart.hasRendered) {
                each(chart.series, function (otherSeries) {
                    if (otherSeries.type === series.type) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            Series.prototype.remove.apply(series, arguments);
        }
    });
    seriesTypes.column = ColumnSeries;
    /**
     * Set the default options for bar
     */
    defaultPlotOptions.bar = merge(defaultPlotOptions.column);
    /**
     * The Bar series class
     */
    var BarSeries = extendClass(ColumnSeries, {
        type: 'bar',
        inverted: true
    });
    seriesTypes.bar = BarSeries;

    /**
     * Set the default options for scatter
     */
    defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
        lineWidth: 0,
        marker: {
            enabled: true // Overrides auto-enabling in line series (#3647)
        },
        tooltip: {
            headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px;"> {series.name}</span><br/>',
            pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'
        }
    });

    /**
     * The scatter series class
     */
    var ScatterSeries = extendClass(Series, {
        type: 'scatter',
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],
        takeOrdinalPosition: false, // #2342
        kdDimensions: 2,
        drawGraph: function () {
            if (this.options.lineWidth) {
                Series.prototype.drawGraph.call(this);
            }
        }
    });

    seriesTypes.scatter = ScatterSeries;

    /**
     * Set the default options for pie
     */
    defaultPlotOptions.pie = merge(defaultSeriesOptions, {
        borderColor: '#FFFFFF',
        borderWidth: 1,
        center: [null, null],
        clip: false,
        colorByPoint: true, // always true for pies
        dataLabels: {
            // align: null,
            // connectorWidth: 1,
            // connectorColor: point.color,
            // connectorPadding: 5,
            distance: 30,
            enabled: true,
            formatter: function () { // #2945
                return this.y === null ? undefined : this.point.name;
            },
            // softConnector: true,
            x: 0
            // y: 0
        },
        ignoreHiddenPoint: true,
        //innerSize: 0,
        legendType: 'point',
        marker: null, // point options are specified in the base options
        size: null,
        showInLegend: false,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: 0.1,
                shadow: false
            }
        },
        stickyTracking: false,
        tooltip: {
            followPointer: true
        }
    });

    /**
     * Extended point object for pies
     */
    var PiePoint = extendClass(Point, {
        /**
         * Initiate the pie slice
         */
        init: function () {

            Point.prototype.init.apply(this, arguments);

            var point = this,
                toggleSlice;

            point.name = pick(point.name, 'Slice');

            // add event listener for select
            toggleSlice = function (e) {
                point.slice(e.type === 'select');
            };
            addEvent(point, 'select', toggleSlice);
            addEvent(point, 'unselect', toggleSlice);

            return point;
        },

        /**
         * Toggle the visibility of the pie slice
         * @param {Boolean} vis Whether to show the slice or not. If undefined, the
         *    visibility is toggled
         */
        setVisible: function (vis, redraw) {
            var point = this,
                series = point.series,
                chart = series.chart,
                ignoreHiddenPoint = series.options.ignoreHiddenPoint;

            redraw = pick(redraw, ignoreHiddenPoint);

            if (vis !== point.visible) {

                // If called without an argument, toggle visibility
                point.visible = point.options.visible = vis = vis === UNDEFINED ? !point.visible : vis;
                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

                // Show and hide associated elements. This is performed regardless of redraw or not,
                // because chart.redraw only handles full series.
                each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function (key) {
                    if (point[key]) {
                        point[key][vis ? 'show' : 'hide'](true);
                    }
                });

                if (point.legendItem) {
                    chart.legend.colorizeItem(point, vis);
                }

                // #4170, hide halo after hiding point
                if (!vis && point.state === 'hover') {
                    point.setState('');
                }

                // Handle ignore hidden slices
                if (ignoreHiddenPoint) {
                    series.isDirty = true;
                }

                if (redraw) {
                    chart.redraw();
                }
            }
        },

        /**
         * Set or toggle whether the slice is cut out from the pie
         * @param {Boolean} sliced When undefined, the slice state is toggled
         * @param {Boolean} redraw Whether to redraw the chart. True by default.
         */
        slice: function (sliced, redraw, animation) {
            var point = this,
                series = point.series,
                chart = series.chart,
                translation;

            setAnimation(animation, chart);

            // redraw is true by default
            redraw = pick(redraw, true);

            // if called without an argument, toggle
            point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
            series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data

            translation = sliced ? point.slicedTranslation : {
                translateX: 0,
                translateY: 0
            };

            point.graphic.animate(translation);

            if (point.shadowGroup) {
                point.shadowGroup.animate(translation);
            }

        },

        haloPath: function (size) {
            var shapeArgs = this.shapeArgs,
                chart = this.series.chart;

            return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(chart.plotLeft + shapeArgs.x, chart.plotTop + shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
                innerR: this.shapeArgs.r,
                start: shapeArgs.start,
                end: shapeArgs.end
            });
        }
    });

    /**
     * The Pie series class
     */
    var PieSeries = {
        type: 'pie',
        isCartesian: false,
        pointClass: PiePoint,
        requireSorting: false,
        directTouch: true,
        noSharedTooltip: true,
        trackerGroups: ['group', 'dataLabelsGroup'],
        axisTypes: [],
        pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
            stroke: 'borderColor',
            'stroke-width': 'borderWidth',
            fill: 'color'
        },

        /**
         * Animate the pies in
         */
        animate: function (init) {
            var series = this,
                points = series.points,
                startAngleRad = series.startAngleRad;

            if (!init) {
                each(points, function (point) {
                    var graphic = point.graphic,
                        args = point.shapeArgs;

                    if (graphic) {
                        // start values
                        graphic.attr({
                            r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)
                            start: startAngleRad,
                            end: startAngleRad
                        });

                        // animate
                        graphic.animate({
                            r: args.r,
                            start: args.start,
                            end: args.end
                        }, series.options.animation);
                    }
                });

                // delete this function to allow it only once
                series.animate = null;
            }
        },

        /**
         * Recompute total chart sum and update percentages of points.
         */
        updateTotals: function () {
            var i,
                total = 0,
                points = this.points,
                len = points.length,
                point,
                ignoreHiddenPoint = this.options.ignoreHiddenPoint;

            // Get the total sum
            for (i = 0; i < len; i++) {
                point = points[i];
                // Disallow negative values (#1530, #3623, #5322)
                if (point.y < 0) {
                    point.y = null;
                }
                total += (ignoreHiddenPoint && !point.visible) ? 0 : point.y;
            }
            this.total = total;

            // Set each point's properties
            for (i = 0; i < len; i++) {
                point = points[i];
                point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;
                point.total = total;
            }
        },

        /**
         * Extend the generatePoints method by adding total and percentage properties to each point
         */
        generatePoints: function () {
            Series.prototype.generatePoints.call(this);
            this.updateTotals();
        },

        /**
         * Do translation for pie slices
         */
        translate: function (positions) {
            this.generatePoints();

            var series = this,
                cumulative = 0,
                precision = 1000, // issue #172
                options = series.options,
                slicedOffset = options.slicedOffset,
                connectorOffset = slicedOffset + options.borderWidth,
                start,
                end,
                angle,
                startAngle = options.startAngle || 0,
                startAngleRad = series.startAngleRad = mathPI / 180 * (startAngle - 90),
                endAngleRad = series.endAngleRad = mathPI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),
                circ = endAngleRad - startAngleRad, //2 * mathPI,
                points = series.points,
                radiusX, // the x component of the radius vector for a given point
                radiusY,
                labelDistance = options.dataLabels.distance,
                ignoreHiddenPoint = options.ignoreHiddenPoint,
                i,
                len = points.length,
                point;

            // Get positions - either an integer or a percentage string must be given.
            // If positions are passed as a parameter, we're in a recursive loop for adjusting
            // space for data labels.
            if (!positions) {
                series.center = positions = series.getCenter();
            }

            // utility for getting the x value from a given y, used for anticollision logic in data labels
            series.getX = function (y, left) {

                angle = math.asin(mathMin((y - positions[1]) / (positions[2] / 2 + labelDistance), 1));

                return positions[0] +
                    (left ? -1 : 1) *
                    (mathCos(angle) * (positions[2] / 2 + labelDistance));
            };

            // Calculate the geometry for each point
            for (i = 0; i < len; i++) {

                point = points[i];

                // set start and end angle
                start = startAngleRad + (cumulative * circ);
                if (!ignoreHiddenPoint || point.visible) {
                    cumulative += point.percentage / 100;
                }
                end = startAngleRad + (cumulative * circ);

                // set the shape
                point.shapeType = 'arc';
                point.shapeArgs = {
                    x: positions[0],
                    y: positions[1],
                    r: positions[2] / 2,
                    innerR: positions[3] / 2,
                    start: mathRound(start * precision) / precision,
                    end: mathRound(end * precision) / precision
                };

                // The angle must stay within -90 and 270 (#2645)
                angle = (end + start) / 2;
                if (angle > 1.5 * mathPI) {
                    angle -= 2 * mathPI;
                } else if (angle < -mathPI / 2) {
                    angle += 2 * mathPI;
                }

                // Center for the sliced out slice
                point.slicedTranslation = {
                    translateX: mathRound(mathCos(angle) * slicedOffset),
                    translateY: mathRound(mathSin(angle) * slicedOffset)
                };

                // set the anchor point for tooltips
                radiusX = mathCos(angle) * positions[2] / 2;
                radiusY = mathSin(angle) * positions[2] / 2;
                point.tooltipPos = [
                    positions[0] + radiusX * 0.7,
                    positions[1] + radiusY * 0.7
                ];

                point.half = angle < -mathPI / 2 || angle > mathPI / 2 ? 1 : 0;
                point.angle = angle;

                // set the anchor point for data labels
                connectorOffset = mathMin(connectorOffset, labelDistance / 2); // #1678
                point.labelPos = [
                    positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
                    positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
                    positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
                    positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
                    positions[0] + radiusX, // landing point for connector
                    positions[1] + radiusY, // a/a
                    labelDistance < 0 ? // alignment
                        'center' :
                        point.half ? 'right' : 'left', // alignment
                    angle // center angle
                ];

            }
        },

        drawGraph: null,

        /**
         * Draw the data points
         */
        drawPoints: function () {
            var series = this,
                chart = series.chart,
                renderer = chart.renderer,
                groupTranslation,
                //center,
                graphic,
                //group,
                shadow = series.options.shadow,
                shadowGroup,
                pointAttr,
                shapeArgs,
                attr;

            if (shadow && !series.shadowGroup) {
                series.shadowGroup = renderer.g('shadow')
                    .add(series.group);
            }

            // draw the slices
            each(series.points, function (point) {
                if (point.y !== null) {
                    graphic = point.graphic;
                    shapeArgs = point.shapeArgs;
                    shadowGroup = point.shadowGroup;
                    pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
                    if (!pointAttr.stroke) {
                        pointAttr.stroke = pointAttr.fill;
                    }

                    // put the shadow behind all points
                    if (shadow && !shadowGroup) {
                        shadowGroup = point.shadowGroup = renderer.g('shadow')
                            .add(series.shadowGroup);
                    }

                    // if the point is sliced, use special translation, else use plot area traslation
                    groupTranslation = point.sliced ? point.slicedTranslation : {
                        translateX: 0,
                        translateY: 0
                    };

                    //group.translate(groupTranslation[0], groupTranslation[1]);
                    if (shadowGroup) {
                        shadowGroup.attr(groupTranslation);
                    }

                    // draw the slice
                    if (graphic) {
                        graphic
                            .setRadialReference(series.center)
                            .attr(pointAttr)
                            .animate(extend(shapeArgs, groupTranslation));
                    } else {
                        attr = { 'stroke-linejoin': 'round' };
                        if (!point.visible) {
                            attr.visibility = 'hidden';
                        }

                        point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                            .setRadialReference(series.center)
                            .attr(pointAttr)
                            .attr(attr)
                            .attr(groupTranslation)
                            .add(series.group)
                            .shadow(shadow, shadowGroup);
                    }
                }
            });

        },


        searchPoint: noop,

        /**
         * Utility for sorting data labels
         */
        sortByAngle: function (points, sign) {
            points.sort(function (a, b) {
                return a.angle !== undefined && (b.angle - a.angle) * sign;
            });
        },

        /**
         * Use a simple symbol from LegendSymbolMixin
         */
        drawLegendSymbol: LegendSymbolMixin.drawRectangle,

        /**
         * Use the getCenter method from drawLegendSymbol
         */
        getCenter: CenteredSeriesMixin.getCenter,

        /**
         * Pies don't have point marker symbols
         */
        getSymbol: noop

    };
    PieSeries = extendClass(Series, PieSeries);
    seriesTypes.pie = PieSeries;

    /**
     * Draw the data labels
     */
    Series.prototype.drawDataLabels = function () {

        var series = this,
            seriesOptions = series.options,
            cursor = seriesOptions.cursor,
            options = seriesOptions.dataLabels,
            points = series.points,
            pointOptions,
            generalOptions,
            hasRendered = series.hasRendered || 0,
            str,
            dataLabelsGroup,
            defer = pick(options.defer, true),
            renderer = series.chart.renderer;

        if (options.enabled || series._hasPointLabels) {

            // Process default alignment of data labels for columns
            if (series.dlProcessOptions) {
                series.dlProcessOptions(options);
            }

            // Create a separate group for the data labels to avoid rotation
            dataLabelsGroup = series.plotGroup(
                'dataLabelsGroup',
                'data-labels',
                defer && !hasRendered ? 'hidden' : 'visible', // #5133
                options.zIndex || 6
            );

            if (defer) {
                dataLabelsGroup.attr({ opacity: +hasRendered }); // #3300
                if (!hasRendered) {
                    addEvent(series, 'afterAnimate', function () {
                        if (series.visible) { // #2597, #3023, #3024
                            dataLabelsGroup.show(true);
                        }
                        dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({ opacity: 1 }, { duration: 200 });
                    });
                }
            }

            // Make the labels for each point
            generalOptions = options;
            each(points, function (point) {

                var enabled,
                    dataLabel = point.dataLabel,
                    labelConfig,
                    attr,
                    name,
                    rotation,
                    connector = point.connector,
                    isNew = true,
                    style,
                    moreStyle = {};

                // Determine if each data label is enabled
                pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps
                enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641


                // If the point is outside the plot area, destroy it. #678, #820
                if (dataLabel && !enabled) {
                    point.dataLabel = dataLabel.destroy();

                // Individual labels are disabled if the are explicitly disabled
                // in the point options, or if they fall outside the plot area.
                } else if (enabled) {

                    // Create individual options structure that can be extended without
                    // affecting others
                    options = merge(generalOptions, pointOptions);
                    style = options.style;

                    rotation = options.rotation;

                    // Get the string
                    labelConfig = point.getLabelConfig();
                    str = options.format ?
                        format(options.format, labelConfig) :
                        options.formatter.call(labelConfig, options);

                    // Determine the color
                    style.color = pick(options.color, style.color, series.color, 'black');


                    // update existing label
                    if (dataLabel) {

                        if (defined(str)) {
                            dataLabel
                                .attr({
                                    text: str
                                });
                            isNew = false;

                        } else { // #1437 - the label is shown conditionally
                            point.dataLabel = dataLabel = dataLabel.destroy();
                            if (connector) {
                                point.connector = connector.destroy();
                            }
                        }

                    // create new label
                    } else if (defined(str)) {
                        attr = {
                            //align: align,
                            fill: options.backgroundColor,
                            stroke: options.borderColor,
                            'stroke-width': options.borderWidth,
                            r: options.borderRadius || 0,
                            rotation: rotation,
                            padding: options.padding,
                            zIndex: 1
                        };

                        // Get automated contrast color
                        if (style.color === 'contrast') {
                            moreStyle.color = options.inside || options.distance < 0 || !!seriesOptions.stacking ?
                                renderer.getContrast(point.color || series.color) :
                                '#000000';
                        }
                        if (cursor) {
                            moreStyle.cursor = cursor;
                        }


                        // Remove unused attributes (#947)
                        for (name in attr) {
                            if (attr[name] === UNDEFINED) {
                                delete attr[name];
                            }
                        }

                        dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation
                            str,
                            0,
                            -9999,
                            options.shape,
                            null,
                            null,
                            options.useHTML
                        )
                        .attr(attr)
                        .css(extend(style, moreStyle))
                        .add(dataLabelsGroup)
                        .shadow(options.shadow);

                    }

                    if (dataLabel) {
                        // Now the data label is created and placed at 0,0, so we need to align it
                        series.alignDataLabel(point, dataLabel, options, null, isNew);
                    }
                }
            });
        }
    };

    /**
     * Align each individual data label
     */
    Series.prototype.alignDataLabel = function (point, dataLabel, options, alignTo, isNew) {
        var chart = this.chart,
            inverted = chart.inverted,
            plotX = pick(point.plotX, -9999),
            plotY = pick(point.plotY, -9999),
            bBox = dataLabel.getBBox(),
            baseline = chart.renderer.fontMetrics(options.style.fontSize).b,
            rotation = options.rotation,
            normRotation,
            negRotation,
            align = options.align,
            rotCorr, // rotation correction
            // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)
            visible = this.visible && (point.series.forceDL || chart.isInsidePlot(plotX, mathRound(plotY), inverted) ||
                (alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, inverted))),
            alignAttr, // the final position;
            justify = pick(options.overflow, 'justify') === 'justify';

        if (visible) {

            // The alignment box is a singular point
            alignTo = extend({
                x: inverted ? chart.plotWidth - plotY : plotX,
                y: mathRound(inverted ? chart.plotHeight - plotX : plotY),
                width: 0,
                height: 0
            }, alignTo);

            // Add the text size for alignment calculation
            extend(options, {
                width: bBox.width,
                height: bBox.height
            });

            // Allow a hook for changing alignment in the last moment, then do the alignment
            if (rotation) {
                justify = false; // Not supported for rotated text
                rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723
                alignAttr = {
                    x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,
                    y: alignTo.y + options.y + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height
                };
                dataLabel[isNew ? 'attr' : 'animate'](alignAttr)
                    .attr({ // #3003
                        align: align
                    });

                // Compensate for the rotated label sticking out on the sides
                normRotation = (rotation + 720) % 360;
                negRotation = normRotation > 180 && normRotation < 360;

                if (align === 'left') {
                    alignAttr.y -= negRotation ? bBox.height : 0;
                } else if (align === 'center') {
                    alignAttr.x -= bBox.width / 2;
                    alignAttr.y -= bBox.height / 2;
                } else if (align === 'right') {
                    alignAttr.x -= bBox.width;
                    alignAttr.y -= negRotation ? 0 : bBox.height;
                }
            

            } else {
                dataLabel.align(options, null, alignTo);
                alignAttr = dataLabel.alignAttr;
            }

            // Handle justify or crop
            if (justify) {
                this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
            
            // Now check that the data label is within the plot area
            } else if (pick(options.crop, true)) {
                visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
            }

            // When we're using a shape, make it possible with a connector or an arrow pointing to thie point
            if (options.shape && !rotation) {
                dataLabel.attr({
                    anchorX: point.plotX,
                    anchorY: point.plotY
                });
            }
        }

        // Show or hide based on the final aligned position
        if (!visible) {
            stop(dataLabel);
            dataLabel.attr({ y: -9999 });
            dataLabel.placed = false; // don't animate back in
        }

    };

    /**
     * If data labels fall partly outside the plot area, align them back in, in a way that
     * doesn't hide the point.
     */
    Series.prototype.justifyDataLabel = function (dataLabel, options, alignAttr, bBox, alignTo, isNew) {
        var chart = this.chart,
            align = options.align,
            verticalAlign = options.verticalAlign,
            off,
            justified,
            padding = dataLabel.box ? 0 : (dataLabel.padding || 0);

        // Off left
        off = alignAttr.x + padding;
        if (off < 0) {
            if (align === 'right') {
                options.align = 'left';
            } else {
                options.x = -off;
            }
            justified = true;
        }

        // Off right
        off = alignAttr.x + bBox.width - padding;
        if (off > chart.plotWidth) {
            if (align === 'left') {
                options.align = 'right';
            } else {
                options.x = chart.plotWidth - off;
            }
            justified = true;
        }

        // Off top
        off = alignAttr.y + padding;
        if (off < 0) {
            if (verticalAlign === 'bottom') {
                options.verticalAlign = 'top';
            } else {
                options.y = -off;
            }
            justified = true;
        }

        // Off bottom
        off = alignAttr.y + bBox.height - padding;
        if (off > chart.plotHeight) {
            if (verticalAlign === 'top') {
                options.verticalAlign = 'bottom';
            } else {
                options.y = chart.plotHeight - off;
            }
            justified = true;
        }

        if (justified) {
            dataLabel.placed = !isNew;
            dataLabel.align(options, null, alignTo);
        }
    };

    /**
     * Override the base drawDataLabels method by pie specific functionality
     */
    if (seriesTypes.pie) {
        seriesTypes.pie.prototype.drawDataLabels = function () {
            var series = this,
                data = series.data,
                point,
                chart = series.chart,
                options = series.options.dataLabels,
                connectorPadding = pick(options.connectorPadding, 10),
                connectorWidth = pick(options.connectorWidth, 1),
                plotWidth = chart.plotWidth,
                plotHeight = chart.plotHeight,
                connector,
                connectorPath,
                softConnector = pick(options.softConnector, true),
                distanceOption = options.distance,
                seriesCenter = series.center,
                radius = seriesCenter[2] / 2,
                centerY = seriesCenter[1],
                outside = distanceOption > 0,
                dataLabel,
                dataLabelWidth,
                labelPos,
                labelHeight,
                halves = [// divide the points into right and left halves for anti collision
                    [], // right
                    []  // left
                ],
                x,
                y,
                visibility,
                rankArr,
                i,
                j,
                overflow = [0, 0, 0, 0], // top, right, bottom, left
                sort = function (a, b) {
                    return b.y - a.y;
                };

            // get out if not enabled
            if (!series.visible || (!options.enabled && !series._hasPointLabels)) {
                return;
            }

            // run parent method
            Series.prototype.drawDataLabels.apply(series);

            each(data, function (point) {
                if (point.dataLabel && point.visible) { // #407, #2510

                    // Arrange points for detection collision
                    halves[point.half].push(point);

                    // Reset positions (#4905)
                    point.dataLabel._pos = null;
                }
            });

            /* Loop over the points in each half, starting from the top and bottom
             * of the pie to detect overlapping labels.
             */
            i = 2;
            while (i--) {

                var slots = [],
                    slotsLength,
                    usedSlots = [],
                    points = halves[i],
                    pos,
                    bottom,
                    length = points.length,
                    slotIndex;

                if (!length) {
                    continue;
                }

                // Sort by angle
                series.sortByAngle(points, i - 0.5);

                // Assume equal label heights on either hemisphere (#2630)
                j = labelHeight = 0;
                while (!labelHeight && points[j]) { // #1569
                    labelHeight = points[j] && points[j].dataLabel && (points[j].dataLabel.getBBox().height || 21); // 21 is for #968
                    j++;
                }

                // Only do anti-collision when we are outside the pie and have connectors (#856)
                if (distanceOption > 0) {

                    // Build the slots
                    bottom = mathMin(centerY + radius + distanceOption, chart.plotHeight);
                    for (pos = mathMax(0, centerY - radius - distanceOption); pos <= bottom; pos += labelHeight) {
                        slots.push(pos);
                    }
                    slotsLength = slots.length;


                    /* Visualize the slots
                    if (!series.slotElements) {
                        series.slotElements = [];
                    }
                    if (i === 1) {
                        series.slotElements.forEach(function (elem) {
                            elem.destroy();
                        });
                        series.slotElements.length = 0;
                    }

                    slots.forEach(function (pos, no) {
                        var slotX = series.getX(pos, i) + chart.plotLeft - (i ? 100 : 0),
                            slotY = pos + chart.plotTop;

                        if (isNumber(slotX)) {
                            series.slotElements.push(chart.renderer.rect(slotX, slotY - 7, 100, labelHeight, 1)
                                .attr({
                                    'stroke-width': 1,
                                    stroke: 'silver',
                                    fill: 'rgba(0,0,255,0.1)'
                                })
                                .add());
                            series.slotElements.push(chart.renderer.text('Slot '+ no, slotX, slotY + 4)
                                .attr({
                                    fill: 'silver'
                                }).add());
                        }
                    });
                    // */

                    // if there are more values than available slots, remove lowest values
                    if (length > slotsLength) {
                        // create an array for sorting and ranking the points within each quarter
                        rankArr = [].concat(points);
                        rankArr.sort(sort);
                        j = length;
                        while (j--) {
                            rankArr[j].rank = j;
                        }
                        j = length;
                        while (j--) {
                            if (points[j].rank >= slotsLength) {
                                points.splice(j, 1);
                            }
                        }
                        length = points.length;
                    }

                    // The label goes to the nearest open slot, but not closer to the edge than
                    // the label's index.
                    for (j = 0; j < length; j++) {

                        point = points[j];
                        labelPos = point.labelPos;

                        var closest = 9999,
                            distance,
                            slotI;

                        // find the closest slot index
                        for (slotI = 0; slotI < slotsLength; slotI++) {
                            distance = mathAbs(slots[slotI] - labelPos[1]);
                            if (distance < closest) {
                                closest = distance;
                                slotIndex = slotI;
                            }
                        }

                        // if that slot index is closer to the edges of the slots, move it
                        // to the closest appropriate slot
                        if (slotIndex < j && slots[j] !== null) { // cluster at the top
                            slotIndex = j;
                        } else if (slotsLength  < length - j + slotIndex && slots[j] !== null) { // cluster at the bottom
                            slotIndex = slotsLength - length + j;
                            while (slots[slotIndex] === null) { // make sure it is not taken
                                slotIndex++;
                            }
                        } else {
                            // Slot is taken, find next free slot below. In the next run, the next slice will find the
                            // slot above these, because it is the closest one
                            while (slots[slotIndex] === null) { // make sure it is not taken
                                slotIndex++;
                            }
                        }

                        usedSlots.push({ i: slotIndex, y: slots[slotIndex] });
                        slots[slotIndex] = null; // mark as taken
                    }
                    // sort them in order to fill in from the top
                    usedSlots.sort(sort);
                }

                // now the used slots are sorted, fill them up sequentially
                for (j = 0; j < length; j++) {

                    var slot, naturalY;

                    point = points[j];
                    labelPos = point.labelPos;
                    dataLabel = point.dataLabel;
                    visibility = point.visible === false ? HIDDEN : 'inherit';
                    naturalY = labelPos[1];

                    if (distanceOption > 0) {
                        slot = usedSlots.pop();
                        slotIndex = slot.i;

                        // if the slot next to currrent slot is free, the y value is allowed
                        // to fall back to the natural position
                        y = slot.y;
                        if ((naturalY > y && slots[slotIndex + 1] !== null) ||
                                (naturalY < y &&  slots[slotIndex - 1] !== null)) {
                            y = mathMin(mathMax(0, naturalY), chart.plotHeight);
                        }

                    } else {
                        y = naturalY;
                    }

                    // get the x - use the natural x position for first and last slot, to prevent the top
                    // and botton slice connectors from touching each other on either side
                    x = options.justify ?
                        seriesCenter[0] + (i ? -1 : 1) * (radius + distanceOption) :
                        series.getX(y === centerY - radius - distanceOption || y === centerY + radius + distanceOption ? naturalY : y, i);


                    // Record the placement and visibility
                    dataLabel._attr = {
                        visibility: visibility,
                        align: labelPos[6]
                    };
                    dataLabel._pos = {
                        x: x + options.x +
                            ({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
                        y: y + options.y - 10 // 10 is for the baseline (label vs text)
                    };
                    dataLabel.connX = x;
                    dataLabel.connY = y;


                    // Detect overflowing data labels
                    if (this.options.size === null) {
                        dataLabelWidth = dataLabel.width;
                        // Overflow left
                        if (x - dataLabelWidth < connectorPadding) {
                            overflow[3] = mathMax(mathRound(dataLabelWidth - x + connectorPadding), overflow[3]);

                        // Overflow right
                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {
                            overflow[1] = mathMax(mathRound(x + dataLabelWidth - plotWidth + connectorPadding), overflow[1]);
                        }

                        // Overflow top
                        if (y - labelHeight / 2 < 0) {
                            overflow[0] = mathMax(mathRound(-y + labelHeight / 2), overflow[0]);

                        // Overflow left
                        } else if (y + labelHeight / 2 > plotHeight) {
                            overflow[2] = mathMax(mathRound(y + labelHeight / 2 - plotHeight), overflow[2]);
                        }
                    }
                } // for each point
            } // for each half

            // Do not apply the final placement and draw the connectors until we have verified
            // that labels are not spilling over.
            if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {

                // Place the labels in the final position
                this.placeDataLabels();

                // Draw the connectors
                if (outside && connectorWidth) {
                    each(this.points, function (point) {
                        connector = point.connector;
                        labelPos = point.labelPos;
                        dataLabel = point.dataLabel;

                        if (dataLabel && dataLabel._pos && point.visible) {
                            visibility = dataLabel._attr.visibility;
                            x = dataLabel.connX;
                            y = dataLabel.connY;
                            connectorPath = softConnector ? [
                                M,
                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
                                'C',
                                x, y, // first break, next to the label
                                2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],
                                labelPos[2], labelPos[3], // second break
                                L,
                                labelPos[4], labelPos[5] // base
                            ] : [
                                M,
                                x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label
                                L,
                                labelPos[2], labelPos[3], // second break
                                L,
                                labelPos[4], labelPos[5] // base
                            ];

                            if (connector) {
                                connector.animate({ d: connectorPath });
                                connector.attr('visibility', visibility);

                            } else {
                                point.connector = connector = series.chart.renderer.path(connectorPath).attr({
                                    'stroke-width': connectorWidth,
                                    stroke: options.connectorColor || point.color || '#606060',
                                    visibility: visibility
                                    //zIndex: 0 // #2722 (reversed)
                                })
                                .add(series.dataLabelsGroup);
                            }
                        } else if (connector) {
                            point.connector = connector.destroy();
                        }
                    });
                }
            }
        };
        /**
         * Perform the final placement of the data labels after we have verified that they
         * fall within the plot area.
         */
        seriesTypes.pie.prototype.placeDataLabels = function () {
            each(this.points, function (point) {
                var dataLabel = point.dataLabel,
                    _pos;

                if (dataLabel && point.visible) {
                    _pos = dataLabel._pos;
                    if (_pos) {
                        dataLabel.attr(dataLabel._attr);
                        dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);
                        dataLabel.moved = true;
                    } else if (dataLabel) {
                        dataLabel.attr({ y: -9999 });
                    }
                }
            });
        };

        seriesTypes.pie.prototype.alignDataLabel =  noop;

        /**
         * Verify whether the data labels are allowed to draw, or we should run more translation and data
         * label positioning to keep them inside the plot area. Returns true when data labels are ready
         * to draw.
         */
        seriesTypes.pie.prototype.verifyDataLabelOverflow = function (overflow) {

            var center = this.center,
                options = this.options,
                centerOption = options.center,
                minSize = options.minSize || 80,
                newSize = minSize,
                ret;

            // Handle horizontal size and center
            if (centerOption[0] !== null) { // Fixed center
                newSize = mathMax(center[2] - mathMax(overflow[1], overflow[3]), minSize);

            } else { // Auto center
                newSize = mathMax(
                    center[2] - overflow[1] - overflow[3], // horizontal overflow
                    minSize
                );
                center[0] += (overflow[3] - overflow[1]) / 2; // horizontal center
            }

            // Handle vertical size and center
            if (centerOption[1] !== null) { // Fixed center
                newSize = mathMax(mathMin(newSize, center[2] - mathMax(overflow[0], overflow[2])), minSize);

            } else { // Auto center
                newSize = mathMax(
                    mathMin(
                        newSize,
                        center[2] - overflow[0] - overflow[2] // vertical overflow
                    ),
                    minSize
                );
                center[1] += (overflow[0] - overflow[2]) / 2; // vertical center
            }

            // If the size must be decreased, we need to run translate and drawDataLabels again
            if (newSize < center[2]) {
                center[2] = newSize;
                center[3] = Math.min(relativeLength(options.innerSize || 0, newSize), newSize); // #3632
                this.translate(center);
            
                if (this.drawDataLabels) {
                    this.drawDataLabels();
                }
            // Else, return true to indicate that the pie and its labels is within the plot area
            } else {
                ret = true;
            }
            return ret;
        };
    }

    if (seriesTypes.column) {

        /**
         * Override the basic data label alignment by adjusting for the position of the column
         */
        seriesTypes.column.prototype.alignDataLabel = function (point, dataLabel, options,  alignTo, isNew) {
            var inverted = this.chart.inverted,
                series = point.series,
                dlBox = point.dlBox || point.shapeArgs, // data label box for alignment
                below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series
                inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?
                overshoot;

            // Align to the column itself, or the top of it
            if (dlBox) { // Area range uses this method but not alignTo
                alignTo = merge(dlBox);

                if (alignTo.y < 0) {
                    alignTo.height += alignTo.y;
                    alignTo.y = 0;
                }
                overshoot = alignTo.y + alignTo.height - series.yAxis.len;
                if (overshoot > 0) {
                    alignTo.height -= overshoot;
                }

                if (inverted) {
                    alignTo = {
                        x: series.yAxis.len - alignTo.y - alignTo.height,
                        y: series.xAxis.len - alignTo.x - alignTo.width,
                        width: alignTo.height,
                        height: alignTo.width
                    };
                }

                // Compute the alignment box
                if (!inside) {
                    if (inverted) {
                        alignTo.x += below ? 0 : alignTo.width;
                        alignTo.width = 0;
                    } else {
                        alignTo.y += below ? alignTo.height : 0;
                        alignTo.height = 0;
                    }
                }
            }


            // When alignment is undefined (typically columns and bars), display the individual
            // point below or above the point depending on the threshold
            options.align = pick(
                options.align,
                !inverted || inside ? 'center' : below ? 'right' : 'left'
            );
            options.verticalAlign = pick(
                options.verticalAlign,
                inverted || inside ? 'middle' : below ? 'top' : 'bottom'
            );

            // Call the parent method
            Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
        };
    }



    /**
     * Highcharts module to hide overlapping data labels. This module is included in Highcharts.
     */
    (function (H) {
        var Chart = H.Chart,
            each = H.each,
            pick = H.pick,
            addEvent = H.addEvent;

        // Collect potensial overlapping data labels. Stack labels probably don't need to be 
        // considered because they are usually accompanied by data labels that lie inside the columns.
        Chart.prototype.callbacks.push(function (chart) {
            function collectAndHide() {
                var labels = [];

                each(chart.series, function (series) {
                    var dlOptions = series.options.dataLabels,
                        collections = series.dataLabelCollections || ['dataLabel']; // Range series have two collections
                    if ((dlOptions.enabled || series._hasPointLabels) && !dlOptions.allowOverlap && series.visible) { // #3866
                        each(collections, function (coll) {
                            each(series.points, function (point) {
                                if (point[coll]) {
                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs && point.shapeArgs.height); // #4118
                                    labels.push(point[coll]);
                                }
                            });
                        });
                    }
                });
                chart.hideOverlappingLabels(labels);
            }

            // Do it now ...
            collectAndHide();

            // ... and after each chart redraw
            addEvent(chart, 'redraw', collectAndHide);

        });

        /**
         * Hide overlapping labels. Labels are moved and faded in and out on zoom to provide a smooth 
         * visual imression.
         */    
        Chart.prototype.hideOverlappingLabels = function (labels) {

            var len = labels.length,
                label,
                i,
                j,
                label1,
                label2,
                isIntersecting,
                pos1,
                pos2,
                parent1,
                parent2,
                padding,
                intersectRect = function (x1, y1, w1, h1, x2, y2, w2, h2) {
                    return !(
                        x2 > x1 + w1 ||
                        x2 + w2 < x1 ||
                        y2 > y1 + h1 ||
                        y2 + h2 < y1
                    );
                };
    
            // Mark with initial opacity
            for (i = 0; i < len; i++) {
                label = labels[i];
                if (label) {
                    label.oldOpacity = label.opacity;
                    label.newOpacity = 1;
                }
            }

            // Prevent a situation in a gradually rising slope, that each label
            // will hide the previous one because the previous one always has
            // lower rank.
            labels.sort(function (a, b) {
                return (b.labelrank || 0) - (a.labelrank || 0);
            });

            // Detect overlapping labels
            for (i = 0; i < len; i++) {
                label1 = labels[i];

                for (j = i + 1; j < len; ++j) {
                    label2 = labels[j];
                    if (label1 && label2 && label1.placed && label2.placed && label1.newOpacity !== 0 && label2.newOpacity !== 0) {
                        pos1 = label1.alignAttr;
                        pos2 = label2.alignAttr;
                        parent1 = label1.parentGroup; // Different panes have different positions
                        parent2 = label2.parentGroup;
                        padding = 2 * (label1.box ? 0 : label1.padding); // Substract the padding if no background or border (#4333)
                        isIntersecting = intersectRect(
                            pos1.x + parent1.translateX,
                            pos1.y + parent1.translateY,
                            label1.width - padding,
                            label1.height - padding,
                            pos2.x + parent2.translateX,
                            pos2.y + parent2.translateY,
                            label2.width - padding,
                            label2.height - padding
                        );

                        if (isIntersecting) {
                            (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
                        }
                    }
                }
            }

            // Hide or show
            each(labels, function (label) {
                var complete,
                    newOpacity;

                if (label) {
                    newOpacity = label.newOpacity;

                    if (label.oldOpacity !== newOpacity && label.placed) {

                        // Make sure the label is completely hidden to avoid catching clicks (#4362)
                        if (newOpacity) {
                            label.show(true);
                        } else {
                            complete = function () {
                                label.hide();
                            };
                        }

                        // Animate or set the opacity                
                        label.alignAttr.opacity = newOpacity;
                        label[label.isOld ? 'animate' : 'attr'](label.alignAttr, null, complete);
                    
                    }
                    label.isOld = true;
                }
            });
        };
    }(Highcharts));
    /**
     * TrackerMixin for points and graphs
     */

    var TrackerMixin = Highcharts.TrackerMixin = {

        drawTrackerPoint: function () {
            var series = this,
                chart = series.chart,
                pointer = chart.pointer,
                cursor = series.options.cursor,
                css = cursor && { cursor: cursor },
                onMouseOver = function (e) {
                    var target = e.target,
                        point;

                    while (target && !point) {
                        point = target.point;
                        target = target.parentNode;
                    }

                    if (point !== UNDEFINED && point !== chart.hoverPoint) { // undefined on graph in scatterchart
                        point.onMouseOver(e);
                    }
                };

            // Add reference to the point
            each(series.points, function (point) {
                if (point.graphic) {
                    point.graphic.element.point = point;
                }
                if (point.dataLabel) {
                    point.dataLabel.element.point = point;
                }
            });

            // Add the event listeners, we need to do this only once
            if (!series._hasTracking) {
                each(series.trackerGroups, function (key) {
                    if (series[key]) { // we don't always have dataLabelsGroup
                        series[key]
                            .addClass(PREFIX + 'tracker')
                            .on('mouseover', onMouseOver)
                            .on('mouseout', function (e) {
                                pointer.onTrackerMouseOut(e);
                            })
                            .css(css);
                        if (hasTouch) {
                            series[key].on('touchstart', onMouseOver);
                        }
                    }
                });
                series._hasTracking = true;
            }
        },

        /**
         * Draw the tracker object that sits above all data labels and markers to
         * track mouse events on the graph or points. For the line type charts
         * the tracker uses the same graphPath, but with a greater stroke width
         * for better control.
         */
        drawTrackerGraph: function () {
            var series = this,
                options = series.options,
                trackByArea = options.trackByArea,
                trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
                trackerPathLength = trackerPath.length,
                chart = series.chart,
                pointer = chart.pointer,
                renderer = chart.renderer,
                snap = chart.options.tooltip.snap,
                tracker = series.tracker,
                cursor = options.cursor,
                css = cursor && { cursor: cursor },
                i,
                onMouseOver = function () {
                    if (chart.hoverSeries !== series) {
                        series.onMouseOver();
                    }
                },
                /*
                 * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable
                 * IE6: 0.002
                 * IE7: 0.002
                 * IE8: 0.002
                 * IE9: 0.00000000001 (unlimited)
                 * IE10: 0.0001 (exporting only)
                 * FF: 0.00000000001 (unlimited)
                 * Chrome: 0.000001
                 * Safari: 0.000001
                 * Opera: 0.00000000001 (unlimited)
                 */
                TRACKER_FILL = 'rgba(192,192,192,' + (hasSVG ? 0.0001 : 0.002) + ')';

            // Extend end points. A better way would be to use round linecaps,
            // but those are not clickable in VML.
            if (trackerPathLength && !trackByArea) {
                i = trackerPathLength + 1;
                while (i--) {
                    if (trackerPath[i] === M) { // extend left side
                        trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
                    }
                    if ((i && trackerPath[i] === M) || i === trackerPathLength) { // extend right side
                        trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
                    }
                }
            }

            // handle single points
            /*for (i = 0; i < singlePoints.length; i++) {
                singlePoint = singlePoints[i];
                trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
                L, singlePoint.plotX + snap, singlePoint.plotY);
            }*/

            // draw the tracker
            if (tracker) {
                tracker.attr({ d: trackerPath });
            } else { // create

                series.tracker = renderer.path(trackerPath)
                .attr({
                    'stroke-linejoin': 'round', // #1225
                    visibility: series.visible ? VISIBLE : HIDDEN,
                    stroke: TRACKER_FILL,
                    fill: trackByArea ? TRACKER_FILL : NONE,
                    'stroke-width': options.lineWidth + (trackByArea ? 0 : 2 * snap),
                    zIndex: 2
                })
                .add(series.group);

                // The tracker is added to the series group, which is clipped, but is covered
                // by the marker group. So the marker group also needs to capture events.
                each([series.tracker, series.markerGroup], function (tracker) {
                    tracker.addClass(PREFIX + 'tracker')
                        .on('mouseover', onMouseOver)
                        .on('mouseout', function (e) {
                            pointer.onTrackerMouseOut(e);
                        })
                        .css(css);

                    if (hasTouch) {
                        tracker.on('touchstart', onMouseOver);
                    }
                });
            }
        }
    };
    /* End TrackerMixin */


    /**
     * Add tracking event listener to the series group, so the point graphics
     * themselves act as trackers
     */

    if (seriesTypes.column) {
        ColumnSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }

    if (seriesTypes.pie) {
        seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }

    if (seriesTypes.scatter) {
        ScatterSeries.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
    }

    /*
     * Extend Legend for item events
     */
    extend(Legend.prototype, {

        setItemEvents: function (item, legendItem, useHTML, itemStyle, itemHiddenStyle) {
            var legend = this;
            // Set the events on the item group, or in case of useHTML, the item itself (#1249)
            (useHTML ? legendItem : item.legendGroup).on('mouseover', function () {
                item.setState(HOVER_STATE);
                legendItem.css(legend.options.itemHoverStyle);
            })
            .on('mouseout', function () {
                legendItem.css(item.visible ? itemStyle : itemHiddenStyle);
                item.setState();
            })
            .on('click', function (event) {
                var strLegendItemClick = 'legendItemClick',
                    fnLegendItemClick = function () {
                        if (item.setVisible) {
                            item.setVisible();
                        }
                    };

                // Pass over the click/touch event. #4.
                event = {
                    browserEvent: event
                };

                // click the name or symbol
                if (item.firePointEvent) { // point
                    item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                } else {
                    fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                }
            });
        },

        createCheckboxForItem: function (item) {
            var legend = this;

            item.checkbox = createElement('input', {
                type: 'checkbox',
                checked: item.selected,
                defaultChecked: item.selected // required by IE7
            }, legend.options.itemCheckboxStyle, legend.chart.container);

            addEvent(item.checkbox, 'click', function (event) {
                var target = event.target;
                fireEvent(
                    item.series || item, 
                    'checkboxClick', 
                    { // #3712
                        checked: target.checked,
                        item: item
                    },
                    function () {
                        item.select();
                    }
                );
            });
        }
    });

    /*
     * Add pointer cursor to legend itemstyle in defaultOptions
     */
    defaultOptions.legend.itemStyle.cursor = 'pointer';


    /*
     * Extend the Chart object with interaction
     */

    extend(Chart.prototype, {
        /**
         * Display the zoom button
         */
        showResetZoom: function () {
            var chart = this,
                lang = defaultOptions.lang,
                btnOptions = chart.options.chart.resetZoomButton,
                theme = btnOptions.theme,
                states = theme.states,
                alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';

            function zoomOut() {
                chart.zoomOut();
            }

            this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)
                .attr({
                    align: btnOptions.position.align,
                    title: lang.resetZoomTitle
                })
                .add()
                .align(btnOptions.position, false, alignTo);

        },

        /**
         * Zoom out to 1:1
         */
        zoomOut: function () {
            var chart = this;
            fireEvent(chart, 'selection', { resetSelection: true }, function () {
                chart.zoom();
            });
        },

        /**
         * Zoom into a given portion of the chart given by axis coordinates
         * @param {Object} event
         */
        zoom: function (event) {
            var chart = this,
                hasZoomed,
                pointer = chart.pointer,
                displayButton = false,
                resetZoomButton;

            // If zoom is called with no arguments, reset the axes
            if (!event || event.resetSelection) {
                each(chart.axes, function (axis) {
                    hasZoomed = axis.zoom();
                });
            } else { // else, zoom in on all axes
                each(event.xAxis.concat(event.yAxis), function (axisData) {
                    var axis = axisData.axis,
                        isXAxis = axis.isXAxis;

                    // don't zoom more than minRange
                    if (pointer[isXAxis ? 'zoomX' : 'zoomY'] || pointer[isXAxis ? 'pinchX' : 'pinchY']) {
                        hasZoomed = axis.zoom(axisData.min, axisData.max);
                        if (axis.displayBtn) {
                            displayButton = true;
                        }
                    }
                });
            }

            // Show or hide the Reset zoom button
            resetZoomButton = chart.resetZoomButton;
            if (displayButton && !resetZoomButton) {
                chart.showResetZoom();
            } else if (!displayButton && isObject(resetZoomButton)) {
                chart.resetZoomButton = resetZoomButton.destroy();
            }


            // Redraw
            if (hasZoomed) {
                chart.redraw(
                    pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation
                );
            }
        },

        /**
         * Pan the chart by dragging the mouse across the pane. This function is called
         * on mouse move, and the distance to pan is computed from chartX compared to
         * the first chartX position in the dragging operation.
         */
        pan: function (e, panning) {

            var chart = this,
                hoverPoints = chart.hoverPoints,
                doRedraw;

            // remove active points for shared tooltip
            if (hoverPoints) {
                each(hoverPoints, function (point) {
                    point.setState();
                });
            }

            each(panning === 'xy' ? [1, 0] : [1], function (isX) { // xy is used in maps
                var axis = chart[isX ? 'xAxis' : 'yAxis'][0],
                    horiz = axis.horiz,
                    mousePos = e[horiz ? 'chartX' : 'chartY'],
                    mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',
                    startPos = chart[mouseDown],
                    halfPointRange = (axis.pointRange || 0) / 2,
                    extremes = axis.getExtremes(),
                    newMin = axis.toValue(startPos - mousePos, true) + halfPointRange,
                    newMax = axis.toValue(startPos + axis.len - mousePos, true) - halfPointRange,
                    goingLeft = startPos > mousePos; // #3613
            
                if (axis.series.length &&
                        (goingLeft || newMin > mathMin(extremes.dataMin, extremes.min)) &&    
                        (!goingLeft || newMax < mathMax(extremes.dataMax, extremes.max))) {
                    axis.setExtremes(newMin, newMax, false, false, { trigger: 'pan' });
                    doRedraw = true;
                }

                chart[mouseDown] = mousePos; // set new reference for next run
            });

            if (doRedraw) {
                chart.redraw(false);
            }
            css(chart.container, { cursor: 'move' });
        }
    });

    /*
     * Extend the Point object with interaction
     */
    extend(Point.prototype, {
        /**
         * Toggle the selection status of a point
         * @param {Boolean} selected Whether to select or unselect the point.
         * @param {Boolean} accumulate Whether to add to the previous selection. By default,
         *         this happens if the control key (Cmd on Mac) was pressed during clicking.
         */
        select: function (selected, accumulate) {
            var point = this,
                series = point.series,
                chart = series.chart;

            selected = pick(selected, !point.selected);

            // fire the event with the default handler
            point.firePointEvent(selected ? 'select' : 'unselect', { accumulate: accumulate }, function () {
                point.selected = point.options.selected = selected;
                series.options.data[inArray(point, series.data)] = point.options;

                point.setState(selected && SELECT_STATE);

                // unselect all other points unless Ctrl or Cmd + click
                if (!accumulate) {
                    each(chart.getSelectedPoints(), function (loopPoint) {
                        if (loopPoint.selected && loopPoint !== point) {
                            loopPoint.selected = loopPoint.options.selected = false;
                            series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                            loopPoint.setState(NORMAL_STATE);
                            loopPoint.firePointEvent('unselect');
                        }
                    });
                }
            });
        },

        /**
         * Runs on mouse over the point
         *
         * @param {Object} e The event arguments
         * @param {Boolean} byProximity Falsy for kd points that are closest to the mouse, or to
         *        actually hovered points. True for other points in shared tooltip.
         */
        onMouseOver: function (e, byProximity) {
            var point = this,
                series = point.series,
                chart = series.chart,
                tooltip = chart.tooltip,
                hoverPoint = chart.hoverPoint;

            if (chart.hoverSeries !== series) {
                series.onMouseOver();
            }

            // set normal state to previous series
            if (hoverPoint && hoverPoint !== point) {
                hoverPoint.onMouseOut();
            }

            if (point.series) { // It may have been destroyed, #4130

                // trigger the event
                point.firePointEvent('mouseOver');

                // update the tooltip
                if (tooltip && (!tooltip.shared || series.noSharedTooltip)) {
                    tooltip.refresh(point, e);
                }

                // hover this
                point.setState(HOVER_STATE);
                if (!byProximity) {
                    chart.hoverPoint = point;
                }
            }
        },

        /**
         * Runs on mouse out from the point
         */
        onMouseOut: function () {
            var chart = this.series.chart,
                hoverPoints = chart.hoverPoints;

            this.firePointEvent('mouseOut');

            if (!hoverPoints || inArray(this, hoverPoints) === -1) { // #887, #2240
                this.setState();
                chart.hoverPoint = null;
            }
        },

        /**
         * Import events from the series' and point's options. Only do it on
         * demand, to save processing time on hovering.
         */
        importEvents: function () {
            if (!this.hasImportedEvents) {
                var point = this,
                    options = merge(point.series.options.point, point.options),
                    events = options.events,
                    eventType;

                point.events = events;

                for (eventType in events) {
                    addEvent(point, eventType, events[eventType]);
                }
                this.hasImportedEvents = true;

            }
        },

        /**
         * Set the point's state
         * @param {String} state
         */
        setState: function (state, move) {
            var point = this,
                plotX = mathFloor(point.plotX), // #4586
                plotY = point.plotY,
                series = point.series,
                stateOptions = series.options.states,
                markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
                normalDisabled = markerOptions && !markerOptions.enabled,
                markerStateOptions = markerOptions && markerOptions.states[state],
                stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
                stateMarkerGraphic = series.stateMarkerGraphic,
                pointMarker = point.marker || {},
                chart = series.chart,
                radius,
                halo = series.halo,
                haloOptions,
                newSymbol,
                pointAttr;

            state = state || NORMAL_STATE; // empty string
            pointAttr = point.pointAttr[state] || series.pointAttr[state];

            if (
                    // already has this state
                    (state === point.state && !move) ||
                    // selected points don't respond to hover
                    (point.selected && state !== SELECT_STATE) ||
                    // series' state options is disabled
                    (stateOptions[state] && stateOptions[state].enabled === false) ||
                    // general point marker's state options is disabled
                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||
                    // individual point marker's state options is disabled
                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610

                ) {
                return;
            }

            // apply hover styles to the existing point
            if (point.graphic) {
                radius = markerOptions && point.graphic.symbolName && pointAttr.r;
                point.graphic.attr(merge(
                    pointAttr,
                    radius ? { // new symbol attributes (#507, #612)
                        x: plotX - radius,
                        y: plotY - radius,
                        width: 2 * radius,
                        height: 2 * radius
                    } : {}
                ));

                // Zooming in from a range with no markers to a range with markers
                if (stateMarkerGraphic) {
                    stateMarkerGraphic.hide();
                }
            } else {
                // if a graphic is not applied to each point in the normal state, create a shared
                // graphic for the hover state
                if (state && markerStateOptions) {
                    radius = markerStateOptions.radius;
                    newSymbol = pointMarker.symbol || series.symbol;

                    // If the point has another symbol than the previous one, throw away the
                    // state marker graphic and force a new one (#1459)
                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                        stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }

                    // Add a new state marker graphic
                    if (!stateMarkerGraphic) {
                        if (newSymbol) {
                            series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
                                newSymbol,
                                plotX - radius,
                                plotY - radius,
                                2 * radius,
                                2 * radius
                            )
                            .attr(pointAttr)
                            .add(series.markerGroup);
                            stateMarkerGraphic.currentSymbol = newSymbol;
                        }

                    // Move the existing graphic
                    } else {
                        stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054
                            x: plotX - radius,
                            y: plotY - radius
                        });
                    }
                }

                if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450
                    stateMarkerGraphic.element.point = point; // #4310
                }
            }

            // Show me your halo
            haloOptions = stateOptions[state] && stateOptions[state].halo;
            if (haloOptions && haloOptions.size) {
                if (!halo) {
                    series.halo = halo = chart.renderer.path()
                        .add(chart.seriesGroup);
                }
                halo.attr(extend({
                    'fill': point.color || series.color,
                    'fill-opacity': haloOptions.opacity,
                    'zIndex': -1 // #4929, IE8 added halo above everything
                },
                haloOptions.attributes))[move ? 'animate' : 'attr']({
                    d: point.haloPath(haloOptions.size)
                });
            } else if (halo) {
                halo.attr({ d: [] });
            }

            point.state = state;
        },

        /**
         * Get the circular path definition for the halo
         * @param  {Number} size The radius of the circular halo
         * @returns {Array} The path definition
         */
        haloPath: function (size) {
            var series = this.series,
                chart = series.chart,
                plotBox = series.getPlotBox(),
                inverted = chart.inverted,
                plotX = Math.floor(this.plotX);

            return chart.renderer.symbols.circle(
                plotBox.translateX + (inverted ? series.yAxis.len - this.plotY : plotX) - size, 
                plotBox.translateY + (inverted ? series.xAxis.len - plotX : this.plotY) - size, 
                size * 2, 
                size * 2
            );
        }
    });

    /*
     * Extend the Series object with interaction
     */

    extend(Series.prototype, {
        /**
         * Series mouse over handler
         */
        onMouseOver: function () {
            var series = this,
                chart = series.chart,
                hoverSeries = chart.hoverSeries;

            // set normal state to previous series
            if (hoverSeries && hoverSeries !== series) {
                hoverSeries.onMouseOut();
            }

            // trigger the event, but to save processing time,
            // only if defined
            if (series.options.events.mouseOver) {
                fireEvent(series, 'mouseOver');
            }

            // hover this
            series.setState(HOVER_STATE);
            chart.hoverSeries = series;
        },

        /**
         * Series mouse out handler
         */
        onMouseOut: function () {
            // trigger the event only if listeners exist
            var series = this,
                options = series.options,
                chart = series.chart,
                tooltip = chart.tooltip,
                hoverPoint = chart.hoverPoint;

            chart.hoverSeries = null; // #182, set to null before the mouseOut event fires

            // trigger mouse out on the point, which must be in this series
            if (hoverPoint) {
                hoverPoint.onMouseOut();
            }

            // fire the mouse out event
            if (series && options.events.mouseOut) {
                fireEvent(series, 'mouseOut');
            }


            // hide the tooltip
            if (tooltip && !options.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                tooltip.hide();
            }

            // set normal state
            series.setState();
        },

        /**
         * Set the state of the graph
         */
        setState: function (state) {
            var series = this,
                options = series.options,
                graph = series.graph,
                stateOptions = options.states,
                lineWidth = options.lineWidth,
                attribs,
                i = 0;

            state = state || NORMAL_STATE;

            if (series.state !== state) {
                series.state = state;

                if (stateOptions[state] && stateOptions[state].enabled === false) {
                    return;
                }

                if (state) {
                    lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035
                }

                if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
                    attribs = {
                        'stroke-width': lineWidth
                    };
                    // use attr because animate will cause any other animation on the graph to stop
                    graph.attr(attribs);
                    while (series['zoneGraph' + i]) {
                        series['zoneGraph' + i].attr(attribs);
                        i = i + 1;
                    }
                }
            }
        },

        /**
         * Set the visibility of the graph
         *
         * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
         *                the visibility is toggled.
         */
        setVisible: function (vis, redraw) {
            var series = this,
                chart = series.chart,
                legendItem = series.legendItem,
                showOrHide,
                ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
                oldVisibility = series.visible;

            // if called without an argument, toggle visibility
            series.visible = vis = series.userOptions.visible = vis === UNDEFINED ? !oldVisibility : vis;
            showOrHide = vis ? 'show' : 'hide';

            // show or hide elements
            each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker'], function (key) {
                if (series[key]) {
                    series[key][showOrHide]();
                }
            });


            // hide tooltip (#1361)
            if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
                series.onMouseOut();
            }


            if (legendItem) {
                chart.legend.colorizeItem(series, vis);
            }


            // rescale or adapt to resized chart
            series.isDirty = true;
            // in a stack, all other series are affected
            if (series.options.stacking) {
                each(chart.series, function (otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                        otherSeries.isDirty = true;
                    }
                });
            }

            // show or hide linked series
            each(series.linkedSeries, function (otherSeries) {
                otherSeries.setVisible(vis, false);
            });

            if (ignoreHiddenSeries) {
                chart.isDirtyBox = true;
            }
            if (redraw !== false) {
                chart.redraw();
            }

            fireEvent(series, showOrHide);
        },

        /**
         * Show the graph
         */
        show: function () {
            this.setVisible(true);
        },

        /**
         * Hide the graph
         */
        hide: function () {
            this.setVisible(false);
        },


        /**
         * Set the selected state of the graph
         *
         * @param selected {Boolean} True to select the series, false to unselect. If
         *                UNDEFINED, the selection state is toggled.
         */
        select: function (selected) {
            var series = this;
            // if called without an argument, toggle
            series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

            if (series.checkbox) {
                series.checkbox.checked = selected;
            }

            fireEvent(series, selected ? 'select' : 'unselect');
        },

        drawTracker: TrackerMixin.drawTrackerGraph
    });

    // global variables
    extend(Highcharts, {

        // Constructors
        Color: Color,
        Point: Point,
        Tick: Tick,
        Renderer: Renderer,
        SVGElement: SVGElement,
        SVGRenderer: SVGRenderer,

        // Various
        arrayMin: arrayMin,
        arrayMax: arrayMax,
        charts: charts,
        correctFloat: correctFloat,
        dateFormat: dateFormat,
        error: error,
        format: format,
        pathAnim: pathAnim,
        getOptions: getOptions,
        hasBidiBug: hasBidiBug,
        isTouchDevice: isTouchDevice,
        setOptions: setOptions,
        addEvent: addEvent,
        removeEvent: removeEvent,
        createElement: createElement,
        discardElement: discardElement,
        css: css,
        each: each,
        map: map,
        merge: merge,
        splat: splat,
        stableSort: stableSort,
        extendClass: extendClass,
        pInt: pInt,
        svg: hasSVG,
        canvas: useCanVG,
        vml: !hasSVG && !useCanVG,
        product: PRODUCT,
        version: VERSION
    });
    
    return Highcharts;
}));

/*! ngstorage 0.3.10 | Copyright (c) 2015 Gias Kay Lee | MIT License */!function (a, b) { "use strict"; "function" == typeof define && define.amd ? define(["angular"], b) : a.hasOwnProperty("angular") ? b(a.angular) : "object" == typeof exports && (module.exports = b(require("angular"))) }(this, function (a) { "use strict"; function b(b) { return function () { var c = "ngStorage-"; this.setKeyPrefix = function (a) { if ("string" != typeof a) throw new TypeError("[ngStorage] - " + b + "Provider.setKeyPrefix() expects a String."); c = a }; var d = a.toJson, e = a.fromJson; this.setSerializer = function (a) { if ("function" != typeof a) throw new TypeError("[ngStorage] - " + b + "Provider.setSerializer expects a function."); d = a }, this.setDeserializer = function (a) { if ("function" != typeof a) throw new TypeError("[ngStorage] - " + b + "Provider.setDeserializer expects a function."); e = a }, this.get = function (a) { return e(window[b].getItem(c + a)) }, this.set = function (a, e) { return window[b].setItem(c + a, d(e)) }, this.$get = ["$rootScope", "$window", "$log", "$timeout", "$document", function (f, g, h, i, j) { function k(a) { var b; try { b = g[a] } catch (c) { b = !1 } if (b && "localStorage" === a) { var d = "__" + Math.round(1e7 * Math.random()); try { localStorage.setItem(d, d), localStorage.removeItem(d) } catch (c) { b = !1 } } return b } var l, m, n = c.length, o = k(b) || (h.warn("This browser does not support Web Storage!"), { setItem: a.noop, getItem: a.noop, removeItem: a.noop }), p = { $default: function (b) { for (var c in b) a.isDefined(p[c]) || (p[c] = a.copy(b[c])); return p.$sync(), p }, $reset: function (a) { for (var b in p) "$" === b[0] || delete p[b] && o.removeItem(c + b); return p.$default(a) }, $sync: function () { for (var a, b = 0, d = o.length; d > b; b++) (a = o.key(b)) && c === a.slice(0, n) && (p[a.slice(n)] = e(o.getItem(a))) }, $apply: function () { var b; if (m = null, !a.equals(p, l)) { b = a.copy(l), a.forEach(p, function (e, f) { a.isDefined(e) && "$" !== f[0] && (o.setItem(c + f, d(e)), delete b[f]) }); for (var e in b) o.removeItem(c + e); l = a.copy(p) } } }; return p.$sync(), l = a.copy(p), f.$watch(function () { m || (m = i(p.$apply, 100, !1)) }), g.addEventListener && g.addEventListener("storage", function (b) { if (b.key) { var d = j[0]; d.hasFocus && d.hasFocus() || c !== b.key.slice(0, n) || (b.newValue ? p[b.key.slice(n)] = e(b.newValue) : delete p[b.key.slice(n)], l = a.copy(p), f.$apply()) } }), g.addEventListener && g.addEventListener("beforeunload", function () { p.$apply() }), p }] } } return a = a && a.module ? a : window.angular, a.module("ngStorage", []).provider("$localStorage", b("localStorage")).provider("$sessionStorage", b("sessionStorage")) });
/**
 * oclazyload - Load modules on demand (lazy load) with angularJS
 * @version v1.0.9
 * @link https://github.com/ocombe/ocLazyLoad
 * @license MIT
 * @author Olivier Combe <olivier.combe@gmail.com>
 */
!function (e, n) { "use strict"; var r = ["ng", "oc.lazyLoad"], o = {}, t = [], i = [], a = [], s = [], u = e.noop, c = {}, l = [], d = e.module("oc.lazyLoad", ["ng"]); d.provider("$ocLazyLoad", ["$controllerProvider", "$provide", "$compileProvider", "$filterProvider", "$injector", "$animateProvider", function (d, f, p, m, v, y) { function L(n, o, t) { if (o) { var i, s, d, f = []; for (i = o.length - 1; i >= 0; i--) if (s = o[i], e.isString(s) || (s = E(s)), s && -1 === l.indexOf(s) && (!w[s] || -1 !== a.indexOf(s))) { var h = -1 === r.indexOf(s); if (d = g(s), h && (r.push(s), L(n, d.requires, t)), d._runBlocks.length > 0) for (c[s] = []; d._runBlocks.length > 0;) c[s].push(d._runBlocks.shift()); e.isDefined(c[s]) && (h || t.rerun) && (f = f.concat(c[s])), j(n, d._invokeQueue, s, t.reconfig), j(n, d._configBlocks, s, t.reconfig), u(h ? "ocLazyLoad.moduleLoaded" : "ocLazyLoad.moduleReloaded", s), o.pop(), l.push(s) } var p = n.getInstanceInjector(); e.forEach(f, function (e) { p.invoke(e) }) } } function $(n, r) { function t(n, r) { var o, t = !0; return r.length && (o = i(n), e.forEach(r, function (e) { t = t && i(e) !== o })), t } function i(n) { return e.isArray(n) ? M(n.toString()) : e.isObject(n) ? M(S(n)) : e.isDefined(n) && null !== n ? M(n.toString()) : n } var a = n[2][0], s = n[1], c = !1; e.isUndefined(o[r]) && (o[r] = {}), e.isUndefined(o[r][s]) && (o[r][s] = {}); var l = function (e, n) { o[r][s].hasOwnProperty(e) || (o[r][s][e] = []), t(n, o[r][s][e]) && (c = !0, o[r][s][e].push(n), u("ocLazyLoad.componentLoaded", [r, s, e])) }; if (e.isString(a)) l(a, n[2][1]); else { if (!e.isObject(a)) return !1; e.forEach(a, function (n, r) { e.isString(n) ? l(n, a[1]) : l(r, n) }) } return c } function j(n, r, o, i) { if (r) { var a, s, u, c; for (a = 0, s = r.length; s > a; a++) if (u = r[a], e.isArray(u)) { if (null !== n) { if (!n.hasOwnProperty(u[0])) throw new Error("unsupported provider " + u[0]); c = n[u[0]] } var l = $(u, o); if ("invoke" !== u[1]) l && e.isDefined(c) && c[u[1]].apply(c, u[2]); else { var d = function (n) { var r = t.indexOf(o + "-" + n); (-1 === r || i) && (-1 === r && t.push(o + "-" + n), e.isDefined(c) && c[u[1]].apply(c, u[2])) }; if (e.isFunction(u[2][0])) d(u[2][0]); else if (e.isArray(u[2][0])) for (var f = 0, h = u[2][0].length; h > f; f++) e.isFunction(u[2][0][f]) && d(u[2][0][f]) } } } } function E(n) { var r = null; return e.isString(n) ? r = n : e.isObject(n) && n.hasOwnProperty("name") && e.isString(n.name) && (r = n.name), r } function _(n) { if (!e.isString(n)) return !1; try { return g(n) } catch (r) { if (/No module/.test(r) || r.message.indexOf("$injector:nomod") > -1) return !1 } } var w = {}, O = { $controllerProvider: d, $compileProvider: p, $filterProvider: m, $provide: f, $injector: v, $animateProvider: y }, x = !1, b = !1, z = [], D = {}; z.push = function (e) { -1 === this.indexOf(e) && Array.prototype.push.apply(this, arguments) }, this.config = function (n) { e.isDefined(n.modules) && (e.isArray(n.modules) ? e.forEach(n.modules, function (e) { w[e.name] = e }) : w[n.modules.name] = n.modules), e.isDefined(n.debug) && (x = n.debug), e.isDefined(n.events) && (b = n.events) }, this._init = function (o) { if (0 === i.length) { var t = [o], a = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"], u = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/, c = function (e) { return e && t.push(e) }; e.forEach(a, function (n) { a[n] = !0, c(document.getElementById(n)), n = n.replace(":", "\\:"), "undefined" != typeof o[0] && o[0].querySelectorAll && (e.forEach(o[0].querySelectorAll("." + n), c), e.forEach(o[0].querySelectorAll("." + n + "\\:"), c), e.forEach(o[0].querySelectorAll("[" + n + "]"), c)) }), e.forEach(t, function (n) { if (0 === i.length) { var r = " " + o.className + " ", t = u.exec(r); t ? i.push((t[2] || "").replace(/\s+/g, ",")) : e.forEach(n.attributes, function (e) { 0 === i.length && a[e.name] && i.push(e.value) }) } }) } 0 !== i.length || (n.jasmine || n.mocha) && e.isDefined(e.mock) || console.error("No module found during bootstrap, unable to init ocLazyLoad. You should always use the ng-app directive or angular.boostrap when you use ocLazyLoad."); var l = function d(n) { if (-1 === r.indexOf(n)) { r.push(n); var o = e.module(n); j(null, o._invokeQueue, n), j(null, o._configBlocks, n), e.forEach(o.requires, d) } }; e.forEach(i, function (e) { l(e) }), i = [], s.pop() }; var S = function (n) { try { return JSON.stringify(n) } catch (r) { var o = []; return JSON.stringify(n, function (n, r) { if (e.isObject(r) && null !== r) { if (-1 !== o.indexOf(r)) return; o.push(r) } return r }) } }, M = function (e) { var n, r, o, t = 0; if (0 == e.length) return t; for (n = 0, o = e.length; o > n; n++) r = e.charCodeAt(n), t = (t << 5) - t + r, t |= 0; return t }; this.$get = ["$log", "$rootElement", "$rootScope", "$cacheFactory", "$q", function (n, t, a, c, d) { function f(e) { var r = d.defer(); return n.error(e.message), r.reject(e), r.promise } var p, m = c("ocLazyLoad"); return x || (n = {}, n.error = e.noop, n.warn = e.noop, n.info = e.noop), O.getInstanceInjector = function () { return p ? p : p = t.data("$injector") || e.injector() }, u = function (e, r) { b && a.$broadcast(e, r), x && n.info(e, r) }, { _broadcast: u, _$log: n, _getFilesCache: function () { return m }, toggleWatch: function (e) { e ? s.push(!0) : s.pop() }, getModuleConfig: function (n) { if (!e.isString(n)) throw new Error("You need to give the name of the module to get"); return w[n] ? e.copy(w[n]) : null }, setModuleConfig: function (n) { if (!e.isObject(n)) throw new Error("You need to give the module config object to set"); return w[n.name] = n, n }, getModules: function () { return r }, isLoaded: function (n) { var o = function (e) { var n = r.indexOf(e) > -1; return n || (n = !!_(e)), n }; if (e.isString(n) && (n = [n]), e.isArray(n)) { var t, i; for (t = 0, i = n.length; i > t; t++) if (!o(n[t])) return !1; return !0 } throw new Error("You need to define the module(s) name(s)") }, _getModuleName: E, _getModule: function (e) { try { return g(e) } catch (n) { throw (/No module/.test(n) || n.message.indexOf("$injector:nomod") > -1) && (n.message = 'The module "' + S(e) + '" that you are trying to load does not exist. ' + n.message), n } }, moduleExists: _, _loadDependencies: function (n, r) { var o, t, i, a = [], s = this; if (n = s._getModuleName(n), null === n) return d.when(); try { o = s._getModule(n) } catch (u) { return f(u) } return t = s.getRequires(o), e.forEach(t, function (o) { if (e.isString(o)) { var t = s.getModuleConfig(o); if (null === t) return void z.push(o); o = t, t.name = void 0 } if (s.moduleExists(o.name)) return i = o.files.filter(function (e) { return s.getModuleConfig(o.name).files.indexOf(e) < 0 }), 0 !== i.length && s._$log.warn('Module "', n, '" attempted to redefine configuration for dependency. "', o.name, '"\n Additional Files Loaded:', i), e.isDefined(s.filesLoader) ? void a.push(s.filesLoader(o, r).then(function () { return s._loadDependencies(o) })) : f(new Error("Error: New dependencies need to be loaded from external files (" + o.files + "), but no loader has been defined.")); if (e.isArray(o)) { var u = []; e.forEach(o, function (e) { var n = s.getModuleConfig(e); null === n ? u.push(e) : n.files && (u = u.concat(n.files)) }), u.length > 0 && (o = { files: u }) } else e.isObject(o) && o.hasOwnProperty("name") && o.name && (s.setModuleConfig(o), z.push(o.name)); if (e.isDefined(o.files) && 0 !== o.files.length) { if (!e.isDefined(s.filesLoader)) return f(new Error('Error: the module "' + o.name + '" is defined in external files (' + o.files + "), but no loader has been defined.")); a.push(s.filesLoader(o, r).then(function () { return s._loadDependencies(o) })) } }), d.all(a) }, inject: function (n) { var r = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], o = arguments.length <= 2 || void 0 === arguments[2] ? !1 : arguments[2], t = this, a = d.defer(); if (e.isDefined(n) && null !== n) { if (e.isArray(n)) { var s = []; return e.forEach(n, function (e) { s.push(t.inject(e, r, o)) }), d.all(s) } t._addToLoadList(t._getModuleName(n), !0, o) } if (i.length > 0) { var u = i.slice(), c = function f(e) { z.push(e), D[e] = a.promise, t._loadDependencies(e, r).then(function () { try { l = [], L(O, z, r) } catch (e) { return t._$log.error(e.message), void a.reject(e) } i.length > 0 ? f(i.shift()) : a.resolve(u) }, function (e) { a.reject(e) }) }; c(i.shift()) } else { if (r && r.name && D[r.name]) return D[r.name]; a.resolve() } return a.promise }, getRequires: function (n) { var o = []; return e.forEach(n.requires, function (e) { -1 === r.indexOf(e) && o.push(e) }), o }, _invokeQueue: j, _registerInvokeList: $, _register: L, _addToLoadList: h, _unregister: function (n) { e.isDefined(n) && e.isArray(n) && e.forEach(n, function (e) { o[e] = void 0 }) } } }], this._init(e.element(n.document)) }]); var f = e.bootstrap; e.bootstrap = function (n, r, o) { return e.forEach(r.slice(), function (e) { h(e, !0, !0) }), f(n, r, o) }; var h = function (n, r, o) { (s.length > 0 || r) && e.isString(n) && -1 === i.indexOf(n) && (i.push(n), o && a.push(n)) }, g = e.module; e.module = function (e, n, r) { return h(e, !1, !0), g(e, n, r) }, "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "oc.lazyLoad") }(angular, window), function (e) { "use strict"; e.module("oc.lazyLoad").directive("ocLazyLoad", ["$ocLazyLoad", "$compile", "$animate", "$parse", "$timeout", function (n, r, o, t, i) { return { restrict: "A", terminal: !0, priority: 1e3, compile: function (i, a) { var s = i[0].innerHTML; return i.html(""), function (i, a, u) { var c = t(u.ocLazyLoad); i.$watch(function () { return c(i) || u.ocLazyLoad }, function (t) { e.isDefined(t) && n.load(t).then(function () { o.enter(s, a), r(a.contents())(i) }) }, !0) } } } }]) }(angular), function (e) { "use strict"; e.module("oc.lazyLoad").config(["$provide", function (n) { n.decorator("$ocLazyLoad", ["$delegate", "$q", "$window", "$interval", function (n, r, o, t) { var i = !1, a = !1, s = o.document.getElementsByTagName("head")[0] || o.document.getElementsByTagName("body")[0]; return n.buildElement = function (u, c, l) { var d, f, h = r.defer(), g = n._getFilesCache(), p = function (e) { var n = (new Date).getTime(); return e.indexOf("?") >= 0 ? "&" === e.substring(0, e.length - 1) ? e + "_dc=" + n : e + "&_dc=" + n : e + "?_dc=" + n }; switch (e.isUndefined(g.get(c)) && g.put(c, h.promise), u) { case "css": d = o.document.createElement("link"), d.type = "text/css", d.rel = "stylesheet", d.href = l.cache === !1 ? p(c) : c; break; case "js": d = o.document.createElement("script"), d.src = l.cache === !1 ? p(c) : c; break; default: g.remove(c), h.reject(new Error('Requested type "' + u + '" is not known. Could not inject "' + c + '"')) } d.onload = d.onreadystatechange = function (e) { d.readyState && !/^c|loade/.test(d.readyState) || f || (d.onload = d.onreadystatechange = null, f = 1, n._broadcast("ocLazyLoad.fileLoaded", c), h.resolve()) }, d.onerror = function () { g.remove(c), h.reject(new Error("Unable to load " + c)) }, d.async = l.serie ? 0 : 1; var m = s.lastChild; if (l.insertBefore) { var v = e.element(e.isDefined(window.jQuery) ? l.insertBefore : document.querySelector(l.insertBefore)); v && v.length > 0 && (m = v[0]) } if (m.parentNode.insertBefore(d, m), "css" == u) { if (!i) { var y = o.navigator.userAgent.toLowerCase(); if (/iP(hone|od|ad)/.test(o.navigator.platform)) { var L = o.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), $ = parseFloat([parseInt(L[1], 10), parseInt(L[2], 10), parseInt(L[3] || 0, 10)].join(".")); a = 6 > $ } else if (y.indexOf("android") > -1) { var j = parseFloat(y.slice(y.indexOf("android") + 8)); a = 4.4 > j } else if (y.indexOf("safari") > -1) { var E = y.match(/version\/([\.\d]+)/i); a = E && E[1] && parseFloat(E[1]) < 6 } } if (a) var _ = 1e3, w = t(function () { try { d.sheet.cssRules, t.cancel(w), d.onload() } catch (e) { --_ <= 0 && d.onerror() } }, 20) } return h.promise }, n }]) }]) }(angular), function (e) { "use strict"; e.module("oc.lazyLoad").config(["$provide", function (n) { n.decorator("$ocLazyLoad", ["$delegate", "$q", function (n, r) { return n.filesLoader = function (o) { var t = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], i = [], a = [], s = [], u = [], c = null, l = n._getFilesCache(); n.toggleWatch(!0), e.extend(t, o); var d = function (r) { var o, d = null; if (e.isObject(r) && (d = r.type, r = r.path), c = l.get(r), e.isUndefined(c) || t.cache === !1) { if (null !== (o = /^(css|less|html|htm|js)?(?=!)/.exec(r)) && (d = o[1], r = r.substr(o[1].length + 1, r.length)), !d) if (null !== (o = /[.](css|less|html|htm|js)?((\?|#).*)?$/.exec(r))) d = o[1]; else { if (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || !n.jsLoader.hasOwnProperty("requirejs")) return void n._$log.error("File type could not be determined. " + r); d = "js" } "css" !== d && "less" !== d || -1 !== i.indexOf(r) ? "html" !== d && "htm" !== d || -1 !== a.indexOf(r) ? "js" === d || -1 === s.indexOf(r) ? s.push(r) : n._$log.error("File type is not valid. " + r) : a.push(r) : i.push(r) } else c && u.push(c) }; if (t.serie ? d(t.files.shift()) : e.forEach(t.files, function (e) { d(e) }), i.length > 0) { var f = r.defer(); n.cssLoader(i, function (r) { e.isDefined(r) && n.cssLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), f.reject(r)) : f.resolve() }, t), u.push(f.promise) } if (a.length > 0) { var h = r.defer(); n.templatesLoader(a, function (r) { e.isDefined(r) && n.templatesLoader.hasOwnProperty("ocLazyLoadLoader") ? (n._$log.error(r), h.reject(r)) : h.resolve() }, t), u.push(h.promise) } if (s.length > 0) { var g = r.defer(); n.jsLoader(s, function (r) { e.isDefined(r) && (n.jsLoader.hasOwnProperty("ocLazyLoadLoader") || n.jsLoader.hasOwnProperty("requirejs")) ? (n._$log.error(r), g.reject(r)) : g.resolve() }, t), u.push(g.promise) } if (0 === u.length) { var p = r.defer(), m = "Error: no file to load has been found, if you're trying to load an existing module you should use the 'inject' method instead of 'load'."; return n._$log.error(m), p.reject(m), p.promise } return t.serie && t.files.length > 0 ? r.all(u).then(function () { return n.filesLoader(o, t) }) : r.all(u)["finally"](function (e) { return n.toggleWatch(!1), e }) }, n.load = function (o) { var t, i = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], a = this, s = null, u = [], c = r.defer(), l = e.copy(o), d = e.copy(i); if (e.isArray(l)) return e.forEach(l, function (e) { u.push(a.load(e, d)) }), r.all(u).then(function (e) { c.resolve(e) }, function (e) { c.reject(e) }), c.promise; if (e.isString(l) ? (s = a.getModuleConfig(l), s || (s = { files: [l] })) : e.isObject(l) && (s = e.isDefined(l.path) && e.isDefined(l.type) ? { files: [l] } : a.setModuleConfig(l)), null === s) { var f = a._getModuleName(l); return t = 'Module "' + (f || "unknown") + '" is not configured, cannot load.', n._$log.error(t), c.reject(new Error(t)), c.promise } e.isDefined(s.template) && (e.isUndefined(s.files) && (s.files = []), e.isString(s.template) ? s.files.push(s.template) : e.isArray(s.template) && s.files.concat(s.template)); var h = e.extend({}, d, s); return e.isUndefined(s.files) && e.isDefined(s.name) && n.moduleExists(s.name) ? n.inject(s.name, h, !0) : (n.filesLoader(s, h).then(function () { n.inject(null, h).then(function (e) { c.resolve(e) }, function (e) { c.reject(e) }) }, function (e) { c.reject(e) }), c.promise) }, n }]) }]) }(angular), function (e) { "use strict"; e.module("oc.lazyLoad").config(["$provide", function (n) { n.decorator("$ocLazyLoad", ["$delegate", "$q", function (n, r) { return n.cssLoader = function (o, t, i) { var a = []; e.forEach(o, function (e) { a.push(n.buildElement("css", e, i)) }), r.all(a).then(function () { t() }, function (e) { t(e) }) }, n.cssLoader.ocLazyLoadLoader = !0, n }]) }]) }(angular), function (e) { "use strict"; e.module("oc.lazyLoad").config(["$provide", function (n) { n.decorator("$ocLazyLoad", ["$delegate", "$q", function (n, r) { return n.jsLoader = function (o, t, i) { var a = []; e.forEach(o, function (e) { a.push(n.buildElement("js", e, i)) }), r.all(a).then(function () { t() }, function (e) { t(e) }) }, n.jsLoader.ocLazyLoadLoader = !0, n }]) }]) }(angular), function (e) { "use strict"; e.module("oc.lazyLoad").config(["$provide", function (n) { n.decorator("$ocLazyLoad", ["$delegate", "$templateCache", "$q", "$http", function (n, r, o, t) { return n.templatesLoader = function (i, a, s) { var u = [], c = n._getFilesCache(); return e.forEach(i, function (n) { var i = o.defer(); u.push(i.promise), t.get(n, s).success(function (o) { e.isString(o) && o.length > 0 && e.forEach(e.element(o), function (e) { "SCRIPT" === e.nodeName && "text/ng-template" === e.type && r.put(e.id, e.innerHTML) }), e.isUndefined(c.get(n)) && c.put(n, !0), i.resolve() }).error(function (e) { i.reject(new Error('Unable to load template file "' + n + '": ' + e)) }) }), o.all(u).then(function () { a() }, function (e) { a(e) }) }, n.templatesLoader.ocLazyLoadLoader = !0, n }]) }]) }(angular), Array.prototype.indexOf || (Array.prototype.indexOf = function (e, n) { var r; if (null == this) throw new TypeError('"this" is null or not defined'); var o = Object(this), t = o.length >>> 0; if (0 === t) return -1; var i = +n || 0; if (Math.abs(i) === 1 / 0 && (i = 0), i >= t) return -1; for (r = Math.max(i >= 0 ? i : t - Math.abs(i), 0) ; t > r;) { if (r in o && o[r] === e) return r; r++ } return -1 });